{
  "type": "nomad_meta_info_1_0",
  "description": "Metainfo for the values parsed from a CP2K input file.",
  "dependencies": [ {
      "relativePath": "cp2k.general.nomadmetainfo.json"
    }],
  "metaInfos": [ {
      "description": "CP2K Basis Set Standard Format",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.BASIS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS.BASIS"
      ]
    }, {
      "description": "Name of the basis set file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.BASIS_SET_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "The contracted Gaussian basis set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Basis set type",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.BASIS_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Exponents for d functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.D_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for d functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.D_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Cutoff of overlap matrix eigenvalues included into basis",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.EPS_EIGENVALUE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Exponents for f functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.F_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for f functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.F_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Geometrical basis: starting value a in a*C^k",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.GEO_START_VALUE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Geometrical basis: factor C in a*C^k",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.GEOMETRICAL_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Number of radial grid points",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.GRID_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Number of Gaussian type functions for s, p, d, ...",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.NUM_GTO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Number of Slater type functions for s, p, d, ...",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.NUM_SLATER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Exponents for p functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.P_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for p functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.P_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Algorithm to construct the atomic radial grids",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.QUADRATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Exponents for s functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.S_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for s functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.S_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Starting index for Geometrical Basis sets",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.AE_BASIS.START_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Specify the atomic number",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.ATOMIC_NUMBER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Specifies the number of states calculated per l value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.CALCULATE_STATES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Specifies the core electrons for a pseudopotential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Method to calculate Coulomb integrals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.COULOMB_INTEGRALS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Specifies the electron configuration. Optional the multiplicity (m) and a core state [XX] can be declared",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.ELECTRON_CONFIGURATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Specify the element to be calculated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.ELEMENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Method to calculate Exchange integrals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.EXCHANGE_INTEGRALS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Specifies the largest angular momentum calculated [0-3]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.MAX_ANGULAR_MOMENTUM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Specifies the filename containing the external vxc",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.EXTERNAL_VXC.FILE_VXC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.EXTERNAL_VXC"
      ]
    }, {
      "description": "Tolerance in the equivalence of read-grid in ZMP method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.EXTERNAL_VXC.GRID_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.EXTERNAL_VXC"
      ]
    }, {
      "description": "Type of electronic structure method to be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.METHOD_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD"
      ]
    }, {
      "description": "Type of scalar relativistic method to be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.RELATIVISTIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD"
      ]
    }, {
      "description": "Which model for the coupling constant integration should be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.ADIABATIC_RESCALING.FUNCTIONAL_MODEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "Which Hybrid functional should be used. (Has to be consistent with the definitions in XC and HF).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.ADIABATIC_RESCALING.FUNCTIONAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "The point to be used along the adiabatic curve (0 &#60; Î» &#60; 1)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.ADIABATIC_RESCALING.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "Long-range parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.ADIABATIC_RESCALING.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "The cutoff on the density used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.DENSITY_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Parameter for the smoothing procedure inxc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.DENSITY_SMOOTH_CUTOFF_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Select the code for xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.FUNCTIONAL_ROUTINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "The cutoff on the gradient of the density used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.GRADIENT_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HF_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HF_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HF_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HF_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HF_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HF_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HF_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HF_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HF_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HF_INFO"
      ]
    }, {
      "description": "Accuracy of iterative RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HFX_RI.EPS_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Accuracy of geminal integral evaluation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HFX_RI.EPS_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Maximum number of iteration in RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.HFX_RI.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Parameter for short/longrange interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, longrange or shortrange).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.SCALE_COULOMB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.SCALE_GAUSSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.SCALE_LONGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL.T_C_G_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.LOAD_BALANCE.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Number of bins per process used to group atom quartets.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.LOAD_BALANCE.NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.LOAD_BALANCE.RANDOMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.MEMORY.EPS_STORAGE_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.MEMORY.MAX_DISK_SPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all the threads within a process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.MEMORY"
      ]
    }, {
      "description": "Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.MEMORY.STORAGE_LOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.MEMORY"
      ]
    }, {
      "description": "Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.MEMORY.TREAT_FORCES_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.MEMORY"
      ]
    }, {
      "description": "Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.PERIODIC.NUMBER_OF_SHELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.PERIODIC"
      ]
    }, {
      "description": "Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.PW_HFX_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.PW_HFX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.SCREENING.EPS_SCHWARZ_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.SCREENING.EPS_SCHWARZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.SCREENING"
      ]
    }, {
      "description": "Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disabled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.SCREENING.P_SCREEN_CORRECTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.SCREENING.SCREEN_ON_INITIAL_P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.SCREENING.SCREEN_P_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF.SCREENING"
      ]
    }, {
      "description": "Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.HF.TREAT_LSD_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "The cutoff on tau used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.TAU_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "The cutoff of the FFT grid used in the calculation of the nonlocal vdW functional [Ry].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Name of the kernel data file, may include a path.vdW_kernel_table.dat is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL.KERNEL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Parameters b and C of the rVV10 functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Type of functional (the corresponding kernel data file should be selected).Allows for common forms such as vdW-DF, vdW-DF2, optB88-vdW, rVV10.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Extensive output for non local functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL.VERBOSE_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Specifies the coordination number of a set of atoms for the C9 term in DFT-D3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.ATOM_COORDINATION_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Specifies parameters for atom types (in atomic units). If not provided default parameters are used (DFT-D2).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.ATOMPARM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate C9 terms in DFT-D3 model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.CALCULATE_C9_TERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3 method, if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.D3_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameters (s6,a1,s8,a2) for the DFT-D3(BJ) method, if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.D3BJ_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Cutoff value for coordination number function (DFT-D3 method)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.EPS_CN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Prefactor in exponential damping factor (DFT-D2 potential)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.EXP_PRE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Specifies the coordination number for a kind for the C9 term in DFT-D3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.KIND_COORDINATION_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate a long range correction to the DFT-D3 model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.LONG_RANGE_CORRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Name of the parameter file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PARAMETER_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "Range of potential. The cutoff will be 2 times this value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.R_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate C9 terms in DFT-D3 model using reference coordination numbers",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.REFERENCE_C9_TERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Use parameters for this specific density functional. For available D3 and D3(BJ) parameters see: http://www.thch.uni-bonn.de/tc/downloads/DFT-D3/functionals.html, http://www.thch.uni-bonn.de/tc/downloads/DFT-D3/functionalsbj.html",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.REFERENCE_FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameter, if set to zero CP2K attempts to guess the xc functional that is in use and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Type of potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Extensive output for the DFT-D2 and DFT-D3 models",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.VERBOSE_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Type of dispersion/vdW functional or potential to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.VDW_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "Calculate the condition number of the (P|Q) matrix for the RI methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.CALC_COND_NUM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Size of the column block used in the SCALAPACK block cyclic data distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.COL_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Convergence threshold for the solution of the Z-vector equations. The Z-vector equations have the form of a linear system of equations Ax=b, convergence is achieved when |Ax-b|<=EPS_CONV.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.CPHF.EPS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.CPHF"
      ]
    }, {
      "description": "Maximum number of iterations allowed for the solution of the Z-vector equations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.CPHF.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.CPHF"
      ]
    }, {
      "description": "Send big messages between processes (useful for >48 processors).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.DIRECT_CANONICAL.BIG_SEND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.DIRECT_CANONICAL"
      ]
    }, {
      "description": "Group size used in the computation of the integrals. Default is to use all processors (GROUP_SIZE=-1).A smaller group size (for example the node size), might a better choice if the actual MP2 time is large compared to integral computation time. This is usually the case if the total number of processors is not too large.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.GROUP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, TShPSC operator).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines truncation radius for the truncated TShPSC potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL.TRUNCATION_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file TShPSC.dat that contains the data for the evaluation of the TShPSC G0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL.TSHPSC_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Maximum allowed total memory usage during MP2 methods [Mb].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Which method should be used to compute the MP2 energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "Specifies the size of the auxiliary basis set automatically generated as initial guess. This will be effective only if RI_AUX_BASIS_SET in the KIND section and NUM_FUNC are not specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS.BASIS_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Target accuracy in the relative deviation of the amplitudes calculated with and without RI approximation, (more details in Chem.Phys.Lett.294(1998)143).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS.DELTA_I_REL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Target accuracy in the absolute difference between the RI-MP2 and the exact MP2 energy, DRI=ABS(E_MP2-E_RI-MP2).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS.DELTA_RI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "The derivatives of the MP2 energy with respect to the exponents of the basis are calculated numerically. The change in the exponent a_i employed for the numerical evaluation is defined as h_i=EPS_DERIV*a_i.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS.EPS_DERIV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Specifies the maximum number of steps in the RI basis optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Specifies the number of function, for each angular momentum (s, p, d ...), employed in the automatically generated initial guess. This will be effective only if RI_AUX_BASIS_SET in the KIND section is not specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS.NUM_FUNC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Number of quadrature points for the numerical integration in the RI-SOS-MP2-Laplace method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_LAPLACE.QUADRATURE_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_LAPLACE"
      ]
    }, {
      "description": "Group size for the integration in the Laplace method, that is the number of processes involved in the computation of each integration point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_LAPLACE.SIZE_INTEG_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_LAPLACE"
      ]
    }, {
      "description": "Determines the blocking used for communication in RI-MP2. Larger BLOCK_SIZE reduces communication but requires more memory. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "Threshold for discriminate if a given ij pairs of the unrelaxed MP2 density matrix has to be calculated with a canonical reformulation based on the occupied eigenvalues differences.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2.EPS_CANONICAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "Free the buffer containing the 4 center integrals used in the Hartree-Fock exchange calculation. This will be effective only for gradients calculations, since for the energy only case, the buffers are released by default. (Right now debugging only).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2.FREE_HFX_BUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "Accuracy of iterative RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.EPS_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Accuracy of geminal integral evaluation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.EPS_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Maximum number of iteration in RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Parameter for short/longrange interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, longrange or shortrange).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_COULOMB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_GAUSSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_LONGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.T_C_G_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Number of bins per process used to group atom quartets.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.RANDOMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.EPS_STORAGE_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.MAX_DISK_SPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all the threads within a process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.STORAGE_LOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.TREAT_FORCES_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC.NUMBER_OF_SHELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC"
      ]
    }, {
      "description": "Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.PW_HFX_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.PW_HFX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.EPS_SCHWARZ_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.EPS_SCHWARZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disabled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.P_SCREEN_CORRECTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.SCREEN_ON_INITIAL_P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.SCREEN_P_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.TREAT_LSD_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Use the Minimax quadrature scheme for performing the numerical integration. Maximum number of quadrature point limited to 20.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.MINIMAX_QUADRATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Matrix multiplication style for the Q matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.MM_STYLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Number of quadrature points for the numerical integration in the RI-RPA method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.QUADRATURE_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Group size for frequency integration, that is the number of processes involved in the computation of each integration point. SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.SIZE_FREQ_INTEG_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Size of the row block used in the SCALAPACK block cyclic data distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.ROW_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Scaling factor of the singlet energy component (opposite spin, OS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.SCALE_S",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Scaling factor of the triplet energy component (same spin, SS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.SCALE_T",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "The cutoff of the finest grid level in the MP2 gpw integration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines a threshold for the DBCSR based multiply (usually 10 times smaller than EPS_GRID).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW.EPS_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines a threshold for the GPW based integration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW.EPS_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "How much output is written by the individual groups.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW.PRINT_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines the grid at which a Gaussian is mapped.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88"
      ]
    }, {
      "description": "Potential parameter in erf(omega*r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "Defines the parameter of the adiabatic curve",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "Potential parameter in erf(omega*r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "switches between the B97 and Grimme parametrization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "scales the exchange part of the functional, if -1 the default for the given parametrization is used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "Defines the cutoff radius for the truncation. If put to zero, the standard full range potential will be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "Parameter in the exchange hole. Usually this is put to 1.0 or 0.8",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BEEF.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BEEF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BEEF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BEEF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.CS1.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.CS1"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "Parameter for Becke Roussel hole",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "Which version of the parameters should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.HCTH.PARAMETER_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.HCTH"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.HCTH.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.HCTH"
      ]
    }, {
      "description": "Which one of the KE_GGA functionals should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_GGA.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_GGA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_GGA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_GGA"
      ]
    }, {
      "description": "names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "parameters of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "scaling factors of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "parameters of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "scaling factors of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP"
      ]
    }, {
      "description": "Defines the parameter of the adiabatic curve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP_ADIABATIC.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP_ADIABATIC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP_ADIABATIC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP_ADIABATIC"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.OPTX.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.OPTX"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.OPTX.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.OPTX"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.P86C.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.P86C"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.P86C.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.P86C"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PADE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PADE"
      ]
    }, {
      "description": "switches between the different parametrizations of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "Which one of parametrizations should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "Scaling of the energy functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "Which one of parametrizations should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "Shortcut for the most common functional combinations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TFW.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TFW"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "Which version of the VWN functional should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN.FUNCTIONAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "Value of the xa parameter (this does not change the exponent, just the mixing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA.XA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "Which one of the XGGA functionals should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XGGA.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XGGA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XGGA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XGGA"
      ]
    }, {
      "description": "screening parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "scales the exchange part of the original hole PBE-functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE.SCALE_X0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "Uses a finer grid only to calculate the xc",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_GRID.USE_FINER_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_GRID"
      ]
    }, {
      "description": "The method used to compute the derivatives",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_GRID.XC_DERIV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_GRID"
      ]
    }, {
      "description": "The density smoothing used for the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_GRID.XC_SMOOTH_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_GRID"
      ]
    }, {
      "description": "How to determine the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_POTENTIAL.ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL"
      ]
    }, {
      "description": "Value of the alpha parameter (default = 1.19).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Value of the beta parameter (default = 0.01).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Value of the K_rho parameter (default = 0.42).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP.K_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "read external density from density matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.ZMP.DM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.ZMP"
      ]
    }, {
      "description": "Specifies the filename containing the target density",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.ZMP.FILE_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.ZMP"
      ]
    }, {
      "description": "Tolerance in the equivalence of read-grid in ZMP method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.ZMP.GRID_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.ZMP"
      ]
    }, {
      "description": "Parameter used for the constraint in ZMP method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.ZMP.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.ZMP"
      ]
    }, {
      "description": "Specifies the filename containing the restart file density",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.METHOD.ZMP.RESTART.FILE_RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.ZMP.RESTART"
      ]
    }, {
      "description": "Damping parameter for extrapolation method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.OPTIMIZATION.DAMPING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.OPTIMIZATION"
      ]
    }, {
      "description": "Starting DIIS method at convergence to EPS_DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.OPTIMIZATION.EPS_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.OPTIMIZATION"
      ]
    }, {
      "description": "Convergence criterion for SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.OPTIMIZATION.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.OPTIMIZATION"
      ]
    }, {
      "description": "Maximum number of iterations for optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.OPTIMIZATION.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.OPTIMIZATION"
      ]
    }, {
      "description": "Maximum number of DIIS vectors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.OPTIMIZATION.N_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.OPTIMIZATION"
      ]
    }, {
      "description": "Definition of confinement potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POTENTIAL.CONFINEMENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POTENTIAL"
      ]
    }, {
      "description": "CP2K Pseudo Potential Standard Format (GTH, ALL or KG)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POTENTIAL.GTH_POTENTIAL.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POTENTIAL.GTH_POTENTIAL"
      ]
    }, {
      "description": "Name of the pseudo potential file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POTENTIAL.POTENTIAL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POTENTIAL"
      ]
    }, {
      "description": "The name of the pseudopotential for the defined kind.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POTENTIAL.POTENTIAL_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POTENTIAL"
      ]
    }, {
      "description": "Pseudopotential type",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POTENTIAL.PSEUDO_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POTENTIAL"
      ]
    }, {
      "description": "Final accuracy requested in optimization (RHOEND)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Maximum number of function evaluations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.MAX_FUN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Multiply Rcov integration limit for charge conservation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.RCOV_MULTIPLICATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Initial step size for search algorithm (RHOBEG)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Target accuracy for semicore state eigenvalues in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.TARGET_POT_SEMICORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Target accuracy for valence state eigenvalues in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.TARGET_POT_VALENCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Target accuracy for virtual state eigenvalues in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.TARGET_POT_VIRTUAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for different electronic states in optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_ELECTRON_CONFIGURATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for different methods in optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for node mismatch in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_POT_NODE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for semi core states in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_POT_SEMICORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for valence states in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_POT_VALENCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for virtual states in pseudopotential optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_POT_VIRTUAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "Weight for the wavefunctions at r=0 (only occupied states)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.POWELL.WEIGHT_PSIR0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.POWELL"
      ]
    }, {
      "description": "CP2K Basis Set Standard Format",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.BASIS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS.BASIS"
      ]
    }, {
      "description": "Name of the basis set file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.BASIS_SET_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "The contracted Gaussian basis set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Basis set type",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.BASIS_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Exponents for d functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.D_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for d functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.D_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Cutoff of overlap matrix eigenvalues included into basis",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.EPS_EIGENVALUE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Exponents for f functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.F_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for f functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.F_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Geometrical basis: starting value a in a*C^k",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.GEO_START_VALUE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Geometrical basis: factor C in a*C^k",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.GEOMETRICAL_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Number of radial grid points",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.GRID_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Number of Gaussian type functions for s, p, d, ...",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.NUM_GTO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Number of Slater type functions for s, p, d, ...",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.NUM_SLATER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Exponents for p functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.P_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for p functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.P_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Algorithm to construct the atomic radial grids",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.QUADRATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Exponents for s functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.S_EXPONENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Main quantum numbers for s functions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.S_QUANTUM_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Starting index for Geometrical Basis sets",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.PP_BASIS.START_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Type of run that you want to perform [ENERGY,BASIS_OPTIMIZATION,PSEUDOPOTENTIAL_OPTIMIZATION,,...]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_ATOM.RUN_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Activates the debugging of the atomic forces",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.DEBUG_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG"
      ]
    }, {
      "description": "Activates the debugging of the stress tensor",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.DEBUG_STRESS_TENSOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG"
      ]
    }, {
      "description": "Increment for the calculation of the numerical derivatives",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG"
      ]
    }, {
      "description": "The mismatch between the numerical and the analytical value is not checked for analytical values smaller than this threshold value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.EPS_NO_ERROR_CHECK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Stop the debug run when a mismatch between the numerical and the analytical value is detected",
      "dtypeStr": "C",
      "name": "x_cp2k_input_DEBUG.STOP_ON_MISMATCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_DEBUG"
      ]
    }, {
      "description": "Specifies the name of an additional restart file from which selected input sections are read in binary format (see SPLIT_RESTART_FILE).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.BINARY_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the given path from the EXTERNAL file. Allows a major flexibility for restarts.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.CUSTOM_PATH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts information for AVERAGES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_AVERAGES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts positions and velocities of the Band.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the barostat thermostat from the external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_BAROSTAT_THERMOSTAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the barostat from the external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_BAROSTAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts information for BSSE calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the cell (and cell_ref) from the EXTERNAL file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts constraint section. It's necessary when doing restraint calculation to have a perfect energy conservation. For constraints only it's use is optional.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_CONSTRAINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Takes the positions of the cores from the external file (only if shell-model)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_CORE_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Takes the velocities of the shells from the external file (only if shell-model)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_CORE_VELOCITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the counters in MD schemes",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_COUNTERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "This keyword controls the default value for all possible  restartable keywords, unless explicitly defined. For example setting this keyword to .FALSE. does not restart any quantity. If, at the  same time, one keyword is set to .TRUE. only that quantity will be restarted.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_DEFAULT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts information for DIMER geometry optimizations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_DIMER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Specifies the name of restart file (or any other input file) to be read. Only fields relevant to a restart will be used (unless switched off with the keywords in this section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts helium density distributions from PINT%HELIUM%RHO.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_HELIUM_DENSITIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart helium forces exerted on the solute from PINT%HELIUM%FORCE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_HELIUM_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart helium permutation state from PINT%HELIUM%PERM.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_HELIUM_PERMUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart helium positions from PINT%HELIUM%COORD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_HELIUM_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts helium random number generators from PINT%HELIUM%RNG_STATE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_HELIUM_RNG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts hills from a previous metadynamics run from the EXTERNAL file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart with the optimize input variables",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_OPTIMIZE_INPUT_VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart GLE thermostat for beads from PINT%GLE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_PINT_GLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart Nose thermostat for beads from PINT%NOSE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_PINT_NOSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart bead positions from PINT%BEADS%COORD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_PINT_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restart bead velocities from PINT%BEADS%VELOCITY.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_PINT_VEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Takes the positions from the external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the following specific QMMM info: translation vectors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_QMMM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the random number generator from the external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_RANDOMG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts information for REAL TIME PROPAGATION and EHRENFEST DYNAMICS.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_RTP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Takes the positions of the shells from the external file (only if shell-model)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_SHELL_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the shell thermostat from the external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_SHELL_THERMOSTAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Takes the velocities of the shells from the external file (only if shell-model)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_SHELL_VELOCITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts the nose thermostats of the particles from the EXTERNAL file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_THERMOSTAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Takes the velocities from the external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_VEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "Restarts walkers informations from a previous metadynamics run from the EXTERNAL file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_EXT_RESTART.RESTART_WALKERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_EXT_RESTART"
      ]
    }, {
      "description": "If farming should process all jobs in a cyclic way, stopping only if MAX_JOBS_PER_GROUP is exceeded.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.CYCLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "Restart a farming job (and should pick up where the previous left off)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.DO_RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "gives the exact number of processors for each group.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.GROUP_PARTITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "Gives the preferred size of a working group, groups will always be equal or larger than this size.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.GROUP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "specifies a list of JOB_IDs on which the current job depends. The current job will not be executed before all the dependencies have finished. The keyword requires a MASTER_SLAVE farming run. Beyond the default case, some special cases might arise: 1) circular dependencies will lead to a deadlock. 2) This keyword is not compatible with CYCLE. 3) MAX_JOBS_PER_GROUP is ignored (though only a total of MAX_JOBS_PER_GROUP*NGROUPS jobs will be executed) 4) dependencies on jobs that will not be executed (due to RESTART or MAX_JOBS_PER_GROUP) are ignored. Additionally, note that, on some file systems,  output (restart) files might not be immediately available on all compute nodes,potentially resulting in unexpected failures.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.JOB.DEPENDENCIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.JOB"
      ]
    }, {
      "description": "the directory in which the job should be executed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.JOB.DIRECTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.JOB"
      ]
    }, {
      "description": "the filename of the input file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.JOB.INPUT_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.JOB"
      ]
    }, {
      "description": "An ID used to indentify a job in DEPENDENCIES. JOB_IDs do not need to be unique, dependencies will be on all jobs with a given ID. If no JOB_ID is given, the index of the &JOB section in the input file will be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.JOB.JOB_ID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.JOB"
      ]
    }, {
      "description": "the filename of the output file, if not specified will use the project name in the &GLOBAL section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.JOB.OUTPUT_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.JOB"
      ]
    }, {
      "description": "If a master-slave setup should be employed, in which one process is used to distribute the tasks. This is most useful to load-balance if not all jobs have the same length, and a lot of CPUs/groups are availabe.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.MASTER_SLAVE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "maximum number of jobs executed per group",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.MAX_JOBS_PER_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "Gives the preferred number of working groups.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.NGROUPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.RESTART"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING.RESTART"
      ]
    }, {
      "description": "Name of the restart file to use for restarting a FARMING run. If not specified the name is determined from PROJECT name.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "Time to wait [s] for a new task if no task is currently available, make this zero if no clock is available",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FARMING.WAIT_TIME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "The total charge for each fragment.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.BSSE.CONFIGURATION.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE.CONFIGURATION"
      ]
    }, {
      "description": "Specifies the global configuration using 1 or 0.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.BSSE.CONFIGURATION.GLB_CONF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE.CONFIGURATION"
      ]
    }, {
      "description": "Specify for each fragment the multiplicity. Two times the total spin plus one. Specify 3 for a triplet, 4 for a quartet,and so on. Default is 1 (singlet) for an even number and 2 (doublet) for an odd number of electrons.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.BSSE.CONFIGURATION.MULTIPLICITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE.CONFIGURATION"
      ]
    }, {
      "description": "Specifies the subconfiguration using 1 or 0 belonging to the global configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.BSSE.CONFIGURATION.SUB_CONF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE.CONFIGURATION"
      ]
    }, {
      "description": "Specifies a list of atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.BSSE.FRAGMENT.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE.FRAGMENT"
      ]
    }, {
      "description": "The energy computed for each fragment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.BSSE.FRAGMENT_ENERGIES.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE.FRAGMENT_ENERGIES"
      ]
    }, {
      "description": "Specifies the algorithm to update block-diagonal ALMOs during the SCF procedure.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Target value of the MAX norm of the error",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS.EPS_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS"
      ]
    }, {
      "description": "Maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS"
      ]
    }, {
      "description": "Number of error vectors to be used in the DIIS optimization procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS.N_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS"
      ]
    }, {
      "description": "Various methods to compute step directions in the PCG optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.CONJUGATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Target value of the MAX norm of the error",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.EPS_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Target value of the gradient norm during the linear search",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.LIN_SEARCH_EPS_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "The size of the first step in the linear search",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.LIN_SEARCH_STEP_SIZE_GUESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Maximum number of iterations in the outer loop. Use the outer loop to update the preconditioner and reset the conjugator. This can speed up convergence significantly.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.MAX_ITER_OUTER_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Select a preconditioner for the conjugate gradient optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "The method to generate initial ALMOs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_SCF_GUESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Methods to reintroduce electron delocalization, which is excluded with the block-diagonal ALMO reference. Electron delocalization can be computed using either fully delocalized MOs or spatially restricted ALMOs (called extended ALMOs or XALMOs). All methods below use a PCG optimizer controlled by XALMO_OPTIMIZER_PCG. The only exception is the non-iterative XALMO_1DIAG.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.DELOCALIZE_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Threshold for the matrix sparsity filter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.EPS_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Various methods to compute step directions in the PCG optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.CONJUGATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Target value of the MAX norm of the error",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.EPS_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Target value of the gradient norm during the linear search",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.LIN_SEARCH_EPS_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "The size of the first step in the linear search",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.LIN_SEARCH_STEP_SIZE_GUESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Maximum number of iterations in the outer loop. Use the outer loop to update the preconditioner and reset the conjugator. This can speed up convergence significantly.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.MAX_ITER_OUTER_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Select a preconditioner for the conjugate gradient optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG"
      ]
    }, {
      "description": "Controls the localization radius of XALMOs: R_cutoff = XALMO_R_CUTOFF_FACTOR*(radius(at1)+radius(at2))",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_R_CUTOFF_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Method that shall be used for wavefunction fitting. Use MO_DIAG for MD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD.ADMM_PURIFICATION_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD"
      ]
    }, {
      "description": "Specifies a list of atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD.BLOCK_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD"
      ]
    }, {
      "description": "Define accuracy of DBCSR operations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD.EPS_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD"
      ]
    }, {
      "description": "Exchange functional which is used for the ADMM correction.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD.EXCH_CORRECTION_FUNC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD"
      ]
    }, {
      "description": "Scaling of the exchange correction calculated by the auxiliary density matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD.EXCH_SCALING_MODEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD"
      ]
    }, {
      "description": "Method that shall be used for wavefunction fitting. Use BASIS_PROJECTION for MD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD"
      ]
    }, {
      "description": "Name of the basis set file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.BASIS_SET_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "The total charge of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Cutoff for charge fit in G-space.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.GCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING"
      ]
    }, {
      "description": "Specifies the smallest radius of the gaussian used in the fit. All other radius are obtained with the progression factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.MIN_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING"
      ]
    }, {
      "description": "Specifies the numbers of gaussian used to fit the QM density for each atomic site.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.NUM_GAUSS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING"
      ]
    }, {
      "description": "Specifies the progression factor for the gaussian exponent for each atomic site.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PFACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Prints information regarding the condition numbers of the A matrix (to be inverted)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO.CONDITION_NUMBER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Specifies all the radius of the gaussian used in the fit for each atomic site. The use of this keyword disables all other keywords of this section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.DENSITY_FITTING.RADII",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING"
      ]
    }, {
      "description": "Last step the field is applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.CONSTANT_ENV.END_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.CONSTANT_ENV"
      ]
    }, {
      "description": "First step the field is applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.CONSTANT_ENV.START_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.CONSTANT_ENV"
      ]
    }, {
      "description": "Shape of the efield pulse",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.ENVELOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "Width of the gaussian",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.GAUSSIAN_ENV.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.GAUSSIAN_ENV"
      ]
    }, {
      "description": "Center of the gaussian envelop (maximum of the gaussian)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.GAUSSIAN_ENV.T0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.GAUSSIAN_ENV"
      ]
    }, {
      "description": "Intensity of the electric field in W*cm-2 which corresponds to a maximal amplitude in a.u. of sqrt(I/(3.50944*10^16))",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.INTENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "phase offset of the cosine given in multiples of pi",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.PHASE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "Polarisation vector of electric field",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.POLARISATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "Step when the field reaches the full strength",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV.END_STEP_IN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV"
      ]
    }, {
      "description": "Step when the field disappears",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV.END_STEP_OUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV"
      ]
    }, {
      "description": "Step when the electric field starts to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV.START_STEP_IN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV"
      ]
    }, {
      "description": "Step when the field starts to vanish",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV.START_STEP_OUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV"
      ]
    }, {
      "description": "Wavelength of efield field",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EFIELD.WAVELENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "If excitations should be calculated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXCITATIONS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Add the Fermi-Amaldi contribution to the Hartree potential.It leads to a more stable convergence.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY.FERMI_AMALDI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY"
      ]
    }, {
      "description": "Specifies the filename containing the target density in *.cube format.In the MGRID section it must be imposed NGRID 1, as it works with onlyone grid. The number of points in each direction, and the spacing mustbe previously defined choosing the plane waves cut-off in section MGRIDkeyword CUTOFF, and the cube dimention in section SUBSYS / CELL / keyword ABC",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY.FILE_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY"
      ]
    }, {
      "description": "Lagrange multiplier defined in the constraint ZMP method. When starting, usesmall values when starting from scratch (around 5,10). Then gradually increasethe values depending, restarting from the previous calculation with the smallervalue. To choose the progressive values of LAMBDA look at the convergence of the eigenvalues.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY"
      ]
    }, {
      "description": "Specify which kind of constraint to solve the ZMP equation. The COULOMB defaultoption is more stable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY.ZMP_CONSTRAINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Specifies the functional form in mathematical notation. Variables must be the atomic coordinates (X,Y,Z) of the grid.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Switch for reading the external potential from file pot.cube. The values of the potential must be on the grid points of the realspace grid.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.READ_FROM_CUBE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "A factor for scaling the the external potential that is read from file.The value of the potential at each grid point is multiplied by this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.SCALING_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Specifies the external potential as STATIC or time dependent. At the moment only static potentials are implemented.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.STATIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "The *.cube filename containing the v_xc potential. This works onlywith NGRID 1 imposed in the MGRID section. The number of points in eachdirection, and the spacing must equal to those previously used in the ZMPcalculation and defined through the plane wave cut-off and the cube dimensionrespectively set in section MGRID / keyword CUTOFF, and in section SUBSYS /CELL / keyword ABC",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.EXTERNAL_VXC.FILE_VXC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_VXC"
      ]
    }, {
      "description": "Name of the geminal basis set file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.GEMINAL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Which algorithm to use for coloring.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KG_METHOD.COLORING_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KG_METHOD"
      ]
    }, {
      "description": "Algorithm to use for the calculation of the nonadditive kinetic energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KG_METHOD.TNADD_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KG_METHOD"
      ]
    }, {
      "description": "Accuracy in symmetry determination.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.EPS_GEO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Use full non-reduced kpoint grid.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.FULL_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Specify kpoint coordinates and weight.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.KPOINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Number of processors to be used for a single kpoint. Value=-1 (minimum number of processes). Value=0 (maximum number of processes). Value=n (exactly n processes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.PARALLEL_GROUP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Kpoint scheme to be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.SCHEME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Use symmetry to reduce the number of kpoints.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.SYMMETRY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Verbose output information.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.VERBOSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "Use real/complex wavefunctions if possible.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.KPOINTS.WAVEFUNCTIONS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS"
      ]
    }, {
      "description": "scale angles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.CRAZY_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Use diagonalization (slow) or pade based calculation of matrix exponentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.CRAZY_USE_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Select the orbitals to be localized within the given energy range.This type of selection cannot be added on top of the selection through a LIST. It reads to reals that are lower and higher boundaries of the energy range.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.ENERGY_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Tolerance used in the convergence criterium of the localization methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.EPS_LOCALIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Tolerance in the occupation number to select only fully occupied orbitals for the rotation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.EPS_OCCUPATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Use Jacobi method in case no convergence was achieved by using the crazy rotations method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.JACOBI_FALLBACK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Indexes of the unoccupied states to be localized, up to now only valid in combination with GPW. This keyword has to be present if unoccupied states should be localized. This keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.LIST_UNOCCUPIED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Indexes of the occupied wfn to be localizedThis keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "File name where to read the MOS fromwhich to restart the localization procedure for occupied states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.LOCHOMO_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "File name where to read the MOS fromwhich to restart the localization procedure for unoccupied states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.LOCLUMO_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Largest allowed angle for the crazy rotations algorithm (smaller is slower but more stable).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.MAX_CRAZY_ANGLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Maximum number of iterations used for localization methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Method of optimization if any",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Requires the maximization of the spread of the wfn",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.MIN_OR_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Type of opertator which defines the spread functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.OPERATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Every how many iterations of the localization algorithm(Jacobi) the tolerance value is printed out",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.OUT_ITER_EACH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Restart the localization from a set of orbitals read from a localization restart file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "controls the activation of the MOS localization procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Which states to localize, LUMO up to now only available in GPW",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.STATES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "Generate an improved initial guess based on a history of results, which is useful during MD.Will only work if the number of states to be localized remains constant.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOCALIZE.USE_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE"
      ]
    }, {
      "description": "The scaling factors for each term added to the total energy.This list should contain one number for each term added to the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOW_SPIN_ROKS.ENERGY_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOW_SPIN_ROKS"
      ]
    }, {
      "description": "for each singly occupied orbital, specify if this should be an alpha (=1) or a beta (=2) orbitalThis keyword should be repeated, each repetition corresponding to an additional term.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LOW_SPIN_ROKS.SPIN_CONFIGURATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LOW_SPIN_ROKS"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS"
      ]
    }, {
      "description": "Number of points in the computed DOS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS.N_GRIDPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS"
      ]
    }, {
      "description": "Order of the polynomial expansion.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.N_CHEBYSHEV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "Upper bounds of the energy ranges of interest.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.MAX_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "Lower bounds of the energy ranges of interest.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.MIN_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE.STRIDE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE"
      ]
    }, {
      "description": "Allows for dynamic EPS_FILTER. Updates the filter factor every scf-newton step by FILTER_FACTOR=FILTER_FACTOR*FILTER_FACTOR_SCALE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS.FILTER_FACTOR_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS"
      ]
    }, {
      "description": "Allows to set a seperate EPS_FILTER in the newton iterations. The new EPS is EPS_FILTER*FILTER_FACTOR.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS.FILTER_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS"
      ]
    }, {
      "description": "Line serch type used in the curvy_setp optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS.LINE_SEARCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS"
      ]
    }, {
      "description": "Lowest EPS_FILTER in dynamic filtering. Given as multiple of EPS_FILTER: EPS_FILTER_MIN=EPS_FILTER*MIN_FILTER",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS.MIN_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS"
      ]
    }, {
      "description": "Minimal eigenvalue shift for the Hessian in the Newton iteration. Useful for small band gap systems (0.5-1.0 recommended).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS.MIN_HESSIAN_SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS"
      ]
    }, {
      "description": "Number of stored matrices in the Baker-Campbell-Hausdorff series. Reduces the BCH evaluation during line search but can be memory intense.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS.N_BCH_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS"
      ]
    }, {
      "description": "Should the threshold for the purification be chosen dynamically",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.DYNAMIC_THRESHOLD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Threshold on the convergence to start using DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.EPS_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Threshold used for filtering matrix operations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.EPS_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Threshold used for lanczos estimates.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.EPS_LANCZOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "target accuracy for the scf convergence. Change of the total energy per electron",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Number of previous matrices used for the ASPC extrapolation of the initial guess. 0 implies that an atomic guess is used at each step. low (1-2) will result in a drift of the constant of motion during MD. high (>5) might be somewhat unstable, leading to more SCF iterations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.EXTRAPOLATION_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Should the calculation be performed at fixed chemical potential, or should it be found fixing the number of electrons",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.FIXED_MU",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Iteration cycle to start DIIS Kohn-Sham matrix update",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.INI_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Perform DIIS within linear scaling SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.LS_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Specify how atomic blocks should be clustered in the used matrices, in order to improve flop rate, and possibly speedup the matrix multiply. Note that the atomic s_preconditioner can not be used.Furthermore, since screening is on matrix blocks, slightly more accurate results can be expected with molecular.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.MATRIX_CLUSTER_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Size of LS_DIIS buffer",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.MAX_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Maximum number of lanczos iterations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.MAX_ITER_LANCZOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Maximum number of SCF iteration to be performed for one optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.MAX_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Mixing density matrices uses the specified fraction in the SCF procedure.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.MIXING_FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Value (or initial guess) for the chemical potential, i.e. some suitable energy between HOMO and LUMO energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.MU",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Minimal number of density mixing before start DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.NMIXING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Should the purification be performed non-monotonically. Relevant for TC2 only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.NON_MONOTONIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Do a scan of the chemical potential after the SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.PERFORM_MU_SCAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Scheme used to purify the Kohn-Sham matrix into the density matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.PURIFICATION_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Run the sparsity report at the end of the SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.REPORT_ALL_SPARSITIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Read the density matrix before the (first) SCF.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.RESTART_READ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Write the density matrix at the end of the SCF (currently requires EXTRAPOLATION_ORDER>0). Files might be rather large.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.RESTART_WRITE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Method used to compute the inverse of S.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.S_INVERSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Preconditions S with some appropriate form.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.S_PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Order of the sqrt iteration, should be 2..5, 3 or 5 recommended",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.SIGN_SQRT_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Matrices used within the LS code can be either double or single precision.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.LS_SCF.SINGLE_PRECISION_MATRICES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "If the grids should be commensurate. If true overrides the progression factor and the cutoffs of the sub grids",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.COMMENSURATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "The cutoff of the finest grid level. Default value for SE or DFTB calculation is 1.0 [Ry].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "List of cutoff values to set up multigrids manually",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.MULTIGRID_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "Activate a manual setting of the multigrids",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.MULTIGRID_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "The number of multigrids to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.NGRIDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "Factor used to find the cutoff of the multigrids that where not given explicitly",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.PROGRESSION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "If both rho and rho_gspace are needed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.REALSPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "Determines the grid at which a Gaussian is mapped, giving the cutoff used for a gaussian with alpha=1. A value 50+-10Ry might be required for highly accurate results,  Or for simulations with a variable cell. Versions prior to 2.3 used a default of 30Ry.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "Specifies the number of slices in the x, y and z directions.-1 specifies that any number of slices is OK.If a given distribution can not be satisfied, a replicated grid will result.Also see LOCK_DISTRIBUTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.RS_GRID.DISTRIBUTION_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID"
      ]
    }, {
      "description": "Parallelization strategy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.RS_GRID.DISTRIBUTION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID"
      ]
    }, {
      "description": "Can be used to reduce the halo of the distributed grid (experimental features).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.RS_GRID.HALO_REDUCTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID"
      ]
    }, {
      "description": "Expert use only, only basic QS deals correctly with a non-default value.If the distribution is locked, a grid will have the same distribution asthe next finer multigrid (provided it is distributed).If unlocked, all grids can be distributed freely.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.RS_GRID.LOCK_DISTRIBUTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID"
      ]
    }, {
      "description": "If the multigrid-level of a grid is larger than the parameter, it will not be distributed in the automatic scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.RS_GRID.MAX_DISTRIBUTED_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID"
      ]
    }, {
      "description": "A grid will only be distributed if the memory usage for that grid (including halo) is smaller than a replicated grid by this parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.RS_GRID.MEMORY_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID"
      ]
    }, {
      "description": "Skip load balancing on distributed multigrids, which might be memory intensive.If not explicitly specified, runs using more than 1024 MPI tasks will default to .TRUE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MGRID.SKIP_LOAD_BALANCE_DISTRIBUTED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "Two times the total spin plus one. Specify 3 for a triplet, 4 for a quartet, and so on. Default is 1 (singlet) for an even number and 2 (doublet) for an odd number of electrons.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.MULTIPLICITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Intensity of the electric field in a.u",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.PERIODIC_EFIELD.INTENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.PERIODIC_EFIELD"
      ]
    }, {
      "description": "Polarisation vector of electric field",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.PERIODIC_EFIELD.POLARISATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.PERIODIC_EFIELD"
      ]
    }, {
      "description": "Method employed for the calculation of the DFT+U contribution",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.PLUS_U_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "alpha parameter associated with Ewald (EWALD|PME|SPME). Recommended for small systems is is alpha = 3.5 / r_cut. Tuning alpha, r_cut and gmax is needed to obtain O(N**1.5) scaling for ewald.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "tolerance of gaussians for fft interpolation (PME only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "Expected accuracy in the Ewald sum. This number affects only the calculation of the cutoff for the real-space term of the ewald summation (EWALD|PME|SPME) as well as the construction of the neighbor lists (if the cutoff for non-bonded terms is smaller than the value employed to compute the EWALD real-space term). This keyword has no effect on the reciprocal space term (which can be tuned independently).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.EWALD_ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "The type of ewald you want to perform.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.EWALD_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "number of grid points (SPME and EWALD). If a single number is specified,the same number of points is used for all three directions on the grid.If three numbers are given, each direction can have a different number of points.The number of points needs to be FFTable (which depends on the library used) and odd for EWALD.The optimal number depends e.g. on alpha and the size of the cell. 1 point per Angstrom is common.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.GMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "Specify the rmsd threshold for the derivatives of the energy towards the Cartesian dipoles components",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES.EPS_POL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the maximum number of iterations for induced dipoles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES.MAX_IPOL_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the maximum level of multipoles expansion used  for the electrostatics.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES.MAX_MULTIPOLE_EXPANSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the method to obtain self consistent induced multipole moments.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES.POL_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Controls the activation of the Multipoles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "number of grid points on small mesh (PME only), should be odd.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.NS_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "order of the beta-Euler spline (SPME only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.O_SPLINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "Explicitly provide the real-space cutoff of the ewald summation (EWALD|PME|SPME). If present, overwrites the estimate of EWALD_ACCURACY and may affect the construction of the neighbor lists for non-bonded terms (in FIST), if the value specified is larger than the cutoff for non-bonded interactions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "Specifies the number of slices in the x, y and z directions.-1 specifies that any number of slices is OK.If a given distribution can not be satisfied, a replicated grid will result.Also see LOCK_DISTRIBUTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID.DISTRIBUTION_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Parallelization strategy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID.DISTRIBUTION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Can be used to reduce the halo of the distributed grid (experimental features).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID.HALO_REDUCTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Expert use only, only basic QS deals correctly with a non-default value.If the distribution is locked, a grid will have the same distribution asthe next finer multigrid (provided it is distributed).If unlocked, all grids can be distributed freely.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID.LOCK_DISTRIBUTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "If the multigrid-level of a grid is larger than the parameter, it will not be distributed in the automatic scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID.MAX_DISTRIBUTED_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "A grid will only be distributed if the memory usage for that grid (including halo) is smaller than a replicated grid by this parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID.MEMORY_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Convergence parameter ALPHA*RMIN. Default value 7.0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MT.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MT"
      ]
    }, {
      "description": "Specify the multiplicative factor for the CUTOFF keyword in MULTI_GRID  section. The result gives the cutoff at which the 1/r non-periodic FFT3D is evaluated.Default is 2.0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MT.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MT"
      ]
    }, {
      "description": "Evaluates the Gterm in the Ewald Scheme analytically instead of using Splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.ANALYTICAL_GTERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Precision achieved in the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.EWALD_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "Specifies the number of grid points used for the Interpolation of the G-space term",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.NGRIDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Real space cutoff for the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "Specify the directions on wich apply PBC. Important notice,  this only applies to the electrostatics. See the CELL section to specify the periodicity used for e.g. the pair lists. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON"
      ]
    }, {
      "description": "Specify which kind of solver to use to solve the Poisson equation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.POISSON_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON"
      ]
    }, {
      "description": "Type of scaling function used in the wavelet approach, the total energy depends on this choice,and the convergence with respect to cutoff depends on the selected scaling functions.Possible values are 8,14,16,20,24,30,40,50,60,100",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POISSON.WAVELET.SCF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.WAVELET"
      ]
    }, {
      "description": "Name of the pseudo potential file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.POTENTIAL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Perform ALMO SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.ALMO_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW: Exponent for hard compensation charge",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.ALPHA0_HARD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Selects BCSR pathway.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BCSR_CODE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "Defines the the coefficient of the atom in the atom list (default is one)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "Check the BCSR code on actual data, once per QS run.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.CHECK_BCSR_CODE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Specifies the method used to calculate the local pseudopotential contribution.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.CORE_PPL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "Defines the the coefficient of the atom in the atom list (default is one)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "Debug the integrals needed for LRIGPW.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DEBUG_LRI_INTEGRALS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Use a diagonal version of the 3rd order energy correction (DFTB3)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.DIAGONAL_DFTB3",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Use dispersion correction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.DISPERSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Use Ewald type method instead of direct sum for Coulomb interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.DO_EWALD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Define accuracy of dispersion interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.EPS_DISP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Uses a modified version for the GAMMA within the SCC-DFTB scheme, specifically tuned for hydrogen bonds.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.HB_SR_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Assume orthogonal basis set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.ORTHOGONAL_BASIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Define cutoff for coordination number calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.COORDINATION_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Scaling parameters (s6,sr6,s8) for the D3 dispersion method,",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.D3_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Specify file that contains the atomic dispersion parameters for the D3 method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.DISPERSION_PARAMETER_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Define radius of dispersion interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.DISPERSION_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Use dispersion correction of the specified type. Dispersion correction has to be switched on in the DFTB section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.DISPERSION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Uses a modified version for the GAMMA within the SCC-DFTB scheme, specifically tuned for hydrogen bonds. Specify the exponent used in the exponential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.HB_SR_PARAM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Specify file that contains the names of Slater-Koster tables: A plain text file, each line has the format \"ATOM1 ATOM2 filename.spl\".",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.PARAM_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Specify the directory with the DFTB parameter files. Used in combination with the filenames specified in the file given in PARAM_FILE_NAME.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.PARAM_FILE_PATH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Define parameter file for atom pair",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.SK_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Name of file with UFF parameters that will be used for the dispersion correction. Needs to be specified when DISPERSION==.TRUE., otherwise cp2k crashes with a Segmentation Fault.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER.UFF_FORCE_FIELD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER"
      ]
    }, {
      "description": "Use self-consistent method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DFTB.SELF_CONSISTENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Distribute the atoms so that atoms belonging to a given molecule are on the same CPU for the 2D distribution. This might give rise to a worse distribution but reduces memory needs of finding the optimal distribution.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DISTRIBUTION.2D_MOLECULAR_DISTRIBUTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION"
      ]
    }, {
      "description": "Creates a distribution based on a few heuristics using only minimal memory and CPU time.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DISTRIBUTION.BASIC_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION"
      ]
    }, {
      "description": "Creates a distribution with spatial info, using only minimal memory and CPU time.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DISTRIBUTION.BASIC_SPATIAL_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION"
      ]
    }, {
      "description": "The cost model that needs to be minimized",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DISTRIBUTION.COST_MODEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION"
      ]
    }, {
      "description": "Do not optimize the distribution, go for something very simple. Might be useful if the optimization, which scales quadratically in system size, is too expensive.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DISTRIBUTION.SKIP_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION"
      ]
    }, {
      "description": "Take the symmetry of the distribution_2d into account.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.DISTRIBUTION.SYMMETRIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION"
      ]
    }, {
      "description": "Precision for mapping the core charges.Overrides EPS_DEFAULT/100.0 value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_CORE_CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the GAPW projection. Overrides EPS_DEFAULT value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_CPC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Try setting all EPS_xxx to values leading to an energy correct up to EPS_DEFAULT",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_DEFAULT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets the threshold for filtering matrix elements.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_FILTER_MATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the realspace KS matrix element integration. Overrides SQRT(EPS_DEFAULT) value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_GVG_RSPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision used in coloring the subsets for the Kim-Gordon method. Overrides SQRT(EPS_DEFAULT) value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_KG_ORB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the overlap matrix elements. Overrides SQRT(EPS_DEFAULT) value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_PGF_ORB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Adjusts the precision for the local part of the pseudo potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_PPL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the non-local part of the pseudo potential. Overrides sqrt(EPS_DEFAULT) value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_PPNL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the density mapping in gspace.Overrides EPS_DEFAULT value..Overrides EPS_RHO value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_RHO_GSPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the density mapping in rspace.Overrides EPS_DEFAULT value..Overrides EPS_RHO value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_RHO_RSPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Sets precision of the density mapping on the grids.Overrides EPS_DEFAULT value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPS_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW: precision to give the extention of a hard gaussian",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPSFIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW: precision to determine an isolated projector",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPSISO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW : precision to determine the range of V(rho0-rho0soft)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPSRHO0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW: tolerance used in the singular value decomposition of the projector matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EPSSVD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Order for the PS or ASPC extrapolation (typically 2-4). Higher order might bring more accuracy, but comes, for large systems, also at some cost. In some cases, a high order extrapolation is not stable, and the order needs to be reduced.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EXTRAPOLATION_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Extrapolation strategy for the wavefunction during e.g. MD.PS and ASPC are recommended, see also EXTRAPOLATION_ORDER.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.EXTRAPOLATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Use the GAPW scheme also for atoms with soft basis sets, i.e.  the local densities are computed even if hard and soft should be equal. If this keyword is not set to true, those atoms with soft basis sets are treated by a GPW scheme, i.e. the corresponding density contribution goes on the global grid and is expanded in PW.  This option nullifies the effect of the GPW_TYPE in the atomic KIND",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.FORCE_PAW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Activates the harris functional.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.HARRIS.ACTIVATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.HARRIS"
      ]
    }, {
      "description": "Overrides the QS Energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.HARRIS.HARRIS_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.HARRIS"
      ]
    }, {
      "description": "Use a Kim-Gordon-like scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.KG_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW : integer added to the max L of the basis set, used to determine the maximum value of L for the compensation charge density.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.LADDN0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW : max L number for the expansion compensation densities in spherical gaussians",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.LMAXN0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW : max L number for expansion of the atomic densities in spherical gaussians",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.LMAXN1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Perform a linear scaling SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.LS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Compute the exact derivative (Hks) of the energy with respect to the density matrix. This is slightly more expensive than using an approximate computation, but consistent mapping can improve the stability of the SCF procedure, especially for a tight EPS_SCF and a less tight EPS_DEFAULT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.MAP_CONSISTENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW : maximum radius of gaussian functions included in the generation of projectors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.MAX_RAD_LOCAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Specifies the electronic structure method that should be employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT"
      ]
    }, {
      "description": "Target accuracy for the objective function (RHOEND)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "This keyword allows to give different weight factors to the condition number (LOG(cond) is used).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.CONDITION_WEIGHT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "Exponent in the fermi-like constraint function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.CONSTRAIN_EXPONENTS.FERMI_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.CONSTRAIN_EXPONENTS"
      ]
    }, {
      "description": "Defines the upper and lower boundaries as (1+scale)*exp and (1-scale)*exp. Fermi-like constraint function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.CONSTRAIN_EXPONENTS.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.CONSTRAIN_EXPONENTS"
      ]
    }, {
      "description": "Specifies the degrees of freedom in the basis optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.DEGREES_OF_FREEDOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "Exponents are assumed to be a geometric squence. Only the minimal and maximal exponents of one set are optimized and the other exponents are obtained by geometric progression.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.GEOMETRIC_SEQUENCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "Maximum number of function evaluations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.MAX_FUN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "Initial step size for search algorithm (RHOBEG)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "Determines whether condition number should be part of optimization or not",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.USE_CONDITION_NUMBER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "Can be used to set the distribution in g-space for the pw grids and their FFT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.PW_GRID_BLOCKED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Force a particular real-space layout for the plane waves grids. Numbers â¤ 0 mean that this dimension is free, incorrect layouts will be ignored. The default (/-1,-1/) causes CP2K to select a good value, i.e. plane distributed for large grids, more general distribution for small grids.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.PW_GRID_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "What kind of PW_GRID should be employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.PW_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "GAPW: algorithm to construct the atomic radial grids",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.QUADRATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT"
      ]
    }, {
      "description": "Define cutoff for coordination number calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.COORDINATION_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Scaling parameters (s6,sr6,s8) for the D3 dispersion method,",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.D3_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Specify file that contains the atomic dispersion parameters",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.DISPERSION_PARAMETER_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Define radius of dispersion interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.DISPERSION_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Use dispersion correction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.DISPERSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Use Ewald type method instead of direct sum for Coulomb interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.DO_EWALD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Use self consistent charge method. Can be used together with DO_SCP to get TB method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.DO_SCC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Use SCP method. Can be used to switch off SCP to get a SCC-DFTB method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.DO_SCP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Define cutoff for pair potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.PAIR_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Specify file that contains the atomic parameters",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.PARAMETER_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Provides the order of the Slater orbital expansion of Gaussian-Type Orbitals.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCPTB.STO_NG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB"
      ]
    }, {
      "description": "Introduce additional self-consistent polarization through additional response basis functions (read in through AUX_BASIS.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SCP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Nuclear Gradients are computed analytically or numerically",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.ANALYTICAL_GRADIENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Define cutoff for coordination number calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.COORDINATION_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for the evaluation of the  Coulomb integrals. For non-periodic calculation the default value is exactly the full cell dimension, in order to evaluate all pair interactions. Instead, for periodic calculations the default numerical value is used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.COULOMB.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.COULOMB"
      ]
    }, {
      "description": "Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.COULOMB.RC_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.COULOMB"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for Tapering Coulomb integrals. If not specified it assumes the same value specified for the CUTOFF.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.COULOMB.RC_TAPER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.COULOMB"
      ]
    }, {
      "description": "Scaling parameters (s6,sr6,s8) for the D3 dispersion method,",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.D3_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Step size in finite difference force calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.DELTA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Specify file that contains the atomic dispersion parameters",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.DISPERSION_PARAMETER_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Define radius of dispersion interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.DISPERSION_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Use dispersion correction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.DISPERSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for the evaluation of the Exchange integrals. For non-periodic calculation the default value is exactly the full cell dimension, in order to evaluate all pair interactions. Instead, for periodic calculations the default is the minimum value between 1/4 of the cell dimension and the value specified in input (either explicitly defined or the default numerical value).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE"
      ]
    }, {
      "description": "Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE.RC_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for Tapering Exchange integrals. If not specified it assumes the same value specified for the CUTOFF.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE.RC_TAPER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE"
      ]
    }, {
      "description": "This keywords forces the usage of the KDSO-D integral screening for the Exchange integrals (default is to apply the screening only to the Coulomb integrals.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.FORCE_KDSO-D_EXCHANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Defines the number of linked cells for the neighbor list. Default value is number of processors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.GA.NCELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.GA"
      ]
    }, {
      "description": "Specifies the functional form for the",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.INTEGRAL_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for the evaluation of the long-ranbe correction integrals.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION"
      ]
    }, {
      "description": "Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION.RC_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for Tapering the long-range correction integrals. If not specified it assumes the same value specified for the CUTOFF.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION.RC_TAPER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION"
      ]
    }, {
      "description": "Enables the compression of the integrals in memory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.MEMORY.COMPRESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.MEMORY"
      ]
    }, {
      "description": "Storage threshold for compression is EPS_STORAGE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.MEMORY.EPS_STORAGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] used to store precomputed (possibly compressed) two-electron two-center integrals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.MEMORY"
      ]
    }, {
      "description": "This keyword enables the check that two atoms are never below the minimum value used to construct the splines during the construction of the neighbouring list. Disabling this keyword avoids CP2K to abort in case two atoms are below the minimum  value of the radius used to generate the splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS.GEO_CHECK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "This keyword enables the building of the neighbouring list from scratch.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS.NEIGHBOR_LISTS_FROM_SCRATCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "Defines the Verlet Skin for the generation of the neighbor lists",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS.VERLET_SKIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "Assume orthogonal basis set. This flag is overwritten by methods with fixed orthogonal/non-orthogonal basis set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.ORTHOGONAL_BASIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Specifies the type of treatment for the electrostatic long-range part in semi-empirical calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Perform a SCP-NDDO calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.SCP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2*RC_TAPER-20*RC_RANGE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.SCREENING.RC_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.SCREENING"
      ]
    }, {
      "description": "Atomic Cutoff Radius Cutoff for Tapering the screening term.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.SCREENING.RC_TAPER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.SCREENING"
      ]
    }, {
      "description": "Provides the order of the Slater orbital expansion of Gaussian-Type Orbitals.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.SE.STO_NG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Perform transport calculations (coupling CP2K and OMEN)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.QS.TRANSPORT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "If using density propagation some parts should be calculated with a higher accuracy than the rest to reduce numerical noise. This factor determines by how much the filtering threshold is reduced for these calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.ACCURACY_REFINEMENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Applies a delta kick to the initial wfn (only RTP for now - the EMD  case is not yet implemented).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.APPLY_DELTA_PULSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Speciefies how many steps will be used for extrapolation. One will be always used which is means X(t+dt)=X(t)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.ASPC_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Calculates the idempotency. Costs some performance. Is for free if McWeeny is used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.CALCULATE_IDEMPOTENCY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Direction of the applied electric field. The k vector is given as 2*Pi*[i,j,k]*inv(h_mat), which for PERIODIC .FALSE. yields exp(ikr) periodic with the unit cell, only if DELTA_PULSE_SCALE is set to unity. For an orthorhombic cell [1,0,0] yields [2*Pi/L_x,0,0]. For small cells, this results in a very large kick.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.DELTA_PULSE_DIRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Scale the k vector, which for PERIODIC .FALSE. results in exp(ikr) no longer being periodic with the unit cell. The norm of k is the strength of the applied electric field in atomic units.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.DELTA_PULSE_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "The density matrix is propagated instead of the molecular orbitals. This allows for a linear scaling simulation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.DENSITY_PROPAGATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Convergence criterium for the self consistent propagator loop.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.EPS_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Accuracy for the taylor and pade approximation. This is only an upper bound bound since the norm used for the guess is an upper bound for the needed one.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.EXP_ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "If HFX is used, this keyword forces a redistribution/recalculation of the integrals, balanced with respect to the in core steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.HFX_BALANCE_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Controls the initial WFN used for propagation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.INITIAL_WFN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Which method should be used to calculate the exponential in the propagator. For Ehrenfest MD only the Taylor method works, for real time propagation diagonalization works as well.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.MAT_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Maximal number of iterations for the self consistent propagator loop.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Threshold after which McWeeny is terminated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.MCWEENY_EPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Determines the maximum amount of McWeeny steps used after each converged step in density propagation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.MCWEENY_MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Performs rtp in the orthonormal basis, currently only works with density propagation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.ORTHONORMAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Apply a delta-kick that is compatible with periodic boundary conditions for any value of DELTA_PULSE_SCALE. Uses perturbation theory for the preparation of the initial wfn. Note that the pulse is only applied when INITIAL_WFN is set to SCF_WFN, and not for restarts (RT_RESTART).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Which propagator should be used for the orbitals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.PROPAGATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "Speciefies how many iteration steps will be done without a check for self consistency. Can save some time in big calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.SC_CHECK_START",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "For density propagation. It writes out the density matrix after each step",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION.WRITE_RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION"
      ]
    }, {
      "description": "The order of the DKH transformation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELATIVISTIC.DKH_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC"
      ]
    }, {
      "description": "type of relativistic correction used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELATIVISTIC.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC"
      ]
    }, {
      "description": "External potential used in DKH transformation, full 1/r or erfc(r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELATIVISTIC.POTENTIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC"
      ]
    }, {
      "description": "Type of DKH transformation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELATIVISTIC.TRANSFORMATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC"
      ]
    }, {
      "description": "The minimal atomic number considered for atom transformation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELATIVISTIC.Z_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC"
      ]
    }, {
      "description": "Type of ZORA method to be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELATIVISTIC.ZORA_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC"
      ]
    }, {
      "description": "Do not enforce the occupation of alpha and beta MOs due to the initially defined multiplicity, but rather follow an Aufbau principle. A threshold value greater than zero activates this option. Larger threshold values increase the probability for a spin flip. This option is only valid for unrestricted (i.e. spin polarised) Kohn-Sham (UKS) calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.RELAX_MULTIPLICITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Requests a restricted open Kohn-Sham calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.ROKS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Solvent specific tunable parameter for the calculation of the repulsion term <i>G<sup>rep</sup> = Î± S</i> where <i>S</i> is the (quantum) surface of the cavity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Maximum density value used for the smoothing of the dielectric function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.ANDREUSSI.RHO_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS.ANDREUSSI"
      ]
    }, {
      "description": "Minimum density value used for the smoothing of the dielectric function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.ANDREUSSI.RHO_MIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS.ANDREUSSI"
      ]
    }, {
      "description": "Solvent specific tunable parameter for the calculation of the dispersion term <i>G<sup>dis</sup> = Î² V</i> where <i>V</i> is the (quantum) volume of the cavity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Numerical increment for the calculation of the (quantum) surface of the solute cavity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.DELTA_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Method for the calculation of the numerical derivatives on the real-space grids",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.DERIVATIVE_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Dielectric constant of the solvent",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.DIELECTRIC_CONSTANT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Tolerance for the convergence of the polarisation density, i.e. requested accuracy for the SCCS iteration cycle",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.EPS_SCCS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "The SCCS iteration cycle is activated only if the SCF iteration cycle is converged to this threshold value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Parameter Î² changes the width of the interface solute-solvent",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.FATTEBERT-GYGI.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS.FATTEBERT-GYGI"
      ]
    }, {
      "description": "Parameter Ï<sub>0</sub> defines the critical density in the middle of the interface solute-solvent",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.FATTEBERT-GYGI.RHO_ZERO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS.FATTEBERT-GYGI"
      ]
    }, {
      "description": "Surface tension of the solvent used for the calculation of the cavitation term <i>G<sup>cav</sup> = Î³ S</i> where <i>S</i> is the (quantum) surface of the cavity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Maximum number of SCCS iteration steps performed to converge within the given tolerance",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Method used for the smoothing of the dielectric function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Mixing parameter (Hartree damping) employed during the iteration procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.MIXING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Controls the activation of the SCCS section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCCS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Number of additional MOS added for each spin",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.ADDED_MOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "If the cholesky method should be used for computing the inverse of S, and in this case calling which Lapack routines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.CHOLESKY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Algorithm to be used for diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Minimal percent of MOS that have to converge within the Davidson loop before the SCF iteration is completed and a new Hamiltonian is computed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.CONV_MOS_PERCENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (0.001 doing normally fine). For the other preconditioners, making this value larger (0.2) will tame the preconditioner in case of poor initial guesses.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "First SCF iteration at which a Preconditioner is employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.FIRST_PREC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Number of SCF iterations after which a new Preconditioner is computed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.NEW_PREC_EACH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "How the preconditioner is applied to the residual.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.PRECOND_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Use MOS as sparse matrix and avoid as much as possible multiplications with full matrices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON.SPARSE_MOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Required density matrix accuracy as compared to current SCF convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.EPS_ADAPT_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Required energy accuracy for convergence of subspace diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.EPS_ENE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Level of convergence to be reached before starting the internal loop of subspace rotations. Above this threshold only the outer diagonalization method is used.  If negative the subspace rotation is started at the first iteration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.EPS_SKIP_SUB_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Maximum number of iterations for the SCF inner loop",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Fraction of new density to be included",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Denominator parameter in Kerker damping introduced to suppress charge sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 + beta^2)*(rho_out(g)-rho_in(g))",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": " w0 parameter used in Broyden mixing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BROY_W0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WMAX",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BROY_WMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WREF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BROY_WREF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Restricts the G-space mixing to lower part of G-vector spectrum, up to a G0, by assigning the exponent of the Gaussian that can be represented by vectors smaller than G0 within a certain accuracy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.MAX_GVEC_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Upper bound for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.MAX_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Mixing method to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Number of kerker damping iterations before starting other mixing procedures",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.N_SIMPLE_MIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Number of previous steps stored for the actual mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.NBUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Minimal number of density mixing (should be greater than 0),before starting DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.NMIXING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Number of initial iteration for which the mixing is skipped",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.NSKIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Fraction of new density to be added to the Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.PULAY_ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Fraction of residual contribution to be added to Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.PULAY_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Control factor for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.R_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Regularization parameter to stabilize the inversion of the residual matrix {Yn^t Yn} in the multisecant mixing scheme (noise)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.REGULARIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Controls the activation of the mixing procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "controls the activation of inner SCF loop to refine occupations in MOS subspace",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Required accuracy in iterative diagonalization as compared to current SCF convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.EPS_ADAPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Required accuracy in iterative diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.EPS_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Below this threshold value for the SCF convergence the pseudo-diagonalization method using Jacobi rotations is activated. This method is much faster than a real diagonalization and it is even speeding up while achieving full convergence.However, it needs a pre-converged wavefunction obtained by at least one real diagonalization which is further optimized while keeping the original eigenvalue spectrum. The MO eigenvalues are NOT updated. The method might be useful to speed up calculations for large systems e.g. using a semi-empirical method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.EPS_JACOBI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Controls the accuracy of the pseudo-diagonalization method using Jacobi rotations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.JACOBI_THRESHOLD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "This requires to check the convergence of MOS also when standard diagonalization steps are performed, if the block krylov approach is active.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV.CHECK_MOS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Convergence criterion for the MOs",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV.EPS_KRYLOV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Level of convergence to be reached before starting the Lanczos procedure. Above this threshold a standard diagonalization method is used.  If negative Lanczos is started at the first iteration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV.EPS_STD_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Size of the block of vectors refined simultaneously by the Lanczos procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV.NBLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Dimension of the Krylov space used for the Lanczos refinement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV.NKRYLOV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Maximum number of iterations in iterative diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Algorithm to be used for OT",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Enable adaptive curvature estimation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_ADAPTIVE_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Underrelaxation for the broyden mixer",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Ensure positive definite update",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_ENABLE_FLIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Dampening of estimated energy curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_ETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Forget history on bad approximation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_FORGET_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Backtracking parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Growth limit of curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Reduction of curvature on bad approximation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_SIGMA_DECREASE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Minimum adaptive curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_SIGMA_MIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Curvature of energy functional.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.BROYDEN_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Optimize orbital energies for use in Fermi-Dirac smearing (requires ROTATION and FD smearing to be active).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.ENERGIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (can be a small number, e.g. 0.002). FULL_SINGLE_INVERSE takes it as lower bound (values below 0.05 can cause stability issues). In general, heigher values will tame the preconditioner in case of poor initial guesses. A negative value will leave the choice to CP2K depending on type of preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Sets the threshold for filtering the matrices.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.EPS_IRAC_FILTER_MATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Only one extra refinement iteration is done when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.EPS_IRAC_QUICK_EXIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The algorithm switches to the polynomial refinement when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.EPS_IRAC_SWITCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Targeted accuracy during the refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.EPS_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Target accuracy of the taylor expansion for the matrix functions, should normally be kept as is.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.EPS_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Target relative uncertainty in the location of the minimum for LINESEARCH GOLD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.GOLD_TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The refinement polynomial degree (2, 3 or 4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.IRAC_DEGREE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "1D line search algorithm to be used with the OT minimizer, in increasing order of robustness and cost. MINIMIZER CG combined with LINESEARCH GOLD should always find an electronic minimum.  Whereas the 2PNT minimizer is almost always OK, 3PNT might be needed for systems in which successive OT CG steps do not decrease the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.LINESEARCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Maximum allowed refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.MAX_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Maximum order of the Taylor expansion before diagonalisation is prefered, for large parallel runs a slightly higher order could sometimes result in a small speedup.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.MAX_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Minimizer to be used with the OT method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.MINIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Uses a mixed precision algorithm.With a well behaved basis set (i.e. condition number less than 1/eps_sp)it provides double precision accuracy results and up to a 2 fold speedup for building and applying the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.MIXED_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Number of history vectors to be used with DIIS or BROYDEN",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.N_HISTORY_VEC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The prefactor for the non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.NONDIAG_ENERGY_STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Add a non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.NONDIAG_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Preconditioner with the occupation numbers (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.OCCUPATION_PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "On the fly localization of the molecular orbitals. Can only be used with OT/IRAC.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.ON_THE_FLY_LOC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The orthogonality method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.ORTHO_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "How the preconditioner is applied to the residual.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.PRECOND_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Introduce additional variables so that rotations of the occupied subspace are allowed as well, only needed for cases where the energy is not invariant under  a rotation of the occupied subspace such as non-singlet restricted calculations  or fractional occupations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.ROTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Reject DIIS steps if they point away from the minimum, do SD in that case.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.SAFE_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Introduce additional self-consistent polarization through response basis set = orbital basis set for NDDO.)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.SCP_NDDO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "controls the activation of the ot method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Initial stepsize used for the line search, sometimes this parameter can be reduced to stablize DIIS or to improve the CG behavior in the first few steps. The optimal value depends on the quality of the preconditioner. A negative values leaves the choice to CP2K depending on the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT.STEPSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "controls the activation of the diagonalization method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Threshold on the convergence to start using DIAG/DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.EPS_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Throw away linear combinations of basis functions with a small eigenvalue in S",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.EPS_EIGVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "target accuracy of the computation of the lumo energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.EPS_LUMO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "target accuracy for the scf convergence after the history pipeline is filled",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.EPS_SCF_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "target accuracy for the scf convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Use level shifting to improve convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.LEVEL_SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Maximum number of DIIS vectors to be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MAX_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "The maximum number of iteration for the lumo computation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MAX_ITER_LUMO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Maximum number of SCF iterations after the history pipeline is filled",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MAX_SCF_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Maximum number of SCF iteration to be performed for one optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MAX_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Fraction of new density to be included",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Denominator parameter in Kerker damping introduced to suppress charge sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 + beta^2)*(rho_out(g)-rho_in(g))",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": " w0 parameter used in Broyden mixing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.BROY_W0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WMAX",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.BROY_WMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WREF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.BROY_WREF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Restricts the G-space mixing to lower part of G-vector spectrum, up to a G0, by assigning the exponent of the Gaussian that can be represented by vectors smaller than G0 within a certain accuracy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.MAX_GVEC_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Upper bound for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.MAX_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Mixing method to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Number of kerker damping iterations before starting other mixing procedures",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.N_SIMPLE_MIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Number of previous steps stored for the actual mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.NBUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Minimal number of density mixing (should be greater than 0),before starting DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.NMIXING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Number of initial iteration for which the mixing is skipped",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.NSKIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Fraction of new density to be added to the Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.PULAY_ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Fraction of residual contribution to be added to Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.PULAY_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Control factor for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.R_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Regularization parameter to stabilize the inversion of the residual matrix {Yn^t Yn} in the multisecant mixing scheme (noise)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.REGULARIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Controls the activation of the mixing procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.MIXING.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING"
      ]
    }, {
      "description": "Sets the number of columns in a scalapack block",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.NCOL_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "sets the number of rows in a scalapack block",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.NROW_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Algorithm to be used for OT",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Enable adaptive curvature estimation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_ADAPTIVE_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Underrelaxation for the broyden mixer",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Ensure positive definite update",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_ENABLE_FLIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Dampening of estimated energy curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_ETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Forget history on bad approximation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_FORGET_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Backtracking parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Growth limit of curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Reduction of curvature on bad approximation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_SIGMA_DECREASE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Minimum adaptive curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_SIGMA_MIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Curvature of energy functional.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.BROYDEN_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Optimize orbital energies for use in Fermi-Dirac smearing (requires ROTATION and FD smearing to be active).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.ENERGIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (can be a small number, e.g. 0.002). FULL_SINGLE_INVERSE takes it as lower bound (values below 0.05 can cause stability issues). In general, heigher values will tame the preconditioner in case of poor initial guesses. A negative value will leave the choice to CP2K depending on type of preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Sets the threshold for filtering the matrices.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.EPS_IRAC_FILTER_MATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Only one extra refinement iteration is done when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.EPS_IRAC_QUICK_EXIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "The algorithm switches to the polynomial refinement when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.EPS_IRAC_SWITCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Targeted accuracy during the refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.EPS_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Target accuracy of the taylor expansion for the matrix functions, should normally be kept as is.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.EPS_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Target relative uncertainty in the location of the minimum for LINESEARCH GOLD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.GOLD_TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "The refinement polynomial degree (2, 3 or 4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.IRAC_DEGREE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "1D line search algorithm to be used with the OT minimizer, in increasing order of robustness and cost. MINIMIZER CG combined with LINESEARCH GOLD should always find an electronic minimum.  Whereas the 2PNT minimizer is almost always OK, 3PNT might be needed for systems in which successive OT CG steps do not decrease the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.LINESEARCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Maximum allowed refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.MAX_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Maximum order of the Taylor expansion before diagonalisation is prefered, for large parallel runs a slightly higher order could sometimes result in a small speedup.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.MAX_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Minimizer to be used with the OT method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.MINIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Uses a mixed precision algorithm.With a well behaved basis set (i.e. condition number less than 1/eps_sp)it provides double precision accuracy results and up to a 2 fold speedup for building and applying the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.MIXED_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Number of history vectors to be used with DIIS or BROYDEN",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.N_HISTORY_VEC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "The prefactor for the non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.NONDIAG_ENERGY_STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Add a non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.NONDIAG_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Preconditioner with the occupation numbers (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.OCCUPATION_PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "On the fly localization of the molecular orbitals. Can only be used with OT/IRAC.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.ON_THE_FLY_LOC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "The orthogonality method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.ORTHO_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "How the preconditioner is applied to the residual.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.PRECOND_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Introduce additional variables so that rotations of the occupied subspace are allowed as well, only needed for cases where the energy is not invariant under  a rotation of the occupied subspace such as non-singlet restricted calculations  or fractional occupations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.ROTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Reject DIIS steps if they point away from the minimum, do SD in that case.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.SAFE_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Introduce additional self-consistent polarization through response basis set = orbital basis set for NDDO.)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.SCP_NDDO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "controls the activation of the ot method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Initial stepsize used for the line search, sometimes this parameter can be reduced to stablize DIIS or to improve the CG behavior in the first few steps. The optimal value depends on the quality of the preconditioner. A negative values leaves the choice to CP2K depending on the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OT.STEPSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT"
      ]
    }, {
      "description": "Maximum number of times the same point will be used in bisection, a small number guards against the effect of wrongly converged states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.BISECT_TRUST_COUNT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Maximum number of DIIS vectors used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.DIIS_BUFFER_LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "The target gradient of the outer scf variables. Notice that the EPS_SCF of the inner loop also determines the value that can be reached in the outer loop, typically EPS_SCF of the outer loop must be smaller than EPS_SCF of the inner loop.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Number of past states used in the extrapolation of the variables during e.g. MD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.EXTRAPOLATION_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "The maximum number of outer loops",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.MAX_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Method used to bring the outer loop to a stationary point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.OPTIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "controls the activation of the outer SCF loop",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "The initial step_size used in the optimizer (currently steepest descent).Note that in cases where a sadle point is sought for (DDAPC_CONSTRAINT), this can be negative",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Specifies which kind of outer SCF should be employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.OUTER_SCF.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Allows to define the parameter f for the general ROKS scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.ROKS_F",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Allows to define all parameters for the high-spin ROKS scheme explicitly. The full set of 6 parameters has to be specified in the order acc, bcc, aoo, boo, avv, bvv",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.ROKS_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Selects the ROKS scheme when ROKS is applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.ROKS_SCHEME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Change the initial guess for the wavefunction.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SCF_GUESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Electronic temperature in the case of Fermi-Dirac smearing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.ELECTRONIC_TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "Accuracy checks on occupation numbers use this as a tolerance",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.EPS_FERMI_DIRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "Imposed difference between the numbers of electrons of spin up and spin down: m = n(up) - n(down). A negative value (default) allows for a change of the magnetic moment. -1 specifically keeps an integer number of spin up and spin down electrons.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.FIXED_MAGNETIC_MOMENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "A list of fractional occupations to use. Must match the number of states and sum up to the correct number of electrons",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "Smearing method to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "Controls the activation of smearing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "Size of the energy window centred at the Fermi level",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCF.SMEAR.WINDOW_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR"
      ]
    }, {
      "description": "Value of the dielectric constant outside the sphere",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.EPS_OUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF"
      ]
    }, {
      "description": "Maximum value of L used in the multipole expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.LMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Defines a list of atoms to define the center of the sphere",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER.ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER"
      ]
    }, {
      "description": "Specify if the center of the sphere should be fixed or allowed to move",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER.FIXED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER"
      ]
    }, {
      "description": "Defines the weight used to define the center of the sphere (if ATOM_LIST is provided)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER.WEIGHT_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER"
      ]
    }, {
      "description": "Coordinates of the center of the sphere",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER"
      ]
    }, {
      "description": "Value of the spherical cavity in the dielectric medium",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SCRF.SPHERE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE"
      ]
    }, {
      "description": "Type of orbitals treated with the SIC",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SIC.ORBITAL_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SIC"
      ]
    }, {
      "description": "Method used to remove the self interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SIC.SIC_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SIC"
      ]
    }, {
      "description": "Scaling of the coulomb term in sic [experimental]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SIC.SIC_SCALING_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SIC"
      ]
    }, {
      "description": "Scaling of the xc term in sic [experimental]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SIC.SIC_SCALING_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SIC"
      ]
    }, {
      "description": "Read the grid size for subcell generation in the construction of neighbor lists.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SUBCELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Cartesian axis parallel to surface normal.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SURF_DIP_DIR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "For slab calculations with asymmetric geometries, activate the correction of  the electrostatic potential with by compensating for the surface dipole. Implemented only for slabs with normal  parallel to one Cartesian axis. The normal direction is given by the keyword SURF_DIP_DIR",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.SURFACE_DIPOLE_CORRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "The convergence of the eigenvalues",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.CONVERGENCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "Diagonalization method used in tddfpt",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.DIAG_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "use the inverse of the overlap matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.INVERT_S",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "compute the kernel (debug purpose only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.KERNEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "compute singlets using lsd vxc kernel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.LSD_SINGLETS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": " maximal number of Krylov space vectors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.MAX_KV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": " number of excitations to calculate",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.NEV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": " number of additional unoccupied orbitals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.NLUMO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": " number of reorthogonalization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.NREORTHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "Which type of orbital eigenvalue correction to use\\n(to yield better HOMO-LUMO energies)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.OE_CORR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "use the preconditioner (only for Davidson)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "(singlets/triplets) for restricted calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.RES_ETYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": " maximal number subspace search restarts",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.RESTARTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "Type of orbitals treated with the SIC",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.SIC.ORBITAL_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.SIC"
      ]
    }, {
      "description": "Method used to remove the self interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.SIC.SIC_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.SIC"
      ]
    }, {
      "description": "Scaling of the coulomb term in sic [experimental]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.SIC.SIC_SCALING_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.SIC"
      ]
    }, {
      "description": "Scaling of the xc term in sic [experimental]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.SIC.SIC_SCALING_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.SIC"
      ]
    }, {
      "description": "Which model for the coupling constant integration should be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING.FUNCTIONAL_MODEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "Which Hybrid functional should be used. (Has to be consistent with the definitions in XC and HF).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING.FUNCTIONAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "The point to be used along the adiabatic curve (0 &#60; Î» &#60; 1)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "Long-range parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "The cutoff on the density used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.DENSITY_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Parameter for the smoothing procedure inxc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.DENSITY_SMOOTH_CUTOFF_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Select the code for xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.FUNCTIONAL_ROUTINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "The cutoff on the gradient of the density used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.GRADIENT_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "Accuracy of iterative RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI.EPS_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Accuracy of geminal integral evaluation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI.EPS_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Maximum number of iteration in RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Parameter for short/longrange interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, longrange or shortrange).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.SCALE_COULOMB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.SCALE_GAUSSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.SCALE_LONGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL.T_C_G_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Number of bins per process used to group atom quartets.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE.NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE.RANDOMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY.EPS_STORAGE_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY.MAX_DISK_SPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all the threads within a process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY.STORAGE_LOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY.TREAT_FORCES_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.PERIODIC.NUMBER_OF_SHELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.PERIODIC"
      ]
    }, {
      "description": "Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.PW_HFX_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.PW_HFX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING.EPS_SCHWARZ_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING.EPS_SCHWARZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disabled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING.P_SCREEN_CORRECTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING.SCREEN_ON_INITIAL_P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING.SCREEN_P_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.TREAT_LSD_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "The cutoff on tau used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.TAU_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "The cutoff of the FFT grid used in the calculation of the nonlocal vdW functional [Ry].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Name of the kernel data file, may include a path.vdW_kernel_table.dat is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL.KERNEL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Parameters b and C of the rVV10 functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Type of functional (the corresponding kernel data file should be selected).Allows for common forms such as vdW-DF, vdW-DF2, optB88-vdW, rVV10.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Extensive output for non local functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL.VERBOSE_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Specifies the coordination number of a set of atoms for the C9 term in DFT-D3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.ATOM_COORDINATION_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Specifies parameters for atom types (in atomic units). If not provided default parameters are used (DFT-D2).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.ATOMPARM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate C9 terms in DFT-D3 model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.CALCULATE_C9_TERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3 method, if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.D3_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameters (s6,a1,s8,a2) for the DFT-D3(BJ) method, if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.D3BJ_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Cutoff value for coordination number function (DFT-D3 method)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.EPS_CN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Prefactor in exponential damping factor (DFT-D2 potential)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.EXP_PRE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Specifies the coordination number for a kind for the C9 term in DFT-D3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.KIND_COORDINATION_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate a long range correction to the DFT-D3 model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.LONG_RANGE_CORRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Name of the parameter file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PARAMETER_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "Range of potential. The cutoff will be 2 times this value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.R_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate C9 terms in DFT-D3 model using reference coordination numbers",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.REFERENCE_C9_TERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Use parameters for this specific density functional. For available D3 and D3(BJ) parameters see: http://www.thch.uni-bonn.de/tc/downloads/DFT-D3/functionals.html, http://www.thch.uni-bonn.de/tc/downloads/DFT-D3/functionalsbj.html",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.REFERENCE_FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameter, if set to zero CP2K attempts to guess the xc functional that is in use and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Type of potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Extensive output for the DFT-D2 and DFT-D3 models",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.VERBOSE_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Type of dispersion/vdW functional or potential to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "Calculate the condition number of the (P|Q) matrix for the RI methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.CALC_COND_NUM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Size of the column block used in the SCALAPACK block cyclic data distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.COL_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Convergence threshold for the solution of the Z-vector equations. The Z-vector equations have the form of a linear system of equations Ax=b, convergence is achieved when |Ax-b|<=EPS_CONV.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.CPHF.EPS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.CPHF"
      ]
    }, {
      "description": "Maximum number of iterations allowed for the solution of the Z-vector equations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.CPHF.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.CPHF"
      ]
    }, {
      "description": "Send big messages between processes (useful for >48 processors).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.DIRECT_CANONICAL.BIG_SEND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.DIRECT_CANONICAL"
      ]
    }, {
      "description": "Group size used in the computation of the integrals. Default is to use all processors (GROUP_SIZE=-1).A smaller group size (for example the node size), might a better choice if the actual MP2 time is large compared to integral computation time. This is usually the case if the total number of processors is not too large.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.GROUP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, TShPSC operator).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines truncation radius for the truncated TShPSC potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL.TRUNCATION_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file TShPSC.dat that contains the data for the evaluation of the TShPSC G0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL.TSHPSC_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Maximum allowed total memory usage during MP2 methods [Mb].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Which method should be used to compute the MP2 energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "Specifies the size of the auxiliary basis set automatically generated as initial guess. This will be effective only if RI_AUX_BASIS_SET in the KIND section and NUM_FUNC are not specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS.BASIS_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Target accuracy in the relative deviation of the amplitudes calculated with and without RI approximation, (more details in Chem.Phys.Lett.294(1998)143).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS.DELTA_I_REL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Target accuracy in the absolute difference between the RI-MP2 and the exact MP2 energy, DRI=ABS(E_MP2-E_RI-MP2).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS.DELTA_RI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "The derivatives of the MP2 energy with respect to the exponents of the basis are calculated numerically. The change in the exponent a_i employed for the numerical evaluation is defined as h_i=EPS_DERIV*a_i.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS.EPS_DERIV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Specifies the maximum number of steps in the RI basis optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Specifies the number of function, for each angular momentum (s, p, d ...), employed in the automatically generated initial guess. This will be effective only if RI_AUX_BASIS_SET in the KIND section is not specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS.NUM_FUNC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Number of quadrature points for the numerical integration in the RI-SOS-MP2-Laplace method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_LAPLACE.QUADRATURE_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_LAPLACE"
      ]
    }, {
      "description": "Group size for the integration in the Laplace method, that is the number of processes involved in the computation of each integration point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_LAPLACE.SIZE_INTEG_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_LAPLACE"
      ]
    }, {
      "description": "Determines the blocking used for communication in RI-MP2. Larger BLOCK_SIZE reduces communication but requires more memory. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "Threshold for discriminate if a given ij pairs of the unrelaxed MP2 density matrix has to be calculated with a canonical reformulation based on the occupied eigenvalues differences.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2.EPS_CANONICAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "Free the buffer containing the 4 center integrals used in the Hartree-Fock exchange calculation. This will be effective only for gradients calculations, since for the energy only case, the buffers are released by default. (Right now debugging only).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2.FREE_HFX_BUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "Accuracy of iterative RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.EPS_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Accuracy of geminal integral evaluation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.EPS_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Maximum number of iteration in RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Parameter for short/longrange interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, longrange or shortrange).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_COULOMB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_GAUSSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_LONGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.T_C_G_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Number of bins per process used to group atom quartets.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.RANDOMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.EPS_STORAGE_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.MAX_DISK_SPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all the threads within a process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.STORAGE_LOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.TREAT_FORCES_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC.NUMBER_OF_SHELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC"
      ]
    }, {
      "description": "Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.PW_HFX_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.PW_HFX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.EPS_SCHWARZ_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.EPS_SCHWARZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disabled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.P_SCREEN_CORRECTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.SCREEN_ON_INITIAL_P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.SCREEN_P_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.TREAT_LSD_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Use the Minimax quadrature scheme for performing the numerical integration. Maximum number of quadrature point limited to 20.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.MINIMAX_QUADRATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Matrix multiplication style for the Q matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.MM_STYLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Number of quadrature points for the numerical integration in the RI-RPA method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.QUADRATURE_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Group size for frequency integration, that is the number of processes involved in the computation of each integration point. SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.SIZE_FREQ_INTEG_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Size of the row block used in the SCALAPACK block cyclic data distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.ROW_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Scaling factor of the singlet energy component (opposite spin, OS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.SCALE_S",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Scaling factor of the triplet energy component (same spin, SS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.SCALE_T",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "The cutoff of the finest grid level in the MP2 gpw integration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines a threshold for the DBCSR based multiply (usually 10 times smaller than EPS_GRID).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW.EPS_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines a threshold for the GPW based integration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW.EPS_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "How much output is written by the individual groups.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW.PRINT_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines the grid at which a Gaussian is mapped.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88"
      ]
    }, {
      "description": "Potential parameter in erf(omega*r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "Defines the parameter of the adiabatic curve",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "Potential parameter in erf(omega*r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "switches between the B97 and Grimme parametrization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "scales the exchange part of the functional, if -1 the default for the given parametrization is used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "Defines the cutoff radius for the truncation. If put to zero, the standard full range potential will be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "Parameter in the exchange hole. Usually this is put to 1.0 or 0.8",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BEEF.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BEEF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BEEF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BEEF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.CS1.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.CS1"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "Parameter for Becke Roussel hole",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "Which version of the parameters should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.HCTH.PARAMETER_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.HCTH"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.HCTH.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.HCTH"
      ]
    }, {
      "description": "Which one of the KE_GGA functionals should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_GGA.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_GGA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_GGA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_GGA"
      ]
    }, {
      "description": "names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "parameters of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "scaling factors of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "parameters of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "scaling factors of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP"
      ]
    }, {
      "description": "Defines the parameter of the adiabatic curve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP_ADIABATIC.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP_ADIABATIC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP_ADIABATIC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP_ADIABATIC"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.OPTX.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.OPTX"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.OPTX.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.OPTX"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.P86C.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.P86C"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.P86C.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.P86C"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PADE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PADE"
      ]
    }, {
      "description": "switches between the different parametrizations of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "Which one of parametrizations should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "Scaling of the energy functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "Which one of parametrizations should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "Shortcut for the most common functional combinations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TFW.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TFW"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "Which version of the VWN functional should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN.FUNCTIONAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "Value of the xa parameter (this does not change the exponent, just the mixing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA.XA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "Which one of the XGGA functionals should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XGGA.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XGGA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XGGA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XGGA"
      ]
    }, {
      "description": "screening parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "scales the exchange part of the original hole PBE-functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE.SCALE_X0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "Uses a finer grid only to calculate the xc",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID.USE_FINER_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID"
      ]
    }, {
      "description": "The method used to compute the derivatives",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID.XC_DERIV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID"
      ]
    }, {
      "description": "The density smoothing used for the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID.XC_SMOOTH_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID"
      ]
    }, {
      "description": "How to determine the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL"
      ]
    }, {
      "description": "Value of the alpha parameter (default = 1.19).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Value of the beta parameter (default = 0.01).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Value of the K_rho parameter (default = 0.42).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP.K_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "The number of neighboring unit cells that one unit cell interacts with.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.BANDWIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The smallest number that is not zero in the full diagonalization part.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.COLZERO_THRESHOLD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Number of cores per node.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.CORES_PER_NODE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Method used for constructing the density matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.DENSITY_MATRIX_CONSTRUCTION_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Average distance for big intervals in energy vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.ENERGY_INTERVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The smallest imaginary part that a decaying eigenvalue may have not to be considered as propagating.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.EPS_DECAY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Filter for degenerate bands in the injection vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.EPS_EIGVAL_DEGEN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The smallest eigenvalue that is kept.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.EPS_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Accuracy to which the Fermi level should be determined.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.EPS_MU",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Filter for degenerate bands in the bandstructure.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.EPS_SINGULARITY_CURVATURES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Smallest enery distance in energy vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.MIN_INTERVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The number of abscissae per integration interval on the real axis.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.N_ABSCISSAE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The number of unit cells.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.N_CELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Number of degrees of freedom for the contact unit cell.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.N_DOF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The number of k points for determination of the singularities.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.N_KPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "The number of contacts.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.NUM_CONTACTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Max number of energy points per small interval.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.NUM_INTERVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Number of tasks per energy point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.TASKS_PER_POINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Temperature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.TRANSPORT.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT"
      ]
    }, {
      "description": "Requests a spin-polarized calculation using alpha and beta orbitals, i.e. no spin restriction is applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.UKS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Name of the wavefunction restart file, may include a path. If no file is specified, the default is to open the file as generated by the wfn restart print key.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.WFN_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Number of additional MOS added spin up only",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.ADDED_MOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Indexes of the atoms to be excitedThis keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.ATOMS_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Type of integral to get the oscillator strengths in the diipole approximation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.DIPOLE_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "target accuracy incalculation of the added orbitals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.EPS_ADDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "scale angles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.CRAZY_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Use diagonalization (slow) or pade based calculation of matrix exponentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.CRAZY_USE_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Select the orbitals to be localized within the given energy range.This type of selection cannot be added on top of the selection through a LIST. It reads to reals that are lower and higher boundaries of the energy range.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.ENERGY_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Tolerance used in the convergence criterium of the localization methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.EPS_LOCALIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Tolerance in the occupation number to select only fully occupied orbitals for the rotation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.EPS_OCCUPATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Use Jacobi method in case no convergence was achieved by using the crazy rotations method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.JACOBI_FALLBACK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Indexes of the unoccupied states to be localized, up to now only valid in combination with GPW. This keyword has to be present if unoccupied states should be localized. This keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.LIST_UNOCCUPIED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Indexes of the occupied wfn to be localizedThis keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "File name where to read the MOS fromwhich to restart the localization procedure for occupied states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.LOCHOMO_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "File name where to read the MOS fromwhich to restart the localization procedure for unoccupied states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.LOCLUMO_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Largest allowed angle for the crazy rotations algorithm (smaller is slower but more stable).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.MAX_CRAZY_ANGLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Maximum number of iterations used for localization methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Method of optimization if any",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Requires the maximization of the spread of the wfn",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.MIN_OR_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Type of opertator which defines the spread functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.OPERATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Every how many iterations of the localization algorithm(Jacobi) the tolerance value is printed out",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.OUT_ITER_EACH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Restart the localization from a set of orbitals read from a localization restart file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "controls the activation of the MOS localization procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Which states to localize, LUMO up to now only available in GPW",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.STATES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "Generate an improved initial guess based on a history of results, which is useful during MD.Will only work if the number of states to be localized remains constant.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.LOCALIZE.USE_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE"
      ]
    }, {
      "description": "maximum number of iteration in calculation of added orbitals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.MAX_ITER_ADDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Method to be used to calculate core-level excitation spectra",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Number of gto's for the expansion of the stoof the type given by STATE_TYPE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.NGAUSS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Restart the excited state if the restart file exists",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Number of additional MOS added for each spin",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.ADDED_MOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "If the cholesky method should be used for computing the inverse of S, and in this case calling which Lapack routines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.CHOLESKY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Algorithm to be used for diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Minimal percent of MOS that have to converge within the Davidson loop before the SCF iteration is completed and a new Hamiltonian is computed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.CONV_MOS_PERCENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (0.001 doing normally fine). For the other preconditioners, making this value larger (0.2) will tame the preconditioner in case of poor initial guesses.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "First SCF iteration at which a Preconditioner is employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.FIRST_PREC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Number of SCF iterations after which a new Preconditioner is computed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.NEW_PREC_EACH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "How the preconditioner is applied to the residual.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.PRECOND_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Use MOS as sparse matrix and avoid as much as possible multiplications with full matrices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON.SPARSE_MOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON"
      ]
    }, {
      "description": "Required density matrix accuracy as compared to current SCF convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.EPS_ADAPT_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Required energy accuracy for convergence of subspace diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.EPS_ENE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Level of convergence to be reached before starting the internal loop of subspace rotations. Above this threshold only the outer diagonalization method is used.  If negative the subspace rotation is started at the first iteration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.EPS_SKIP_SUB_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Maximum number of iterations for the SCF inner loop",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Fraction of new density to be included",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Denominator parameter in Kerker damping introduced to suppress charge sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 + beta^2)*(rho_out(g)-rho_in(g))",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": " w0 parameter used in Broyden mixing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BROY_W0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WMAX",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BROY_WMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WREF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.BROY_WREF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Restricts the G-space mixing to lower part of G-vector spectrum, up to a G0, by assigning the exponent of the Gaussian that can be represented by vectors smaller than G0 within a certain accuracy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.MAX_GVEC_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Upper bound for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.MAX_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Mixing method to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Number of kerker damping iterations before starting other mixing procedures",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.N_SIMPLE_MIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Number of previous steps stored for the actual mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.NBUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Minimal number of density mixing (should be greater than 0),before starting DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.NMIXING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Number of initial iteration for which the mixing is skipped",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.NSKIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Fraction of new density to be added to the Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.PULAY_ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Fraction of residual contribution to be added to Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.PULAY_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Control factor for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.R_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Regularization parameter to stabilize the inversion of the residual matrix {Yn^t Yn} in the multisecant mixing scheme (noise)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.REGULARIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "Controls the activation of the mixing procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING"
      ]
    }, {
      "description": "controls the activation of inner SCF loop to refine occupations in MOS subspace",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Required accuracy in iterative diagonalization as compared to current SCF convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.EPS_ADAPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Required accuracy in iterative diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.EPS_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Below this threshold value for the SCF convergence the pseudo-diagonalization method using Jacobi rotations is activated. This method is much faster than a real diagonalization and it is even speeding up while achieving full convergence.However, it needs a pre-converged wavefunction obtained by at least one real diagonalization which is further optimized while keeping the original eigenvalue spectrum. The MO eigenvalues are NOT updated. The method might be useful to speed up calculations for large systems e.g. using a semi-empirical method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.EPS_JACOBI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Controls the accuracy of the pseudo-diagonalization method using Jacobi rotations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.JACOBI_THRESHOLD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "This requires to check the convergence of MOS also when standard diagonalization steps are performed, if the block krylov approach is active.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV.CHECK_MOS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Convergence criterion for the MOs",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV.EPS_KRYLOV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Level of convergence to be reached before starting the Lanczos procedure. Above this threshold a standard diagonalization method is used.  If negative Lanczos is started at the first iteration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV.EPS_STD_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Size of the block of vectors refined simultaneously by the Lanczos procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV.NBLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Dimension of the Krylov space used for the Lanczos refinement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV.NKRYLOV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV"
      ]
    }, {
      "description": "Maximum number of iterations in iterative diagonalization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Algorithm to be used for OT",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Enable adaptive curvature estimation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_ADAPTIVE_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Underrelaxation for the broyden mixer",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Ensure positive definite update",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_ENABLE_FLIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Dampening of estimated energy curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_ETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Forget history on bad approximation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_FORGET_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Backtracking parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Growth limit of curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Reduction of curvature on bad approximation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_SIGMA_DECREASE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Minimum adaptive curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_SIGMA_MIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Curvature of energy functional.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.BROYDEN_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Optimize orbital energies for use in Fermi-Dirac smearing (requires ROTATION and FD smearing to be active).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.ENERGIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (can be a small number, e.g. 0.002). FULL_SINGLE_INVERSE takes it as lower bound (values below 0.05 can cause stability issues). In general, heigher values will tame the preconditioner in case of poor initial guesses. A negative value will leave the choice to CP2K depending on type of preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Sets the threshold for filtering the matrices.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.EPS_IRAC_FILTER_MATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Only one extra refinement iteration is done when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.EPS_IRAC_QUICK_EXIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The algorithm switches to the polynomial refinement when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.EPS_IRAC_SWITCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Targeted accuracy during the refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.EPS_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Target accuracy of the taylor expansion for the matrix functions, should normally be kept as is.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.EPS_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Target relative uncertainty in the location of the minimum for LINESEARCH GOLD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.GOLD_TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The refinement polynomial degree (2, 3 or 4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.IRAC_DEGREE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "1D line search algorithm to be used with the OT minimizer, in increasing order of robustness and cost. MINIMIZER CG combined with LINESEARCH GOLD should always find an electronic minimum.  Whereas the 2PNT minimizer is almost always OK, 3PNT might be needed for systems in which successive OT CG steps do not decrease the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.LINESEARCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Maximum allowed refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.MAX_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Maximum order of the Taylor expansion before diagonalisation is prefered, for large parallel runs a slightly higher order could sometimes result in a small speedup.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.MAX_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Minimizer to be used with the OT method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.MINIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Uses a mixed precision algorithm.With a well behaved basis set (i.e. condition number less than 1/eps_sp)it provides double precision accuracy results and up to a 2 fold speedup for building and applying the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.MIXED_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Number of history vectors to be used with DIIS or BROYDEN",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.N_HISTORY_VEC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The prefactor for the non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.NONDIAG_ENERGY_STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Add a non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.NONDIAG_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Preconditioner with the occupation numbers (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.OCCUPATION_PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "On the fly localization of the molecular orbitals. Can only be used with OT/IRAC.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.ON_THE_FLY_LOC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "The orthogonality method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.ORTHO_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "How the preconditioner is applied to the residual.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.PRECOND_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Introduce additional variables so that rotations of the occupied subspace are allowed as well, only needed for cases where the energy is not invariant under  a rotation of the occupied subspace such as non-singlet restricted calculations  or fractional occupations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.ROTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Reject DIIS steps if they point away from the minimum, do SD in that case.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.SAFE_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Introduce additional self-consistent polarization through response basis set = orbital basis set for NDDO.)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.SCP_NDDO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "controls the activation of the ot method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "Initial stepsize used for the line search, sometimes this parameter can be reduced to stablize DIIS or to improve the CG behavior in the first few steps. The optimal value depends on the quality of the preconditioner. A negative values leaves the choice to CP2K depending on the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT.STEPSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT"
      ]
    }, {
      "description": "controls the activation of the diagonalization method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Threshold on the convergence to start using DIAG/DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.EPS_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Throw away linear combinations of basis functions with a small eigenvalue in S",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.EPS_EIGVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "target accuracy of the computation of the lumo energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.EPS_LUMO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "target accuracy for the scf convergence after the history pipeline is filled",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.EPS_SCF_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "target accuracy for the scf convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Use level shifting to improve convergence",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.LEVEL_SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Maximum number of DIIS vectors to be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MAX_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "The maximum number of iteration for the lumo computation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MAX_ITER_LUMO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Maximum number of SCF iterations after the history pipeline is filled",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MAX_SCF_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Maximum number of SCF iteration to be performed for one optimization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MAX_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Fraction of new density to be included",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Denominator parameter in Kerker damping introduced to suppress charge sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 + beta^2)*(rho_out(g)-rho_in(g))",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": " w0 parameter used in Broyden mixing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.BROY_W0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WMAX",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.BROY_WMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Settings for BROY_WREF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.BROY_WREF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Restricts the G-space mixing to lower part of G-vector spectrum, up to a G0, by assigning the exponent of the Gaussian that can be represented by vectors smaller than G0 within a certain accuracy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.MAX_GVEC_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Upper bound for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.MAX_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Mixing method to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Number of kerker damping iterations before starting other mixing procedures",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.N_SIMPLE_MIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Number of previous steps stored for the actual mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.NBUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Minimal number of density mixing (should be greater than 0),before starting DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.NMIXING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Number of initial iteration for which the mixing is skipped",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.NSKIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Fraction of new density to be added to the Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.PULAY_ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Fraction of residual contribution to be added to Pulay expansion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.PULAY_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Control factor for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.R_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Regularization parameter to stabilize the inversion of the residual matrix {Yn^t Yn} in the multisecant mixing scheme (noise)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.REGULARIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Controls the activation of the mixing procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.MIXING.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING"
      ]
    }, {
      "description": "Sets the number of columns in a scalapack block",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.NCOL_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "sets the number of rows in a scalapack block",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.NROW_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Algorithm to be used for OT",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.ALGORITHM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Enable adaptive curvature estimation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_ADAPTIVE_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Underrelaxation for the broyden mixer",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Ensure positive definite update",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_ENABLE_FLIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Dampening of estimated energy curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_ETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Forget history on bad approximation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_FORGET_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Backtracking parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Growth limit of curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Reduction of curvature on bad approximation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_SIGMA_DECREASE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Minimum adaptive curvature.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_SIGMA_MIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Curvature of energy functional.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.BROYDEN_SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Optimize orbital energies for use in Fermi-Dirac smearing (requires ROTATION and FD smearing to be active).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.ENERGIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (can be a small number, e.g. 0.002). FULL_SINGLE_INVERSE takes it as lower bound (values below 0.05 can cause stability issues). In general, heigher values will tame the preconditioner in case of poor initial guesses. A negative value will leave the choice to CP2K depending on type of preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Sets the threshold for filtering the matrices.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.EPS_IRAC_FILTER_MATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Only one extra refinement iteration is done when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.EPS_IRAC_QUICK_EXIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "The algorithm switches to the polynomial refinement when the norm is below this value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.EPS_IRAC_SWITCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Targeted accuracy during the refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.EPS_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Target accuracy of the taylor expansion for the matrix functions, should normally be kept as is.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.EPS_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Target relative uncertainty in the location of the minimum for LINESEARCH GOLD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.GOLD_TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "The refinement polynomial degree (2, 3 or 4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.IRAC_DEGREE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "1D line search algorithm to be used with the OT minimizer, in increasing order of robustness and cost. MINIMIZER CG combined with LINESEARCH GOLD should always find an electronic minimum.  Whereas the 2PNT minimizer is almost always OK, 3PNT might be needed for systems in which successive OT CG steps do not decrease the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.LINESEARCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Maximum allowed refinement iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.MAX_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Maximum order of the Taylor expansion before diagonalisation is prefered, for large parallel runs a slightly higher order could sometimes result in a small speedup.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.MAX_TAYLOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Minimizer to be used with the OT method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.MINIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Uses a mixed precision algorithm.With a well behaved basis set (i.e. condition number less than 1/eps_sp)it provides double precision accuracy results and up to a 2 fold speedup for building and applying the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.MIXED_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Number of history vectors to be used with DIIS or BROYDEN",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.N_HISTORY_VEC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "The prefactor for the non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.NONDIAG_ENERGY_STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Add a non-diagonal energy penalty (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.NONDIAG_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Preconditioner with the occupation numbers (FD smearing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.OCCUPATION_PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "On the fly localization of the molecular orbitals. Can only be used with OT/IRAC.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.ON_THE_FLY_LOC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "The orthogonality method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.ORTHO_IRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "How the preconditioner is applied to the residual.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.PRECOND_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Introduce additional variables so that rotations of the occupied subspace are allowed as well, only needed for cases where the energy is not invariant under  a rotation of the occupied subspace such as non-singlet restricted calculations  or fractional occupations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.ROTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Reject DIIS steps if they point away from the minimum, do SD in that case.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.SAFE_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Introduce additional self-consistent polarization through response basis set = orbital basis set for NDDO.)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.SCP_NDDO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "controls the activation of the ot method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Initial stepsize used for the line search, sometimes this parameter can be reduced to stablize DIIS or to improve the CG behavior in the first few steps. The optimal value depends on the quality of the preconditioner. A negative values leaves the choice to CP2K depending on the preconditioner.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OT.STEPSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT"
      ]
    }, {
      "description": "Maximum number of times the same point will be used in bisection, a small number guards against the effect of wrongly converged states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.BISECT_TRUST_COUNT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Maximum number of DIIS vectors used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.DIIS_BUFFER_LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "The target gradient of the outer scf variables. Notice that the EPS_SCF of the inner loop also determines the value that can be reached in the outer loop, typically EPS_SCF of the outer loop must be smaller than EPS_SCF of the inner loop.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Number of past states used in the extrapolation of the variables during e.g. MD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.EXTRAPOLATION_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "The maximum number of outer loops",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.MAX_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Method used to bring the outer loop to a stationary point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.OPTIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "controls the activation of the outer SCF loop",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "The initial step_size used in the optimizer (currently steepest descent).Note that in cases where a sadle point is sought for (DDAPC_CONSTRAINT), this can be negative",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Specifies which kind of outer SCF should be employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF"
      ]
    }, {
      "description": "Allows to define the parameter f for the general ROKS scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.ROKS_F",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Allows to define all parameters for the high-spin ROKS scheme explicitly. The full set of 6 parameters has to be specified in the order acc, bcc, aoo, boo, avv, bvv",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.ROKS_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Selects the ROKS scheme when ROKS is applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.ROKS_SCHEME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Change the initial guess for the wavefunction.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SCF_GUESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Electronic temperature in the case of Fermi-Dirac smearing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.ELECTRONIC_TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "Accuracy checks on occupation numbers use this as a tolerance",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.EPS_FERMI_DIRAC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "Imposed difference between the numbers of electrons of spin up and spin down: m = n(up) - n(down). A negative value (default) allows for a change of the magnetic moment. -1 specifically keeps an integer number of spin up and spin down electrons.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.FIXED_MAGNETIC_MOMENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "A list of fractional occupations to use. Must match the number of states and sum up to the correct number of electrons",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "Smearing method to be applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "Controls the activation of smearing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "Size of the energy window centred at the Fermi level",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR.WINDOW_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR"
      ]
    }, {
      "description": "controls the activation of core-level spectroscopy simulations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "# of states where to look for the one to be excited",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.STATE_SEARCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Type of the orbitas that are excited for the xas spectra calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.STATE_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Root of the file names where to read the MOS fromwhich to restart the calculation of the core level excited states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.WFN_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Occupation of the core state in XAS calculation by TP_FLEX.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.XAS_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Total number of electrons for spin channel alpha, in XAS calculation by TP_FLEX.If negative value, the number of electrons is set to GS number of electron  minus the amount subtracted from the core state",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.XAS_TOT_EL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Occupation of the core state in XES calculation by TP_VAL.The homo is emptied by the same amount",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.XES_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Set the occupation of the HOMO in XES calculation by TP_VAL.The HOMO can be emptied or not, if the core is still full",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XAS.XES_EMPTY_HOMO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Which model for the coupling constant integration should be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING.FUNCTIONAL_MODEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "Which Hybrid functional should be used. (Has to be consistent with the definitions in XC and HF).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING.FUNCTIONAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "The point to be used along the adiabatic curve (0 &#60; Î» &#60; 1)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "Long-range parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING"
      ]
    }, {
      "description": "The cutoff on the density used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.DENSITY_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Parameter for the smoothing procedure inxc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.DENSITY_SMOOTH_CUTOFF_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Select the code for xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.FUNCTIONAL_ROUTINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "The cutoff on the gradient of the density used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.GRADIENT_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HF_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HF_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HF_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HF_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HF_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HF_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HF_INFO"
      ]
    }, {
      "description": "Accuracy of iterative RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HFX_RI.EPS_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Accuracy of geminal integral evaluation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HFX_RI.EPS_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Maximum number of iteration in RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.HFX_RI.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HFX_RI"
      ]
    }, {
      "description": "Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Parameter for short/longrange interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, longrange or shortrange).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.SCALE_COULOMB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.SCALE_GAUSSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.SCALE_LONGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL.T_C_G_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Number of bins per process used to group atom quartets.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE.NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE.RANDOMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.MEMORY.EPS_STORAGE_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.MEMORY.MAX_DISK_SPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all the threads within a process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.MEMORY.STORAGE_LOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.MEMORY.TREAT_FORCES_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.MEMORY"
      ]
    }, {
      "description": "Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.PERIODIC.NUMBER_OF_SHELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.PERIODIC"
      ]
    }, {
      "description": "Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.PW_HFX_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.PW_HFX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.SCREENING.EPS_SCHWARZ_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.SCREENING.EPS_SCHWARZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disabled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.SCREENING.P_SCREEN_CORRECTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.SCREENING.SCREEN_ON_INITIAL_P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.SCREENING.SCREEN_P_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.SCREENING"
      ]
    }, {
      "description": "Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.HF.TREAT_LSD_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "The cutoff on tau used by the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.TAU_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "The cutoff of the FFT grid used in the calculation of the nonlocal vdW functional [Ry].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Name of the kernel data file, may include a path.vdW_kernel_table.dat is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL.KERNEL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Parameters b and C of the rVV10 functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Type of functional (the corresponding kernel data file should be selected).Allows for common forms such as vdW-DF, vdW-DF2, optB88-vdW, rVV10.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Extensive output for non local functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL.VERBOSE_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL"
      ]
    }, {
      "description": "Specifies the coordination number of a set of atoms for the C9 term in DFT-D3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.ATOM_COORDINATION_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Specifies parameters for atom types (in atomic units). If not provided default parameters are used (DFT-D2).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.ATOMPARM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate C9 terms in DFT-D3 model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.CALCULATE_C9_TERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3 method, if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.D3_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameters (s6,a1,s8,a2) for the DFT-D3(BJ) method, if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.D3BJ_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Cutoff value for coordination number function (DFT-D3 method)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.EPS_CN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Prefactor in exponential damping factor (DFT-D2 potential)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.EXP_PRE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Specifies the coordination number for a kind for the C9 term in DFT-D3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.KIND_COORDINATION_NUMBERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate a long range correction to the DFT-D3 model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.LONG_RANGE_CORRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Name of the parameter file, may include a path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PARAMETER_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD"
      ]
    }, {
      "description": "Range of potential. The cutoff will be 2 times this value",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.R_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Calculate C9 terms in DFT-D3 model using reference coordination numbers",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.REFERENCE_C9_TERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Use parameters for this specific density functional. For available D3 and D3(BJ) parameters see: http://www.thch.uni-bonn.de/tc/downloads/DFT-D3/functionals.html, http://www.thch.uni-bonn.de/tc/downloads/DFT-D3/functionalsbj.html",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.REFERENCE_FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "XC Functional dependent scaling parameter, if set to zero CP2K attempts to guess the xc functional that is in use and sets the associated scaling parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Type of potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Extensive output for the DFT-D2 and DFT-D3 models",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.VERBOSE_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Type of dispersion/vdW functional or potential to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "Calculate the condition number of the (P|Q) matrix for the RI methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.CALC_COND_NUM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Size of the column block used in the SCALAPACK block cyclic data distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.COL_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Convergence threshold for the solution of the Z-vector equations. The Z-vector equations have the form of a linear system of equations Ax=b, convergence is achieved when |Ax-b|<=EPS_CONV.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.CPHF.EPS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.CPHF"
      ]
    }, {
      "description": "Maximum number of iterations allowed for the solution of the Z-vector equations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.CPHF.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.CPHF"
      ]
    }, {
      "description": "Send big messages between processes (useful for >48 processors).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.DIRECT_CANONICAL.BIG_SEND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.DIRECT_CANONICAL"
      ]
    }, {
      "description": "Group size used in the computation of the integrals. Default is to use all processors (GROUP_SIZE=-1).A smaller group size (for example the node size), might a better choice if the actual MP2 time is large compared to integral computation time. This is usually the case if the total number of processors is not too large.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.GROUP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, TShPSC operator).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines truncation radius for the truncated TShPSC potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL.TRUNCATION_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file TShPSC.dat that contains the data for the evaluation of the TShPSC G0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL.TSHPSC_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Maximum allowed total memory usage during MP2 methods [Mb].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Which method should be used to compute the MP2 energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO"
      ]
    }, {
      "description": "Specifies the size of the auxiliary basis set automatically generated as initial guess. This will be effective only if RI_AUX_BASIS_SET in the KIND section and NUM_FUNC are not specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS.BASIS_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Target accuracy in the relative deviation of the amplitudes calculated with and without RI approximation, (more details in Chem.Phys.Lett.294(1998)143).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS.DELTA_I_REL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Target accuracy in the absolute difference between the RI-MP2 and the exact MP2 energy, DRI=ABS(E_MP2-E_RI-MP2).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS.DELTA_RI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "The derivatives of the MP2 energy with respect to the exponents of the basis are calculated numerically. The change in the exponent a_i employed for the numerical evaluation is defined as h_i=EPS_DERIV*a_i.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS.EPS_DERIV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Specifies the maximum number of steps in the RI basis optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Specifies the number of function, for each angular momentum (s, p, d ...), employed in the automatically generated initial guess. This will be effective only if RI_AUX_BASIS_SET in the KIND section is not specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS.NUM_FUNC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS"
      ]
    }, {
      "description": "Number of quadrature points for the numerical integration in the RI-SOS-MP2-Laplace method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_LAPLACE.QUADRATURE_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_LAPLACE"
      ]
    }, {
      "description": "Group size for the integration in the Laplace method, that is the number of processes involved in the computation of each integration point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_LAPLACE.SIZE_INTEG_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_LAPLACE"
      ]
    }, {
      "description": "Determines the blocking used for communication in RI-MP2. Larger BLOCK_SIZE reduces communication but requires more memory. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "Threshold for discriminate if a given ij pairs of the unrelaxed MP2 density matrix has to be calculated with a canonical reformulation based on the occupied eigenvalues differences.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2.EPS_CANONICAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "Free the buffer containing the 4 center integrals used in the Hartree-Fock exchange calculation. This will be effective only for gradients calculations, since for the energy only case, the buffers are released by default. (Right now debugging only).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2.FREE_HFX_BUFFER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2"
      ]
    }, {
      "description": "The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO"
      ]
    }, {
      "description": "Accuracy of iterative RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.EPS_OPTIMIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Accuracy of geminal integral evaluation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.EPS_SCREENING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Maximum number of iteration in RI fit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI"
      ]
    }, {
      "description": "Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Parameter for short/longrange interaction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Which interaction potential should be used (Coulomb, longrange or shortrange).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.POTENTIAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_COULOMB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_GAUSSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.SCALE_LONGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL.T_C_G_DATA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL"
      ]
    }, {
      "description": "Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Number of bins per process used to group atom quartets.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE.RANDOMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE"
      ]
    }, {
      "description": "Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.EPS_STORAGE_SCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.MAX_DISK_SPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all the threads within a process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.MAX_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.STORAGE_LOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY.TREAT_FORCES_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY"
      ]
    }, {
      "description": "Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC.NUMBER_OF_SHELLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC"
      ]
    }, {
      "description": "Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.PW_HFX_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.PW_HFX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.EPS_SCHWARZ_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.EPS_SCHWARZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disabled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.P_SCREEN_CORRECTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.SCREEN_ON_INITIAL_P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING.SCREEN_P_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING"
      ]
    }, {
      "description": "Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.TREAT_LSD_IN_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Use the Minimax quadrature scheme for performing the numerical integration. Maximum number of quadrature point limited to 20.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.MINIMAX_QUADRATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Matrix multiplication style for the Q matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.MM_STYLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Number of quadrature points for the numerical integration in the RI-RPA method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.QUADRATURE_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Group size for frequency integration, that is the number of processes involved in the computation of each integration point. SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.SIZE_FREQ_INTEG_GROUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Size of the row block used in the SCALAPACK block cyclic data distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.ROW_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Scaling factor of the singlet energy component (opposite spin, OS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.SCALE_S",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Scaling factor of the triplet energy component (same spin, SS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.SCALE_T",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "The cutoff of the finest grid level in the MP2 gpw integration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW.CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines a threshold for the DBCSR based multiply (usually 10 times smaller than EPS_GRID).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW.EPS_FILTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines a threshold for the GPW based integration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW.EPS_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "How much output is written by the individual groups.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW.PRINT_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "Determines the grid at which a Gaussian is mapped.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88"
      ]
    }, {
      "description": "Potential parameter in erf(omega*r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR"
      ]
    }, {
      "description": "Defines the parameter of the adiabatic curve",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "Potential parameter in erf(omega*r)/r",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC"
      ]
    }, {
      "description": "switches between the B97 and Grimme parametrization",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "scales the exchange part of the functional, if -1 the default for the given parametrization is used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97"
      ]
    }, {
      "description": "Defines the cutoff radius for the truncation. If put to zero, the standard full range potential will be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "Parameter in the exchange hole. Usually this is put to 1.0 or 0.8",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BEEF.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BEEF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BEEF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BEEF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.CS1.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.CS1"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "Parameter for Becke Roussel hole",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09"
      ]
    }, {
      "description": "Which version of the parameters should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.HCTH.PARAMETER_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.HCTH"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.HCTH.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.HCTH"
      ]
    }, {
      "description": "Which one of the KE_GGA functionals should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_GGA.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_GGA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_GGA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_GGA"
      ]
    }, {
      "description": "names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "parameters of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "scaling factors of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR"
      ]
    }, {
      "description": "names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "parameters of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "scaling factors of the functionals",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP"
      ]
    }, {
      "description": "Defines the parameter of the adiabatic curve.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP_ADIABATIC.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP_ADIABATIC"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP_ADIABATIC.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP_ADIABATIC"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.OPTX.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.OPTX"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.OPTX.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.OPTX"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.P86C.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.P86C"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.P86C.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.P86C"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PADE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PADE"
      ]
    }, {
      "description": "switches between the different parametrizations of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE"
      ]
    }, {
      "description": "Defines cutoff for lower integration boundary",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.CUTOFF_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR"
      ]
    }, {
      "description": "Which one of parametrizations should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "Scaling of the energy functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92"
      ]
    }, {
      "description": "Which one of parametrizations should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81.PARAMETRIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81"
      ]
    }, {
      "description": "Shortcut for the most common functional combinations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TF"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TFW.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TFW"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS"
      ]
    }, {
      "description": "Which version of the VWN functional should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN.FUNCTIONAL_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "scales the correlation part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN.SCALE_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "Value of the xa parameter (this does not change the exponent, just the mixing)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA.XA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA"
      ]
    }, {
      "description": "Which one of the XGGA functionals should be used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XGGA.FUNCTIONAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XGGA"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XGGA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XGGA"
      ]
    }, {
      "description": "screening parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE.OMEGA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "scales the exchange part of the original hole PBE-functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE.SCALE_X0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "scales the exchange part of the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE.SCALE_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "activates the functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE"
      ]
    }, {
      "description": "Uses a finer grid only to calculate the xc",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_GRID.USE_FINER_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_GRID"
      ]
    }, {
      "description": "The method used to compute the derivatives",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_GRID.XC_DERIV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_GRID"
      ]
    }, {
      "description": "The density smoothing used for the xc calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_GRID.XC_SMOOTH_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_GRID"
      ]
    }, {
      "description": "How to determine the total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL"
      ]
    }, {
      "description": "Value of the alpha parameter (default = 1.19).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Value of the beta parameter (default = 0.01).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Value of the K_rho parameter (default = 0.42).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP.K_RHO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP"
      ]
    }, {
      "description": "Selects the empirical interaction potential model",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EIP.EIP_MODEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EIP"
      ]
    }, {
      "description": "Number of atoms in each molecule (at the moment only uniform system cam be handled)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EP.AT_PER_MOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EP"
      ]
    }, {
      "description": "Path to the input to be used for the component of the main system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EP.COMP_INPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EP"
      ]
    }, {
      "description": "If only e0 should be calculated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EP.E0_ONLY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EP"
      ]
    }, {
      "description": "Requested convergence of the linear solver (for psi1)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EP.EPS_LIN_SOLV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EP"
      ]
    }, {
      "description": "If rotations from a unique set of coefficients should be used or if single molecule optimizations generate it",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EP.ROTATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EP"
      ]
    }, {
      "description": "Starting coefficients for roatation based ep",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EP.START_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EP"
      ]
    }, {
      "description": "Specifies the atoms on which the external potential will act",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.ATOMS_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Specifies the functional form in mathematical notation. Variables must be the atomic coordinates (X,Y,Z).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Defines the values of  parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.EXTERNAL_POTENTIAL.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL"
      ]
    }, {
      "description": "Which method should be used to compute forces",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Coupling parameter H12 used in the coupling",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.COUPLING.COUPLING_PARAMETER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.COUPLING"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "Specifies the mixing functional form in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.MIXING_FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GENERIC.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC"
      ]
    }, {
      "description": "gives the exact number of processors for each group. If not specified processors allocated will be equally distributed for the specified subforce_eval, trying to build a number of groups equal to the number of subforce_eval specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.GROUP_PARTITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "Specify the mixing parameter lambda in the formula:",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.LINEAR.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.LINEAR"
      ]
    }, {
      "description": "Specify the fragments definition of the force_eval through the fragments of the force_eval_mixed. This avoids the pedantic definition of the fragments for the force_eval, assuming the order of the fragments for the specified force_eval is the same as the sequence  of integers provided. Easier to USE should be preferred to the specification of the single fragments.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.DEFINE_FRAGMENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL"
      ]
    }, {
      "description": "Starting and ending atomic index defining one fragment must be provided",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT"
      ]
    }, {
      "description": "Provides the index of the fragment of the MIXED force_eval mapped on the locally defined fragment.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT.MAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT"
      ]
    }, {
      "description": "Defines the index of the fragment defined",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT"
      ]
    }, {
      "description": "Defines the index of the force_eval for which fragments and mappings are provided",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL"
      ]
    }, {
      "description": "Starting and ending atomic index defining one fragment must be provided",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED.FRAGMENT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED.FRAGMENT"
      ]
    }, {
      "description": "Defines the index of the fragment defined",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED.FRAGMENT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED.FRAGMENT"
      ]
    }, {
      "description": "The type of mixing to be employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.MIXING_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "Gives the wanted number of groups. If not specified the number of groups is set to the number of subforce_eval defined.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.NGROUPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "Strength of the restraint (k) in k*(E1-E2-t)**2",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.RESTRAINT.RESTRAINT_STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.RESTRAINT"
      ]
    }, {
      "description": "Target value of the restraint (t)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MIXED.RESTRAINT.RESTRAINT_TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.RESTRAINT"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the bend.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Defines the the cubic force constant of the bend",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.CB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Mixed bend stretch parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.KBS12",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Mixed bend stretch parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.KBS32",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Define the kind of bend potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Mixed bend stretch parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.KSS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Defines the force constant of the potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Mixed bend stretch parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.R012",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Mixed bend stretch parameter",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.R032",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Defines the equilibrium angle.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.THETA0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Defines the cubic stretch term.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB.CS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB"
      ]
    }, {
      "description": "Define the kind of Urey-Bradleypotential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB"
      ]
    }, {
      "description": "Defines the force constant of the potential. For MORSE potentials 2 numbers are expected. For QUARTIC potentials 3 numbers are expected.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB"
      ]
    }, {
      "description": "Defines the equilibrium distance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BOND.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BOND"
      ]
    }, {
      "description": "Defines the cubic stretch term.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BOND.CS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BOND"
      ]
    }, {
      "description": "Define the kind of Bondpotential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BOND.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BOND"
      ]
    }, {
      "description": "Defines the force constant of the potential. For MORSE potentials 2 numbers are expected. For QUARTIC potentials 3 numbers are expected.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BOND.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BOND"
      ]
    }, {
      "description": "Defines the equilibrium distance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.BOND.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BOND"
      ]
    }, {
      "description": "Defines the atomic kind of the charge.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.CHARGE.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.CHARGE"
      ]
    }, {
      "description": "Defines the charge of the MM atom in electron charge unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.CHARGE.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.CHARGE"
      ]
    }, {
      "description": "Value of the charge for the individual atom. Order MUST reflect the one specified for the geometry.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.CHARGES.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.CHARGES"
      ]
    }, {
      "description": "Defines the isotropic polarizability of the MM atom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.APOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE"
      ]
    }, {
      "description": "Defines the atomic kind of the scf dipole.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE"
      ]
    }, {
      "description": "Defines the atomic kind for this damping function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING"
      ]
    }, {
      "description": "Defines the BIJ parameter for this damping.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING.BIJ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING"
      ]
    }, {
      "description": "Defines the CIJ parameter for this damping.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING.CIJ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING"
      ]
    }, {
      "description": "Defines the order for this damping.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING.ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING"
      ]
    }, {
      "description": "Defines the damping type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING"
      ]
    }, {
      "description": "Controls the computation of all the real-sapce (short-range) nonbonded interactions. This also includes the real-space corrections for excluded or scaled 1-2, 1-3 and 1-4 interactions. When set to F, the neighborlists are not created and all interactions that depend on them are not computed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.DO_NONBONDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Scaling factor for the electrostatics 1-4",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.EI_SCALE14",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Do not abort when critical force-field parameters are missing. CP2K will run as if the terms containing the missing parameters are zero.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.IGNORE_MISSING_CRITICAL_PARAMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the improper tors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER"
      ]
    }, {
      "description": "Define the kind of improper torsion potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER"
      ]
    }, {
      "description": "Defines the force constant of the potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER"
      ]
    }, {
      "description": "Defines the phase of the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER.PHI0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER"
      ]
    }, {
      "description": "Enables the possibility to define NONBONDED and NONBONDED14 as a sum of different kinds of potential. Useful for piecewise defined potentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.MULTIPLE_POTENTIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Defines the atomic kind involved in the BMHFT nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the A parameter of the Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the B parameter of the Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the C parameter of the Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the D parameter of the Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the kinds for which internally is defined the BMHFT nonbond potential at the moment only Na and Cl.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.MAP_ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the cutoff parameter of the BMHFT potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT"
      ]
    }, {
      "description": "Defines the atomic kind involved in the BMHFTD nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the A parameter of the dispersion-damped Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the BD parameter of the dispersion-damped Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.BD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the B parameter of the dispersion-damped Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the C parameter of the dispersion-damped Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the D parameter of the dispersion-damped Fumi-Tosi Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the kinds for which internally is defined the BMHFTD nonbond potential at the moment no species included.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.MAP_ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the order for this damping.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the cutoff parameter of the BMHFTD potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the A parameter of the Buckingham potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the B parameter of the Buckingham potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the C parameter of the Buckingham  potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Coefficients of the polynomial used in the second rangeThis keyword can be repeated several times.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.POLY1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Coefficients of the polynomial used in the third rangeThis keyword can be repeated several times.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.POLY2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the upper bound of the first range",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.R1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the upper bound of the second range",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.R2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the upper bound of the third range",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.R3",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Buckingham potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES"
      ]
    }, {
      "description": "Defines the A1 parameter of Buckingham+Morse potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.A1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the A2 parameter of Buckingham+Morse potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.A2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the B1 parameter of Buckingham+Morse potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.B1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the B2 parameter of Buckingham+Morse potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.B2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the width for the Morse part",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the C parameter of Buckingham+Morse  potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the amplitude for the Morse part",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the f0 parameter of Buckingham+Morse potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.F0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the equilibrium distance for the Morse part",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Buckingham potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.EAM.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.EAM"
      ]
    }, {
      "description": "Specifies the filename that contains the tabulated EAM potential. File structure: the first line of the potential file contains a title. The second line contains: atomic number, mass and lattice constant. These information are parsed but not used in CP2K. The third line contains: dr: increment of r for the tabulated values of density and phi (assuming r starts in 0) [angstrom]; drho: increment of density for the tabulated values of the embedding function (assuming rho starts in 0) [au_c]; cutoff: cutoff of the EAM potential; npoints: number of points in tabulated. Follow in order npoints lines for rho [au_c] and its derivative [au_c*angstrom^-1]; npoints lines for PHI [ev] and its derivative [ev*angstrom^-1] and npoint lines for the embedded function [ev] and its derivative [ev*au_c^-1].",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.EAM.PARM_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.EAM"
      ]
    }, {
      "description": "Defines the atomic kind involved in the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Specifies the functional form in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the cutoff parameter of the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the variable of the functional form.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the DC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.DC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the D parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the MC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.MC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the M parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the VR0 parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN.VR0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the atomic kind involved in the IPBV nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV"
      ]
    }, {
      "description": "Defines the cutoff parameter of the IPBV potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the EPSILON parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the cutoff parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the SIGMA parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the QUIP potential. For more than 2 elements, &QUIP section must be repeated until each element has been mentioned at least once. Set IGNORE_MISSING_CRITICAL_PARAMS to T in enclosing &FORCEFIELD section to avoid having to list every pair of elements separately.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP"
      ]
    }, {
      "description": "Specifies the potential calculation arguments for the QUIP potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP.CALC_ARGS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP"
      ]
    }, {
      "description": "Specifies the potential initialization arguments for the QUIP potential. If blank (default) first potential defined in QUIP parameter file will be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP.INIT_ARGS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP"
      ]
    }, {
      "description": "Specifies the filename that contains the QUIP potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP.PARM_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the beta parameter of Siepmann potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the B parameter of Siepmann potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the D parameter of Siepmann potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the E parameter of Siepmann potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.E",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the F parameter of Siepmann potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.F",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the cutoff parameter of Siepmann potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN"
      ]
    }, {
      "description": "Defines the alpha parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the A parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the beta parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the D parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.BIGD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the bigR parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.BIGR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the B parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the c parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the d parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the h parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.H",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the lambda1 parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.LAMBDA1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the lambda2 parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.LAMBDA2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the lambda3 parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.LAMBDA3",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the n parameter of Tersoff potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the cutoff parameter of the tersoff potential.  This parameter is in principle already defined by the values of  bigD and bigR. But it is necessary to define it when using the tersoff  in conjuction with other potentials (for the same atomic pair) in order to have the same consistent definition of RCUT for all potentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the A parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the B parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the C parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the atomic kind involved in the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Specifies the functional form in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the cutoff parameter of the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the variable of the functional form.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the DC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.DC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the D parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the MC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.MC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the M parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the VR0 parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN.VR0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the EPSILON parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the cutoff parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the SIGMA parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the A parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the B parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the C parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the opbend.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND"
      ]
    }, {
      "description": "Define the kind of out of plane bend potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND"
      ]
    }, {
      "description": "Defines the force constant of the potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND"
      ]
    }, {
      "description": "Defines the phase of the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND.PHI0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND"
      ]
    }, {
      "description": "Specifies the filename that contains the parameters of the FF.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.PARM_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Define the kind of torsion potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.PARMTYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Defines the atomic kind of the scf quadrupole.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.QUADRUPOLE.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.QUADRUPOLE"
      ]
    }, {
      "description": "Defines the isotropic polarizability of the MM atom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.QUADRUPOLE.CPOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.QUADRUPOLE"
      ]
    }, {
      "description": "Partial charge assigned to the core (electron charge units)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.CORE_CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Force constant k2 of the spring potential 1/2*k2*r^2 + 1/24*k4*r^4 binding a core-shell pair when a core-shell potential is employed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.K2_SPRING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Force constant k4 of the spring potential 1/2*k2*r^2 + 1/24*k4*r^4 binding a core-shell pair when a core-shell potential is employed. By default a harmonic spring potential is used, i.e. k4 is zero.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.K4_SPRING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Fraction of the mass of the atom to be assigned to the shell",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.MASS_FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Assign a maximum elongation of the spring, if negative no limit is imposed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.MAX_DISTANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "The kind for which the shell potential parameters are given",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Partial charge assigned to the shell (electron charge units)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.SHELL_CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Define a screening function to exclude some neighbors  of the shell when electrostatic interaction are considered, if negative no screening is operated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHELL.SHELL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL"
      ]
    }, {
      "description": "Add a constant energy shift to the real-space non-bonding interactions (both Van der Waals and electrostatic) such that the energy at the cutoff radius is zero. This makes the non-bonding interactions continuous at the cutoff.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SHIFT_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Specify the maximum value of energy used to check the accuracy requested through EPS_SPLINE. Energy values larger than EMAX_ACCURACY generally do not  satisfy the requested accuracy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.EMAX_ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "Specify the maximum value of the potential up to which splines will be constructed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.EMAX_SPLINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "Specify the threshold for the choice of the number of points used in the splines (comparing the splined value with the  analytically evaluated one)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.EPS_SPLINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "Override the default search for an accurate spline by specifying a fixed number of spline points.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.NPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "Specify the minimum value of the distance interval  that brackets the value of emax_spline.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.R0_NB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "Cutoff radius for nonbonded interactions. This value overrides  the value specified in the potential definition and is global for all potentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.RCUT_NB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "For few potentials (Lennard-Jones) one global optimal spline is generated instead of different optimal splines for each kind of potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE.UNIQUE_SPLINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the tors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.TORSION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.TORSION"
      ]
    }, {
      "description": "Define the kind of torsion potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.TORSION.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.TORSION"
      ]
    }, {
      "description": "Defines the force constant of the potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.TORSION.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.TORSION"
      ]
    }, {
      "description": "Defines the multiplicity of the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.TORSION.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.TORSION"
      ]
    }, {
      "description": "Defines the phase of the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.TORSION.PHI0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.TORSION"
      ]
    }, {
      "description": "Scaling factor for the VDW 1-4",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.VDW_SCALE14",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "A short range repulsive potential is added, to simulate collisions and scattering.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.FORCEFIELD.ZBL_SCATTERING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This keyword enables the check that two atoms are never below the minimum value used to construct the splines during the construction of the neighbouring list. Disabling this keyword avoids CP2K to abort in case two atoms are below the minimum  value of the radius used to generate the splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.NEIGHBOR_LISTS.GEO_CHECK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "This keyword enables the building of the neighbouring list from scratch.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.NEIGHBOR_LISTS.NEIGHBOR_LISTS_FROM_SCRATCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "Defines the Verlet Skin for the generation of the neighbor lists",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.NEIGHBOR_LISTS.VERLET_SKIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "alpha parameter associated with Ewald (EWALD|PME|SPME). Recommended for small systems is is alpha = 3.5 / r_cut. Tuning alpha, r_cut and gmax is needed to obtain O(N**1.5) scaling for ewald.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "tolerance of gaussians for fft interpolation (PME only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "Expected accuracy in the Ewald sum. This number affects only the calculation of the cutoff for the real-space term of the ewald summation (EWALD|PME|SPME) as well as the construction of the neighbor lists (if the cutoff for non-bonded terms is smaller than the value employed to compute the EWALD real-space term). This keyword has no effect on the reciprocal space term (which can be tuned independently).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.EWALD_ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "The type of ewald you want to perform.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.EWALD_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "number of grid points (SPME and EWALD). If a single number is specified,the same number of points is used for all three directions on the grid.If three numbers are given, each direction can have a different number of points.The number of points needs to be FFTable (which depends on the library used) and odd for EWALD.The optimal number depends e.g. on alpha and the size of the cell. 1 point per Angstrom is common.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.GMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "Specify the rmsd threshold for the derivatives of the energy towards the Cartesian dipoles components",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES.EPS_POL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the maximum number of iterations for induced dipoles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES.MAX_IPOL_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the maximum level of multipoles expansion used  for the electrostatics.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES.MAX_MULTIPOLE_EXPANSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the method to obtain self consistent induced multipole moments.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES.POL_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Controls the activation of the Multipoles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "number of grid points on small mesh (PME only), should be odd.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.NS_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "order of the beta-Euler spline (SPME only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.O_SPLINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "Explicitly provide the real-space cutoff of the ewald summation (EWALD|PME|SPME). If present, overwrites the estimate of EWALD_ACCURACY and may affect the construction of the neighbor lists for non-bonded terms (in FIST), if the value specified is larger than the cutoff for non-bonded interactions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "Specifies the number of slices in the x, y and z directions.-1 specifies that any number of slices is OK.If a given distribution can not be satisfied, a replicated grid will result.Also see LOCK_DISTRIBUTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID.DISTRIBUTION_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Parallelization strategy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID.DISTRIBUTION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Can be used to reduce the halo of the distributed grid (experimental features).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID.HALO_REDUCTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Expert use only, only basic QS deals correctly with a non-default value.If the distribution is locked, a grid will have the same distribution asthe next finer multigrid (provided it is distributed).If unlocked, all grids can be distributed freely.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID.LOCK_DISTRIBUTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "If the multigrid-level of a grid is larger than the parameter, it will not be distributed in the automatic scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID.MAX_DISTRIBUTED_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "A grid will only be distributed if the memory usage for that grid (including halo) is smaller than a replicated grid by this parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID.MEMORY_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Convergence parameter ALPHA*RMIN. Default value 7.0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MT.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MT"
      ]
    }, {
      "description": "Specify the multiplicative factor for the CUTOFF keyword in MULTI_GRID  section. The result gives the cutoff at which the 1/r non-periodic FFT3D is evaluated.Default is 2.0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MT.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MT"
      ]
    }, {
      "description": "Evaluates the Gterm in the Ewald Scheme analytically instead of using Splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.ANALYTICAL_GTERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Precision achieved in the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.EWALD_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "Specifies the number of grid points used for the Interpolation of the G-space term",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.NGRIDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Real space cutoff for the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "Specify the directions on wich apply PBC. Important notice,  this only applies to the electrostatics. See the CELL section to specify the periodicity used for e.g. the pair lists. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON"
      ]
    }, {
      "description": "Specify which kind of solver to use to solve the Poisson equation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.POISSON_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON"
      ]
    }, {
      "description": "Type of scaling function used in the wavelet approach, the total energy depends on this choice,and the convergence with respect to cutoff depends on the selected scaling functions.Possible values are 8,14,16,20,24,30,40,50,60,100",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.MM.POISSON.WAVELET.SCF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.WAVELET"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "Specifies the number of digits used for the printing of the forces",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.NDIGITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.FORCES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.GRID_INFORMATION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "Specifies the number of digits used for the printing of the stress tensor",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.NDIGITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.STRESS_TENSOR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS"
      ]
    }, {
      "description": "Calculate atomic energies",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ATOMIC.ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ATOMIC"
      ]
    }, {
      "description": "Calculate atomic pressure tensors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ATOMIC.PRESSURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ATOMIC"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "Specifies the list of atoms that is summed in the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "Specifies the functional form of the term added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.FUNCTIONAL_FORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "force constant of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "target value of the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Specifies the type of constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.TYPE_OF_CONSTRAINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE"
      ]
    }, {
      "description": "Specifies the type of density used for the fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE.TYPE_OF_DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE"
      ]
    }, {
      "description": "Calculate the succeptibility correction to the shift with PBC",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.CHI_PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "The common center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.COMMON_CENTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "Build the gauge=atom using only the atoms within this radius.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.GAUGE_ATOM_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "The gauge used to compute the induced current within GAPW.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.GAUGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "How many boxes along each directions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.NBOX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "The orbital center.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.ORBITAL_CENTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "Restart the induced current density calculation from a previous run (not working yet).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.RESTART_CURRENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "controls the activation of the induced current calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "Select all the states included in the given radius arround each atoms in SELECTED_STATES_ON_ATOM_LIST.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.SELECTED_STATES_ATOM_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "Indexes of the atoms for selecting the states to be used for the response calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.SELECTED_STATES_ON_ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "Use the old way to compute the gauge.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.USE_OLD_GAUGE_ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "Energy gap estimate [a.u.] for preconditioning",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.ENERGY_GAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "Restart the EPR calculation from a previous run (NOT WORKING)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.RESTART_EPR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR"
      ]
    }, {
      "description": "controls the activation of the epr calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR"
      ]
    }, {
      "description": "target accuracy for the convergence of the conjugate gradient.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.EPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "scale angles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.CRAZY_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Use diagonalization (slow) or pade based calculation of matrix exponentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.CRAZY_USE_DIAG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Select the orbitals to be localized within the given energy range.This type of selection cannot be added on top of the selection through a LIST. It reads to reals that are lower and higher boundaries of the energy range.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.ENERGY_RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Tolerance used in the convergence criterium of the localization methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.EPS_LOCALIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Tolerance in the occupation number to select only fully occupied orbitals for the rotation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.EPS_OCCUPATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Use Jacobi method in case no convergence was achieved by using the crazy rotations method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.JACOBI_FALLBACK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Indexes of the unoccupied states to be localized, up to now only valid in combination with GPW. This keyword has to be present if unoccupied states should be localized. This keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.LIST_UNOCCUPIED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Indexes of the occupied wfn to be localizedThis keyword can be repeated several times(useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "File name where to read the MOS fromwhich to restart the localization procedure for occupied states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.LOCHOMO_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "File name where to read the MOS fromwhich to restart the localization procedure for unoccupied states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.LOCLUMO_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Largest allowed angle for the crazy rotations algorithm (smaller is slower but more stable).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.MAX_CRAZY_ANGLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Maximum number of iterations used for localization methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Method of optimization if any",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Requires the maximization of the spread of the wfn",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.MIN_OR_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Type of opertator which defines the spread functional",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.OPERATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Every how many iterations of the localization algorithm(Jacobi) the tolerance value is printed out",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.OUT_ITER_EACH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Restart the localization from a set of orbitals read from a localization restart file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "controls the activation of the MOS localization procedure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Which states to localize, LUMO up to now only available in GPW",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.STATES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Generate an improved initial guess based on a history of results, which is useful during MD.Will only work if the number of states to be localized remains constant.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE.USE_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE"
      ]
    }, {
      "description": "Maximum number of conjugate gradient iteration to be performed for one optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "Calculate the soft part of the chemical shift by interpolation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATE_SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "Name of the file with the NICS points coordinates",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.NICS_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "Calculate the chemical shift in a set of points   given from an external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.NICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "Restart the NMR calculation from a previous run (NOT WORKING YET)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.RESTART_NMR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "controls the activation of the nmr calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "While computing the local part of the shift (GAPW), the integration is restricted to nuclei that are within this radius.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.SHIFT_GAPW_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "Compute the electric-dipole--electric-dipole polarizability",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.DO_RAMAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "controls the activation of the polarizability calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR"
      ]
    }, {
      "description": "Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.PRECONDITIONER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "Restart the conjugate gradient after the specified number of iterations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.RESTART_EVERY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "Restart the response calculation if the restart file exists",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "Compute the diamagnetic spin-orbit contribution (NOT YET IMPLEMENTED)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.DO_DSO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "Compute the Fermi contact contribution",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.DO_FC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "Compute the paramagnetic spin-orbit contribution",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.DO_PSO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "Compute the spin-dipolar contribution",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.DO_SD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "Atoms for which the issc is computed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.ISSC_ON_ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "Restart the spin-spin calculation from a previous run (NOT WORKING YET)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.RESTART_SPINSPIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "controls the activation of the nmr calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "Root of the file names where to read the response functions fromwhich to restart the calculation of the linear response",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.LINRES.WFN_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "Defines the coefficient of the atom in this linear constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT.ATOM_COEF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT"
      ]
    }, {
      "description": "Defines the list of atoms involved in this constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT.ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT"
      ]
    }, {
      "description": "All atoms in ATOM_LIST are constrained to have the same charges. When using this keyword, TARGET and ATOM_COEF do not need to be set and will be ignored. Instead of using this keyword, the constraint section could be repeated.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT.EQUAL_CHARGES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT"
      ]
    }, {
      "description": "the target value for the constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT"
      ]
    }, {
      "description": "Forces the total charge to be integer",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.INTEGER_TOTAL_CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Specifies the maximum distance a fit point is away from an atom of a given kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.RMAX_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the maximum distance a fit point is away from an atom. Valid for all atomic kinds for which no RMAX_KIND are specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the minimum distance a fit point is away from an atom of a given kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.RMIN_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the minimum distance a fit point is away from an atom. Valid for all atomic kinds for which no RMIN_KIND are specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the upper boundary of the box along X used to sample the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.X_HI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the lower boundary of the box along X used to sample the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.X_LOW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the upper boundary of the box along Y used to sample the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.Y_HI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the lower boundary of the box along Y used to sample the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.Y_LOW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the upper boundary of the box along Z used to sample the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.Z_HI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the lower boundary of the box along Z used to sample the potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS.Z_LOW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS"
      ]
    }, {
      "description": "Specifies the list of indexes of atoms used to define the region for the RESP fitting. The list should contain indexes of atoms of the first surface layer.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS.ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS"
      ]
    }, {
      "description": "Length of the sampling box, i.e. a box of this length and the height specified by RANGE is defined above each surface atom given in ATOM_LIST. The grid points in the boxes are accepted as fitting point. Should be in the range of the nearest neighbour distance (a bit larger to be on the safe side). Allows for a refined sampling of grid points in case of corrugated surfaces.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS.LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS"
      ]
    }, {
      "description": "Range where the fitting points are sampled. A range of 3 to 5 Angstroms means that the fitting points are sampled in the region of 3 to 5 Angstroms above the surface which is defined by atom indexes given in ATOM_LIST.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS"
      ]
    }, {
      "description": "Specifies what above the surface means. Defines the direction.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS.SURF_DIRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS"
      ]
    }, {
      "description": "If defined, enforce the restraint of non-hydrogen atoms to zero. Its value is the strength of the restraint on the heavy atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAIN_HEAVIES_STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Restrain non-hydrogen atoms to zero.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAIN_HEAVIES_TO_ZERO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Defines the coefficient of the atom in this linear restraint. If given, the restraint will be: s*(sum over atom_list c_i * q_i - t)**2",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT.ATOM_COEF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT"
      ]
    }, {
      "description": "Defines the list of atoms involved in this restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT.ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT"
      ]
    }, {
      "description": "the target value for the constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT"
      ]
    }, {
      "description": "the target value for the restraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT"
      ]
    }, {
      "description": "The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.STRIDE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Specifies the value of the width of the Gaussian charge distribution carried by each atom. Needs only to be specified when using a periodic Poisson solver.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.PROPERTIES.RESP.WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Specify the lengths of the cell vectors A, B, and C, which defines the diagonal elements of h matrix for an orthorhombic cell. For non-orthorhombic cells it is possible either to specify the angles ALPHA, BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the keywords A, B, and C. The convention is that A lies along the X-axis, B is in the XY plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.ABC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specify the angles between the vectors A, B and C when using the ABC keyword. The convention is that A lies along the X-axis, B is in the XY plane. ALPHA is the angle between B and C, BETA is the angle between A and C and GAMMA the angle between A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.ALPHA_BETA_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector A. This defines the first column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector B. This defines the second column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specify the format of the cell file (if used)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Possibility to read the cell from an external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specify the lengths of the cell vectors A, B, and C, which defines the diagonal elements of h matrix for an orthorhombic cell. For non-orthorhombic cells it is possible either to specify the angles ALPHA, BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the keywords A, B, and C. The convention is that A lies along the X-axis, B is in the XY plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.ABC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the angles between the vectors A, B and C when using the ABC keyword. The convention is that A lies along the X-axis, B is in the XY plane. ALPHA is the angle between B and C, BETA is the angle between A and C and GAMMA the angle between A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.ALPHA_BETA_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector A. This defines the first column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector B. This defines the second column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the format of the cell file (if used)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.CELL_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Possibility to read the cell from an external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector C. This defines the third column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the CELL specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL should be modified in order to affect the coordinates specification.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.MULTIPLE_UNIT_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the directions for which periodic boundary conditions (PBC) will be applied. Important notice: This applies to the generation of the pair lists as well as to the application of the PBCs to positions. See the POISSON section to specify the periodicity used for the electrostatics. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Imposes an initial cell symmetry.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.CELL_REF.SYMMETRY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector C. This defines the third column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the CELL specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL should be modified in order to affect the coordinates specification.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.MULTIPLE_UNIT_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Specify the directions for which periodic boundary conditions (PBC) will be applied. Important notice: This applies to the generation of the pair lists as well as to the application of the PBCs to positions. See the POISSON section to specify the periodicity used for the electrostatics. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Imposes an initial cell symmetry.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CELL.SYMMETRY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "This keyword specifies whether the QM system is centered in units of the grid spacing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CENTER_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "How to do the centering",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CENTER_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "This keyword sets when the qm system is automatically centered.  Default is EVERY_STEP.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.CENTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Additional net charge relative to that specified in DFT section.  Used automatically by force mixing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.DELTA_CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Specifies the type of the QM - MM electrostatic coupling.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.E_COUPL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Set the threshold for the collocation of the GEEP gaussian functions.this keyword affects only the GAUSS E_COUPLING.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.EPS_MM_RSPACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "List of molecule names to exclude from adaptive regions (e.g. big things like proteins)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.ADAPTIVE_EXCLUDE_MOLECULES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Specifies the scaling factor that defines the movement along the defined direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the first atom defining the direction along which the atom will be added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE.ATOM_INDEX_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the second atom defining the direction along which  the atom will be added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE.ATOM_INDEX_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the charge for the added source of QM/MM potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the correction radius used for the QM/MM electrostatic coupling for the added source",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the radius used for the QM/MM electrostatic coupling for the added source",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the scaling factor to be used for projecting the forces on the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of the link. A good guess can be derived from the bond distances of the forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ALPHA_IMOMM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Overwrite the specification of the correction radius only for the MM atom involved in the link.Default is to use the same correction radius as for the specified type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword modifies the MM charge in FIST. The modified charge will be used then also for the generation of the QM/MM potential. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.FIST_SCALE_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the method to use to treat the defined QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.LINK_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the index of the MM atom involved in the QM/MM link, Default hydrogen.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor that defines the movement along the defined direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the MM atom involved in the QM/MM link to be moved",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE.ATOM_INDEX_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the second atom defining the direction along which  the atom will be moved",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE.ATOM_INDEX_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the correction radius used for the QM/MM electrostatic coupling after movement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the radius used for the QM/MM electrostatic coupling after movement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the QM atom involved in the QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.QM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the element of the QM capping atom involved in the QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.QM_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword affects only the QM/MM potential, it doesn't affect the electrostatic in  the classical part of the code. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.QMMM_SCALE_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Overwrite the specification of the radius only for the MM atom involved in the link.Default is to use the same radius as for the specified type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor that defines the movement along the defined direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the first atom defining the direction along which the atom will be added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE.ATOM_INDEX_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the second atom defining the direction along which  the atom will be added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE.ATOM_INDEX_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the charge for the added source of QM/MM potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the correction radius used for the QM/MM electrostatic coupling for the added source",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the radius used for the QM/MM electrostatic coupling for the added source",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the scaling factor to be used for projecting the forces on the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of the link. A good guess can be derived from the bond distances of the forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ALPHA_IMOMM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Overwrite the specification of the correction radius only for the MM atom involved in the link.Default is to use the same correction radius as for the specified type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword modifies the MM charge in FIST. The modified charge will be used then also for the generation of the QM/MM potential. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.FIST_SCALE_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specifies the method to use to treat the defined QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.LINK_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specifies the index of the MM atom involved in the QM/MM link, Default hydrogen.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor that defines the movement along the defined direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the MM atom involved in the QM/MM link to be moved",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE.ATOM_INDEX_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the second atom defining the direction along which  the atom will be moved",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE.ATOM_INDEX_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the correction radius used for the QM/MM electrostatic coupling after movement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the radius used for the QM/MM electrostatic coupling after movement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the QM atom involved in the QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.QM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specifies the element of the QM capping atom involved in the QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.QM_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword affects only the QM/MM potential, it doesn't affect the electrostatic in  the classical part of the code. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.QMMM_SCALE_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Overwrite the specification of the radius only for the MM atom involved in the link.Default is to use the same radius as for the specified type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "The indexes of the mm atoms that have this kind. This keyword can be repeated several times (useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.QM_KIND.MM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.QM_KIND"
      ]
    }, {
      "description": "The qm kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.QM_KIND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.QM_KIND"
      ]
    }, {
      "description": "Additional net charge in extended region relative to core (core charge is  specified in DFT section, as usual for a convetional QM/MM calculation)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.EXTENDED_DELTA_CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Maximum number of QM atoms, for detection of runaway adaptive selection.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.MAX_N_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Region to apply correction force to for momentum conservation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.MOMENTUM_CONSERVATION_REGION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "How to apply force to get momentum conservation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.MOMENTUM_CONSERVATION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Makes the extended QM zone be defined hysterestically  by distance from QM core list (i.e. atoms specified explicitly by  user) instead of from full QM core region (specified by user + hysteretic  selection + unbreakable bonds)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_EXTENDED_SEED_IS_ONLY_CORE_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Mapping from elements to QM_KINDs for adaptively included atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_KIND_ELEMENT_MAPPING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "The indexes of the mm atoms that have this kind. This keyword can be repeated several times (useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE.QM_KIND.MM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE.QM_KIND"
      ]
    }, {
      "description": "The qm kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE.QM_KIND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE.QM_KIND"
      ]
    }, {
      "description": "Specify the inner and outer radii of buffer region.  All atoms within this distance (hysteretically) of any QM atoms  will be buffer atoms in the force-mixing calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.R_BUF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Specify the inner and outer radii of core QM region.  All molecules with any atoms within this distance (hysteretically) of any atoms  specified as QM in enclosing QM/MM section  will be core QM atoms in the force-mixing calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.R_CORE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Specify the inner and outer radii of QM dynamics region.  All molecules with atoms within this distance (hysteretically) of any atoms in  core will follow QM dynamics in the force-mixing calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.R_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Indices of atoms in previous step QM regions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.RESTART_INFO.INDICES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.RESTART_INFO"
      ]
    }, {
      "description": "Labels of atoms in previous step QM regions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.RESTART_INFO.LABELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.RESTART_INFO"
      ]
    }, {
      "description": "Enables force-mixing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCE_MIXING.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Enables the possibility to define NONBONDED and NONBONDED14 as a sum of different kinds of potential. Useful for piecewise defined potentials.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.MULTIPLE_POTENTIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD"
      ]
    }, {
      "description": "Defines the atomic kind involved in the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Specifies the functional form in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the cutoff parameter of the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the variable of the functional form.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the DC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.DC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the D parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the MC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.MC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the M parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the VR0 parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN.VR0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the EPSILON parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the cutoff parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the SIGMA parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the A parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the B parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the C parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS"
      ]
    }, {
      "description": "Defines the atomic kind involved in the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Specifies the functional form in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the cutoff parameter of the generic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the variable of the functional form.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the DC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.DC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the D parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the MC parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.MC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the M parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the VR0 parameter of the Goodwin potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN.VR0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the EPSILON parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the cutoff parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the SIGMA parameter of the LJ potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES"
      ]
    }, {
      "description": "Defines the atomic kind involved in the nonbond potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the A parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the B parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the C parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the cutoff parameter of the Williams potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the upper bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Defines the lower bound of the potential. If not set the range is the full range generate by the spline",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS.RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS"
      ]
    }, {
      "description": "Specifies how the coefficients are determined.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.IMAGE_CHARGE.DETERM_COEFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE"
      ]
    }, {
      "description": "External potential applied to the metal electrode",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.IMAGE_CHARGE.EXT_POTENTIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE"
      ]
    }, {
      "description": "File name where to read the image matrix used as preconditioner in the iterative scheme",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.IMAGE_CHARGE.IMAGE_RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE"
      ]
    }, {
      "description": "List of MM atoms carrying an induced Gaussian charge. If this keyword is not given, all MM atoms will carry an image charge.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.IMAGE_CHARGE.MM_ATOM_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE"
      ]
    }, {
      "description": "Restart the image matrix. Useful when calculating coefficients iteratively (the image matrix is used as preconditioner in that case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.IMAGE_CHARGE.RESTART_IMAGE_MATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE"
      ]
    }, {
      "description": "Specifies the value of the width of the (induced) Gaussian charge distribution carried by each MM atom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.IMAGE_CHARGE.WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE"
      ]
    }, {
      "description": "This keyword specify the initial translation vector to be applied to the system.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INITIAL_TRANSLATION_VECTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "the interpolator to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "if a non unrolled calculation is to be performed in parallel",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.SAFE_COMPUTATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS"
      ]
    }, {
      "description": "Specifies the scaling factor that defines the movement along the defined direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the first atom defining the direction along which the atom will be added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE.ATOM_INDEX_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the second atom defining the direction along which  the atom will be added",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE.ATOM_INDEX_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the charge for the added source of QM/MM potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the correction radius used for the QM/MM electrostatic coupling for the added source",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the radius used for the QM/MM electrostatic coupling for the added source",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the scaling factor to be used for projecting the forces on the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of the link. A good guess can be derived from the bond distances of the forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.ALPHA_IMOMM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Overwrite the specification of the correction radius only for the MM atom involved in the link.Default is to use the same correction radius as for the specified type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword modifies the MM charge in FIST. The modified charge will be used then also for the generation of the QM/MM potential. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.FIST_SCALE_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the method to use to treat the defined QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.LINK_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the index of the MM atom involved in the QM/MM link, Default hydrogen.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.MM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor that defines the movement along the defined direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the MM atom involved in the QM/MM link to be moved",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE.ATOM_INDEX_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the second atom defining the direction along which  the atom will be moved",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE.ATOM_INDEX_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the correction radius used for the QM/MM electrostatic coupling after movement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the radius used for the QM/MM electrostatic coupling after movement",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE"
      ]
    }, {
      "description": "Specifies the index of the QM atom involved in the QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.QM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the element of the QM capping atom involved in the QM/MM link",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.QM_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword affects only the QM/MM potential, it doesn't affect the electrostatic in  the classical part of the code. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.QMMM_SCALE_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Overwrite the specification of the radius only for the MM atom involved in the link.Default is to use the same radius as for the specified type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.LINK.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specifies the correction radius of the atomic kinds The correction radius is connected to the use of the compatibility keyword.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.MM_KIND.CORR_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.MM_KIND"
      ]
    }, {
      "description": "Specifies the radius of the atomic kinds",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.MM_KIND.RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.MM_KIND"
      ]
    }, {
      "description": "The MM  kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.MM_KIND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.MM_KIND"
      ]
    }, {
      "description": "Name of the file containing the potential expansion in gaussians. See the USE_GEEP_LIB keyword.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.MM_POTENTIAL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "This keyword disables the compatibility of QM/MM potential between CPMD and CP2K implementations. The compatibility is achieved using an MM potential of the form: Erf[x/rc]/x + (1/rc -2/(pi^1/2*rc))*Exp[-(x/rc)^2] .This keyword has effect only selecting GAUSS E_COUPLING type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.NOCOMPATIBILITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Chooses the parallel_scheme for the long range Potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PARALLEL_SCHEME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE"
      ]
    }, {
      "description": "Specifies the maximum value of G in the reciprocal space over which perform the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.GMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR"
      ]
    }, {
      "description": "Evaluates the Gterm in the Ewald Scheme analytically instead of using Splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.ANALYTICAL_GTERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Precision achieved in the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.EWALD_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "Specifies the number of grid points used for the Interpolation of the G-space term",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.NGRIDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Real space cutoff for the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "Defines the usage of the multipole section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "Specifies the number of grid points used for the Interpolation of the G-space term",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.NGRIDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "alpha parameter associated with Ewald (EWALD|PME|SPME). Recommended for small systems is is alpha = 3.5 / r_cut. Tuning alpha, r_cut and gmax is needed to obtain O(N**1.5) scaling for ewald.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "tolerance of gaussians for fft interpolation (PME only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.EPSILON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "Expected accuracy in the Ewald sum. This number affects only the calculation of the cutoff for the real-space term of the ewald summation (EWALD|PME|SPME) as well as the construction of the neighbor lists (if the cutoff for non-bonded terms is smaller than the value employed to compute the EWALD real-space term). This keyword has no effect on the reciprocal space term (which can be tuned independently).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.EWALD_ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "The type of ewald you want to perform.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.EWALD_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "number of grid points (SPME and EWALD). If a single number is specified,the same number of points is used for all three directions on the grid.If three numbers are given, each direction can have a different number of points.The number of points needs to be FFTable (which depends on the library used) and odd for EWALD.The optimal number depends e.g. on alpha and the size of the cell. 1 point per Angstrom is common.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.GMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "Specify the rmsd threshold for the derivatives of the energy towards the Cartesian dipoles components",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES.EPS_POL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the maximum number of iterations for induced dipoles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES.MAX_IPOL_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the maximum level of multipoles expansion used  for the electrostatics.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES.MAX_MULTIPOLE_EXPANSION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Specify the method to obtain self consistent induced multipole moments.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES.POL_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "Controls the activation of the Multipoles",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES"
      ]
    }, {
      "description": "number of grid points on small mesh (PME only), should be odd.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.NS_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "order of the beta-Euler spline (SPME only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.O_SPLINE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "Explicitly provide the real-space cutoff of the ewald summation (EWALD|PME|SPME). If present, overwrites the estimate of EWALD_ACCURACY and may affect the construction of the neighbor lists for non-bonded terms (in FIST), if the value specified is larger than the cutoff for non-bonded interactions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "Specifies the number of slices in the x, y and z directions.-1 specifies that any number of slices is OK.If a given distribution can not be satisfied, a replicated grid will result.Also see LOCK_DISTRIBUTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID.DISTRIBUTION_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Parallelization strategy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID.DISTRIBUTION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Can be used to reduce the halo of the distributed grid (experimental features).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID.HALO_REDUCTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Expert use only, only basic QS deals correctly with a non-default value.If the distribution is locked, a grid will have the same distribution asthe next finer multigrid (provided it is distributed).If unlocked, all grids can be distributed freely.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID.LOCK_DISTRIBUTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "If the multigrid-level of a grid is larger than the parameter, it will not be distributed in the automatic scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID.MAX_DISTRIBUTED_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "A grid will only be distributed if the memory usage for that grid (including halo) is smaller than a replicated grid by this parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID.MEMORY_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID"
      ]
    }, {
      "description": "Convergence parameter ALPHA*RMIN. Default value 7.0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MT.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MT"
      ]
    }, {
      "description": "Specify the multiplicative factor for the CUTOFF keyword in MULTI_GRID  section. The result gives the cutoff at which the 1/r non-periodic FFT3D is evaluated.Default is 2.0",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MT.REL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MT"
      ]
    }, {
      "description": "Evaluates the Gterm in the Ewald Scheme analytically instead of using Splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.ANALYTICAL_GTERM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE"
      ]
    }, {
      "description": "Precision achieved in the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.EWALD_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "the approximate inverse to use to get the starting point for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.AINT_PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO"
      ]
    }, {
      "description": "accuracy on the residual for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.EPS_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "accuracy on the solution for spline3 the interpolators",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.EPS_X",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "the maximum number of iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "The preconditioner used for the linear solver of the spline3 methods",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.PRECOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "Specifies the number of grid points used for the Interpolation of the G-space term",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.NGRIDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Real space cutoff for the Ewald sum.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "Specify the directions on wich apply PBC. Important notice,  this only applies to the electrostatics. See the CELL section to specify the periodicity used for e.g. the pair lists. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON"
      ]
    }, {
      "description": "Specify which kind of solver to use to solve the Poisson equation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.POISSON_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON"
      ]
    }, {
      "description": "Type of scaling function used in the wavelet approach, the total energy depends on this choice,and the convergence with respect to cutoff depends on the selected scaling functions.Possible values are 8,14,16,20,24,30,40,50,60,100",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.WAVELET.SCF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.WAVELET"
      ]
    }, {
      "description": "Specifies the number of replica to take into consideration for the real part of the calculation. Default is letting the qmmm module decide how many replica you really need.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.PERIODIC.REPLICA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "The indexes of the mm atoms that have this kind. This keyword can be repeated several times (useful if you have to specify many indexes).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.QM_KIND.MM_INDEX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.QM_KIND"
      ]
    }, {
      "description": "The qm kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.QM_KIND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.QM_KIND"
      ]
    }, {
      "description": "Set the spherical cutoff for the QMMM electrostatic interaction. This acts like a charge multiplicative factor dependent on cutoff. For MM atoms farther than the SPHERICAL_CUTOFF(1) their charge is zero. The switch is performed with a smooth function: 0.5*(1-TANH((r-[SPH_CUT(1)-20*SPH_CUT(2)])/(SPH_CUT(2)))). Two values are required: the first one is the distance cutoff. The second one controls the stiffness of the smoothing.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.SPHERICAL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": " This keyword enables the use of the internal GEEP library to generate the gaussian expansion of the MM potential. Using this keyword there's no need to provide the MM_POTENTIAL_FILENAME. It expects a number from 2 to 15 (the number of gaussian funtions to be used in the expansion.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.USE_GEEP_LIB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Specify the value of the the force constant for the quadratic wall",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.WALLS.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.WALLS"
      ]
    }, {
      "description": "Specifies the type of wall",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.WALLS.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.WALLS"
      ]
    }, {
      "description": "Specify the value of the skin of the Wall in each dimension. The wall's effect is felt when atoms fall within the skin of the Wall.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.QMMM.WALLS.WALL_SKIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.WALLS"
      ]
    }, {
      "description": "Specify the Maximum Values of the force. If the force of one atom exceed this value it's rescaled to the MAX_FORCE value.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.RESCALE_FORCES.MAX_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.RESCALE_FORCES"
      ]
    }, {
      "description": "Controls the calculation of the stress tensor. The combinations defined below are not implemented for all methods.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.STRESS_TENSOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Specify the lengths of the cell vectors A, B, and C, which defines the diagonal elements of h matrix for an orthorhombic cell. For non-orthorhombic cells it is possible either to specify the angles ALPHA, BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the keywords A, B, and C. The convention is that A lies along the X-axis, B is in the XY plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.ABC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specify the angles between the vectors A, B and C when using the ABC keyword. The convention is that A lies along the X-axis, B is in the XY plane. ALPHA is the angle between B and C, BETA is the angle between A and C and GAMMA the angle between A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.ALPHA_BETA_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector A. This defines the first column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector B. This defines the second column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specify the format of the cell file (if used)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Possibility to read the cell from an external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specify the lengths of the cell vectors A, B, and C, which defines the diagonal elements of h matrix for an orthorhombic cell. For non-orthorhombic cells it is possible either to specify the angles ALPHA, BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the keywords A, B, and C. The convention is that A lies along the X-axis, B is in the XY plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.ABC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the angles between the vectors A, B and C when using the ABC keyword. The convention is that A lies along the X-axis, B is in the XY plane. ALPHA is the angle between B and C, BETA is the angle between A and C and GAMMA the angle between A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.ALPHA_BETA_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector A. This defines the first column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector B. This defines the second column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the format of the cell file (if used)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.CELL_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Possibility to read the cell from an external file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector C. This defines the third column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the CELL specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL should be modified in order to affect the coordinates specification.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.MULTIPLE_UNIT_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the directions for which periodic boundary conditions (PBC) will be applied. Important notice: This applies to the generation of the pair lists as well as to the application of the PBCs to positions. See the POISSON section to specify the periodicity used for the electrostatics. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Imposes an initial cell symmetry.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF.SYMMETRY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF"
      ]
    }, {
      "description": "Specify the Cartesian components for the cell vector C. This defines the third column of the h matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the CELL specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL should be modified in order to affect the coordinates specification.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.MULTIPLE_UNIT_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specify the directions for which periodic boundary conditions (PBC) will be applied. Important notice: This applies to the generation of the pair lists as well as to the application of the PBCs to positions. See the POISSON section to specify the periodicity used for the electrostatics. Typically the settings should be the same.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Imposes an initial cell symmetry.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CELL.SYMMETRY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the angle.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of 3 atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specify how the plane is defined: either by 3 atoms or by a fixed normal vector. At least one plane must be defined through atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE.DEF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Alternatively to 3 atoms/points one can define one of the two, planes by defining its NORMAL vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE.NORMAL_VECTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.P1_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.P1_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.P2_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.P2_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Colvar function data. The order is an internal order. So if you decide to edit/modify/add these values by hand you should know very well what you are doing.!",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COLVAR_FUNC_INFO.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COLVAR_FUNC_INFO"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the angle.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of 3 atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specify how the plane is defined: either by 3 atoms or by a fixed normal vector. At least one plane must be defined through atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE.DEF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Alternatively to 3 atoms/points one can define one of the two, planes by defining its NORMAL vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE.NORMAL_VECTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.P1_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.P1_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.P2_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.P2_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Colvar function data. The order is an internal order. So if you decide to edit/modify/add these values by hand you should know very well what you are doing.!",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COLVAR_FUNC_INFO.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COLVAR_FUNC_INFO"
      ]
    }, {
      "description": "Specify indexes of atoms/points from which the distance is computed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.ATOMS_DISTANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify the lambda parameter at the exponent of the conditioned distance function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify indexes of the third set of atoms/points.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.ATOMS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.KINDS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.ND_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.NN_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, specify the R0 parameter in the second coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.R0_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the distance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Define the axes along which the colvar should be evaluated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.AXIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points for the two bonds d1=(1-2) d2=(3-4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the coefficient in the function for the constraint. -1.0 has to be used for distance difference, 1.0 for distance addition",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.COEFFICIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the atom/point index defining the point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.ATOM_POINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.ATOMS_PLANE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specify indexes of atoms/points defyining the gyration radius variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms defining the gyration radius.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.KINDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP"
      ]
    }, {
      "description": "The number of points in the path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.NPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP"
      ]
    }, {
      "description": "Parameter used for shifting each term in the sum",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.HYDROGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the LAMBDA parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the NH parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.OXYGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.PNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.PNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.QNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.QNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.Q",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROH parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.ROH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROO parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.ROO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the n0 parameter that sets the coordination of the species.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.N0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the gaussian width of used to build the population istogram.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the width of the Fermi-Dirac style smearing around RCUT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the L spherical harmonics from Ylm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the distance cutoff for neighbors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the ring.At least 4 Atoms are needed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Indicate the coordinate to be used. Follow the Cremer-Pople definition for a N ring.0 is the total puckering variable Q,2..[N/2] are puckering coordinates.-2..-[N/2-1] are puckering angles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.COORDINATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Whether the reference frames should be aligned to minimize the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify indexes of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Define the subsytem used to compute the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.SUBSET_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify weights of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the torsion.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the functional form of the collective variable in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.ENERGY_FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC"
      ]
    }, {
      "description": "If enabled, the absolute position of the atoms will be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.ABSOLUTE_POSITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the index of the atom/point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.COMPONENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the index of the atoms/points A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom A.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.COMPONENT_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.COMPONENT_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Parameter used for computing the derivative of the combination of COLVARs with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Specifies the function used to combine different COLVARs into one.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Defines the values of  parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Specifies the name of the variable that parametrises the FUNCTION defining how COLVARS should be combined. The matching follows the same order of the COLVARS definition in the input file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Specify indexes of atoms/points from which the distance is computed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.ATOMS_DISTANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify the lambda parameter at the exponent of the conditioned distance function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify indexes of the third set of atoms/points.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.ATOMS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.KINDS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.ND_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.NN_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, specify the R0 parameter in the second coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.R0_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the distance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Define the axes along which the colvar should be evaluated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.AXIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Whether the reference frames should be aligned to minimize the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Specify indexes of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the angle.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of 3 atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specify how the plane is defined: either by 3 atoms or by a fixed normal vector. At least one plane must be defined through atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE.DEF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Alternatively to 3 atoms/points one can define one of the two, planes by defining its NORMAL vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE.NORMAL_VECTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.P1_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.P1_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.P2_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.P2_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Colvar function data. The order is an internal order. So if you decide to edit/modify/add these values by hand you should know very well what you are doing.!",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COLVAR_FUNC_INFO.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COLVAR_FUNC_INFO"
      ]
    }, {
      "description": "Specify indexes of atoms/points from which the distance is computed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.ATOMS_DISTANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify the lambda parameter at the exponent of the conditioned distance function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify indexes of the third set of atoms/points.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.ATOMS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.KINDS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.ND_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.NN_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, specify the R0 parameter in the second coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.R0_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the distance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Define the axes along which the colvar should be evaluated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.AXIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points for the two bonds d1=(1-2) d2=(3-4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the coefficient in the function for the constraint. -1.0 has to be used for distance difference, 1.0 for distance addition",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.COEFFICIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the atom/point index defining the point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.ATOM_POINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.ATOMS_PLANE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specify indexes of atoms/points defyining the gyration radius variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms defining the gyration radius.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.KINDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "The number of points in the path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.NPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Parameter used for shifting each term in the sum",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.HYDROGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the LAMBDA parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the NH parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.OXYGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.PNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.PNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.QNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.QNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.Q",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROH parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.ROH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROO parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.ROO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the n0 parameter that sets the coordination of the species.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.N0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the gaussian width of used to build the population istogram.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the width of the Fermi-Dirac style smearing around RCUT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the L spherical harmonics from Ylm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the distance cutoff for neighbors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the ring.At least 4 Atoms are needed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Indicate the coordinate to be used. Follow the Cremer-Pople definition for a N ring.0 is the total puckering variable Q,2..[N/2] are puckering coordinates.-2..-[N/2-1] are puckering angles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.COORDINATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Whether the reference frames should be aligned to minimize the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify indexes of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Define the subsytem used to compute the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.SUBSET_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify weights of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the torsion.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the functional form of the collective variable in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.ENERGY_FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC"
      ]
    }, {
      "description": "If enabled, the absolute position of the atoms will be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.ABSOLUTE_POSITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the index of the atom/point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.COMPONENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the index of the atoms/points A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom A.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.COMPONENT_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.COMPONENT_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Settings for DISTANCES_RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.DISTANCES_RMSD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME"
      ]
    }, {
      "description": "Specifies the ith element of the vector valued function that defines the reaction path. This keyword needs to repeat exactly Q times, and the order must match the order of the colvars. The VARIABLE (e.g. T) which parametrises the curve can be used as the target of a constraint.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Specifies the exponent of the Gaussian used in the integral representation of the colvar.The shape of the space orthogonal to the reaction path is defined by this choice. In the limit of large values, it is given by the plane orthogonal to the path.In practice, modest values are required for stable numerical integration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": "Distance between two gridpoints for the grid on the COLVAR",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.GRID_SPACING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": "The range of of the grid of the COLVAR.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP"
      ]
    }, {
      "description": "The range of VARIABLE used for the parametrisation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Settings for RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.RMSD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Step size in the numerical integration, a few thousand points are common, and the proper number also depends on LAMBDA.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Define the subsytem used to compute the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.SUBSET_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Specifies the name of the variable that parametrises the FUNCTION defining the reaction path.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.VARIABLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points for the two bonds d1=(1-2) d2=(3-4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the coefficient in the function for the constraint. -1.0 has to be used for distance difference, 1.0 for distance addition",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.COEFFICIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the atom/point index defining the point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.ATOM_POINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.ATOMS_PLANE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specify indexes of atoms/points defyining the gyration radius variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms defining the gyration radius.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.KINDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP"
      ]
    }, {
      "description": "The number of points in the path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.NPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP"
      ]
    }, {
      "description": "Parameter used for shifting each term in the sum",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.HYDROGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the LAMBDA parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the NH parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.OXYGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.PNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.PNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.QNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.QNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.Q",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROH parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.ROH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROO parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.ROO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the n0 parameter that sets the coordination of the species.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.N0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the gaussian width of used to build the population istogram.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the width of the Fermi-Dirac style smearing around RCUT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the L spherical harmonics from Ylm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the distance cutoff for neighbors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM"
      ]
    }, {
      "description": "Whether the reference frames should be aligned to minimize the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Specify indexes of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the angle.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of 3 atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specify how the plane is defined: either by 3 atoms or by a fixed normal vector. At least one plane must be defined through atoms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE.DEF_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Alternatively to 3 atoms/points one can define one of the two, planes by defining its NORMAL vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE.NORMAL_VECTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.P1_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the first pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.P1_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the first bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.P2_BOND1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the index of atom/point defining the second pointof the second bond/line.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.P2_BOND2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT"
      ]
    }, {
      "description": "Colvar function data. The order is an internal order. So if you decide to edit/modify/add these values by hand you should know very well what you are doing.!",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COLVAR_FUNC_INFO.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COLVAR_FUNC_INFO"
      ]
    }, {
      "description": "Specify indexes of atoms/points from which the distance is computed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.ATOMS_DISTANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify the lambda parameter at the exponent of the conditioned distance function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify indexes of the third set of atoms/points.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.ATOMS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, here specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.KINDS_TO_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.ND_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers,Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.NN_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT"
      ]
    }, {
      "description": "For the CV given by the multiplication of two coorination numbers, specify the R0 parameter in the second coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.R0_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the distance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Define the axes along which the colvar should be evaluated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.AXIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points for the two bonds d1=(1-2) d2=(3-4).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the coefficient in the function for the constraint. -1.0 has to be used for distance difference, 1.0 for distance addition",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.COEFFICIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT"
      ]
    }, {
      "description": "Specifies the atom/point index defining the point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.ATOM_POINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the plane.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.ATOMS_PLANE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT"
      ]
    }, {
      "description": "Specify indexes of atoms/points defyining the gyration radius variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms defining the gyration radius.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.KINDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "The number of points in the path",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.NPOINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Parameter used for shifting each term in the sum",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.SHIFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.HYDROGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the LAMBDA parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the NH parameter in the hydronium function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.OXYGENS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.PNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.PNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.QNH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.QNO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.Q",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROH parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.ROH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify the ROO parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.ROO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.KINDS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify alternatively kinds of atoms building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.KINDS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the n0 parameter that sets the coordination of the species.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.N0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the denominator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.ND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Sets the value of the numerator of the exponential factorin the coordination FUNCTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.NN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT"
      ]
    }, {
      "description": "Specify the R0 parameter in the coordination function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.R0",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specify the gaussian width of used to build the population istogram.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Specifies the width of the Fermi-Dirac style smearing around RCUT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.ATOMS_FROM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specify indexes of atoms/points building the coordination variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.ATOMS_TO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the L spherical harmonics from Ylm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT"
      ]
    }, {
      "description": "Specifies the distance cutoff for neighbors.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the ring.At least 4 Atoms are needed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Indicate the coordinate to be used. Follow the Cremer-Pople definition for a N ring.0 is the total puckering variable Q,2..[N/2] are puckering coordinates.-2..-[N/2-1] are puckering angles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.COORDINATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Whether the reference frames should be aligned to minimize the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify indexes of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Define the subsytem used to compute the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.SUBSET_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify weights of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the torsion.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the functional form of the collective variable in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.ENERGY_FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC"
      ]
    }, {
      "description": "If enabled, the absolute position of the atoms will be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.ABSOLUTE_POSITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the index of the atom/point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.COMPONENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the index of the atoms/points A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom A.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.COMPONENT_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.COMPONENT_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Settings for DISTANCES_RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.DISTANCES_RMSD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME"
      ]
    }, {
      "description": "Specifies the ith element of the vector valued function that defines the reaction path. This keyword needs to repeat exactly Q times, and the order must match the order of the colvars. The VARIABLE (e.g. T) which parametrises the curve can be used as the target of a constraint.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Specifies the exponent of the Gaussian used in the integral representation of the colvar.The shape of the space orthogonal to the reaction path is defined by this choice. In the limit of large values, it is given by the plane orthogonal to the path.In practice, modest values are required for stable numerical integration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": "Distance between two gridpoints for the grid on the COLVAR",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.GRID_SPACING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": "The range of of the grid of the COLVAR.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP"
      ]
    }, {
      "description": "The range of VARIABLE used for the parametrisation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Settings for RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.RMSD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Step size in the numerical integration, a few thousand points are common, and the proper number also depends on LAMBDA.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Define the subsytem used to compute the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.SUBSET_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Specifies the name of the variable that parametrises the FUNCTION defining the reaction path.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.VARIABLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the ring.At least 4 Atoms are needed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Indicate the coordinate to be used. Follow the Cremer-Pople definition for a N ring.0 is the total puckering variable Q,2..[N/2] are puckering coordinates.-2..-[N/2-1] are puckering angles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.COORDINATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT"
      ]
    }, {
      "description": "Whether the reference frames should be aligned to minimize the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify indexes of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Define the subsytem used to compute the RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.SUBSET_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD"
      ]
    }, {
      "description": "Specify weights of atoms building the subset.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the torsion.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT"
      ]
    }, {
      "description": "Parameter used for computing the derivative with the Ridders method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the functional form of the collective variable in mathematical notation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.ENERGY_FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.ERROR_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the parameters of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.UNITS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the values of parameter of the functional form",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.VALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED.VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED"
      ]
    }, {
      "description": "Specifies the indexes of atoms/points defining the bond (Od, H, Oa).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.WC.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT"
      ]
    }, {
      "description": "Parameter used for computing the cutoff radius for searching the wannier centres around an atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.WC.RCUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC"
      ]
    }, {
      "description": "If enabled, the absolute position of the atoms will be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.ABSOLUTE_POSITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the index of the atom/point.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.COMPONENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT"
      ]
    }, {
      "description": "Specifies the index of the atoms/points A and B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom A.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.COMPONENT_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Define the component of the position vector which will be used as a colvar for atom B.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.COMPONENT_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.PBC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Specifies the indexes of atoms defining the geometrical center",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Chooses the type of geometrical point",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT.WEIGHTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "Specifies the xyz of the fixed point (if the case)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT.XYZ",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT"
      ]
    }, {
      "description": "The atomic coordinates in the format:<p><tt>ATOMIC_KIND  X Y Z  MOLNAME</tt></p>The <tt>MOLNAME</tt> is optional. If not provided the molecule name is internally created. All other fields after <tt>MOLNAME</tt> are simply ignored.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COORD"
      ]
    }, {
      "description": "Specify if the coordinateds in input are scaled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COORD.SCALED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COORD"
      ]
    }, {
      "description": "Specify the unit of measurement for the coordinates in inputAll available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.COORD.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COORD"
      ]
    }, {
      "description": "The core particle coordinates in the format:<p><tt>ATOMIC_KIND  X Y Z  ATOMIC_INDEX</tt></p>The <tt>ATOMIC_INDEX</tt> refers to the atom the core particle belongs to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CORE_COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CORE_COORD"
      ]
    }, {
      "description": "Specify if the coordinateds in input are scaled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CORE_COORD.SCALED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CORE_COORD"
      ]
    }, {
      "description": "Specify the unit of measurement for the coordinates in inputAll available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CORE_COORD.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CORE_COORD"
      ]
    }, {
      "description": "The core particle velocities in the format:<p><tt><big>v<sub>x</sub> v<sub>y</sub> v<sub>z</sub></big></tt></p>The same order as for the core particle coordinates is assumed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.CORE_VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CORE_VELOCITY"
      ]
    }, {
      "description": "The polarizability for scalar-isotropic polarization using SCP with FIST as the driver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.ALPHA_SCP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The normalization of the basis set for auxiliary density matrix method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.AUX_BASIS_FIT_NORMALIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The normalization of the auxliliary basis set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.AUX_BASIS_NORMALIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The auxliliary basis set (GTO type)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.AUX_BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The auxliliary basis set (GTO type) for auxiliary density matrix method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.AUX_FIT_BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "<u>CP2K Basis Set Standard Format</u>\n<pre>\nElement symbol  Name of the basis set  Alias names\nnset (repeat the following block of lines nset times)\nn lmin lmax nexp nshell(lmin) nshell(lmin+1) ... nshell(lmax-1) nshell(lmax)\na(1)      c(1,l,1)      c(1,l,2) ...      c(1,l,nshell(l)-1)      c(1,l,nshell(l)), l=lmin,lmax\na(2)      c(2,l,1)      c(2,l,2) ...      c(2,l,nshell(l)-1)      c(2,l,nshell(l)), l=lmin,lmax\n .         .             .                 .                       .\n .         .             .                 .                       .\n .         .             .                 .                       .\na(nexp-1) c(nexp-1,l,1) c(nexp-1,l,2) ... c(nexp-1,l,nshell(l)-1) c(nexp-1,l,nshell(l)), l=lmin,lmax\na(nexp)   c(nexp,l,1)   c(nexp,l,2)   ... c(nexp,l,nshell(l)-1)   c(nexp,l,nshell(l)), l=lmin,lmax\n\n\nnset     : Number of exponent sets\nn        : Principle quantum number (only for orbital label printing)\nlmax     : Maximum angular momentum quantum number l\nlmin     : Minimum angular momentum quantum number l\nnshell(l): Number of shells for angular momentum quantum number l\na        : Exponent\nc        : Contraction coefficient\n</pre>\nSource: ftp://ftp.aip.org/epaps/journ_chem_phys/E-JCPSA6-127-308733/BASIS_MOLOPT_JCP.txt",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BASIS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BASIS"
      ]
    }, {
      "description": "The normalization of the auxliliary basis set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BASIS_NORMALIZATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The primary Gaussian basis set (NONE implies no basis used, meaningful with GHOST)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Angular momentum quantum number of theorbitals whose occupation is changed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA"
      ]
    }, {
      "description": "Orbital ccupation change per angular momentum quantum number.In unrestricted calculations applied to spin alpha.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA.NEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA"
      ]
    }, {
      "description": "Principal quantum number of theorbitals whose occupation is changed. Default is the first not occupied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA.N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA"
      ]
    }, {
      "description": "Angular momentum quantum number of theorbitals of beta spin whose occupation is changed.Active only for unrestricted calculations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA"
      ]
    }, {
      "description": "Orbital ccupation change per angular momentum quantum number.Applied to spin beta and active only in unrestricted calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA.NEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA"
      ]
    }, {
      "description": "Principal quantum number of theorbitals of beta spin whose occupation is changed. Default is the first not occupied.Active only for unrestricted calculations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA.N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA"
      ]
    }, {
      "description": "controls the activation of the BS section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.BS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS"
      ]
    }, {
      "description": "Corrects the effective nuclear charge",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.CORE_CORRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The occupation constraint is enforced until this threshold value for the SCF convergence criterion is reached",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION.EPS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION"
      ]
    }, {
      "description": "The occupation constraint is applied for this number of initial SCF iterations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION.MAX_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION"
      ]
    }, {
      "description": "Select orbitals and occupation order. An input of 1 to 2*L+1 integer values in the range -L to L defining the M values of the spherical orbitals is expected.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION.ORBITALS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION"
      ]
    }, {
      "description": "Controls the activation of the ENFORCE_OCCUPATION section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION"
      ]
    }, {
      "description": "The occupation constraint is applied with smearing",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION.SMEAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION"
      ]
    }, {
      "description": "Threshold value (SCF convergence) for incrementing the effective U value when U ramping is active.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.EPS_U_RAMPING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "Set the initial U ramping value to zero before each wavefunction optimisation. The default is to apply U ramping only for the initial wavefunction optimisation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.INIT_U_RAMPING_EACH_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "Angular momentum quantum number of theorbitals to which the correction is applied",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.L",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "Controls the activation of the DFT+U section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "Effective parameter U(eff) = U - J",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.U_MINUS_J",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "Increase the effective U parameter stepwise using the specified increment until the target value given by U_MINUS_J is reached.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.U_RAMPING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "The third order parameter (derivative of hardness) used in diagonal DFTB3 correction.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.DFTB3_PARAM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Specifies the electronic configration used in construction the atomic initial guess (see the pseudo potential file for the default values.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.ELEC_CONF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The element of the actual kind (if not given it is inferred from the kind name)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.ELEMENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "CP2K Basis Set Standard Format",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.GEMINAL.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.GEMINAL"
      ]
    }, {
      "description": "The Geminal Gaussian basis set to be used in HF exchange fitting",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.GEMINAL_BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "This keyword makes all atoms of this kind ghost atoms, i.e. without pseudo or nuclear charge.Useful to just have the basis set at that position (BSSE calculations),or to have a non-interacting particle with BASIS_SET NONE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.GHOST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Force one type to be treated by the GPW scheme, whatever are its primitives, even if the GAPW method is used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.GPW_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The region where the hard density is supposed to be confined(GAPW)(in Bohr, default is 1.2 for H and 1.512 otherwise)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.HARD_EXP_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The dispersion parameter for scalar-isotropic polarization using SCP with FIST as the driver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.I_SCP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "CP2K KG TNADD Potential Standard Format (TNADD)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.KG_POTENTIAL.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.KG_POTENTIAL"
      ]
    }, {
      "description": "The name of the non-additive atomic kinetic energy potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.KG_POTENTIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The number of points for the angular part of the local grid (GAPW)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.LEBEDEV_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The local resolution of identity basis set (GTO type)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.LRI_BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The mass of the atom (if negative or non present it is inferred from the element symbol)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.MASS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Max radius for the basis functions used to generate the local projectors in GAPW [Bohr]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.MAX_RAD_LOCAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Defines the radius of the electrostatic multipole of the atom in Fist. This radius applies to the charge, the dipole and the quadrupole. When zero, the atom is treated as a point multipole, otherwise it is treated as a Gaussian charge distribution with the given radius: p(x,y,z)*N*exp(-(x**2+y**2+z**2)/(2*MM_RADIUS**2)), where N is a normalization constant. In the core-shell model, only the shell is treated as a Gaussian and the core is always a point charge.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.MM_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Skip optimization of this type (used in specific basis set or potential optimization schemes",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.NO_OPTIMIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "CP2K Pseudo Potential Standard Format (GTH, ALL)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.POTENTIAL.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.POTENTIAL"
      ]
    }, {
      "description": "The name of the pseudopotential for the defined kind.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.POTENTIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The number of points for the radial part of the local grid (GAPW)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.RADIAL_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "the radius which defines the atomic region where the hard compensation density is confined.should be less than HARD_EXP_RADIUS (GAPW)(Bohr, default equals HARD_EXP_RADIUS)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.RHO0_EXP_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The RI auxliliary basis set used in WF_CORRELATION (GTO type)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.RI_AUX_BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Forces the usage of p-orbitals on H for SEMI-EMPIRICAL calculations.  This keyword applies only when the KIND is specifying an Hydrogen element. In all  other cases is simply ignored.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.SE_P_ORBITALS_ON_H",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The name of the kind described in this section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.KIND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The dipole components for each atom in the format:<p><tt><big>D<sub>x</sub> D<sub>y</sub> D<sub>z</sub></big></tt></p>",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.MULTIPOLES.DIPOLES.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES.DIPOLES"
      ]
    }, {
      "description": "The quadrupole components for each atom in the format:<p><big><tt>Q<sub>xx</sub> Q<sub>xy</sub> Q<sub>xz</sub> Q<sub>yy</sub> Q<sub>yz</sub> Q<sub>zz</sub></big></tt></p>",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.MULTIPOLES.QUADRUPOLES.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES.QUADRUPOLES"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.RNG_INIT"
      ]
    }, {
      "description": "The shell particle coordinates in the format:<p><tt>ATOMIC_KIND  X Y Z  ATOMIC_INDEX</tt></p>The <tt>ATOMIC_INDEX</tt> refers to the atom the shell particle belongs to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.SHELL_COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.SHELL_COORD"
      ]
    }, {
      "description": "Specify if the coordinateds in input are scaled.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.SHELL_COORD.SCALED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.SHELL_COORD"
      ]
    }, {
      "description": "Specify the unit of measurement for the coordinates in inputAll available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.SHELL_COORD.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.SHELL_COORD"
      ]
    }, {
      "description": "The shell particle velocities in the format:<p><tt><big>v<sub>x</sub> v<sub>y</sub> v<sub>z</sub></big></tt></p>The same order as for the shell particle coordinates is assumed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.SHELL_VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.SHELL_VELOCITY"
      ]
    }, {
      "description": "When True, the exclude lists are solely based on the bond data in the topology. The (minimal) number of bonds between two atoms is used to determine if the atom pair is added to an exclusion list. When False, 1-2 exclusion is based on bonds in the topology, 1-3 exclusion is based on bonds and bends in the topology, 1-4 exclusion is based on bonds, bends and dihedrals in the topology. This implies that a missing dihedral in the topology will cause the corresponding 1-4 pair not to be in the exclusion list, in case 1-4 exclusion is requested for VDW or EI interactions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.AUTOGEN_EXCLUDE_LISTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Specify the point used for centering the coordinates. Default is to center the system in cell/2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CENTER_COORDINATES.CENTER_POINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CENTER_COORDINATES"
      ]
    }, {
      "description": "Controls the activation of the centering method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CENTER_COORDINATES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CENTER_COORDINATES"
      ]
    }, {
      "description": "Read MM charges from the BETA field of PDB file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CHARGE_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Read MM charges from the very last field of PDB file (starting from column 81). No limitations of number of digits.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CHARGE_EXTENDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Read MM charges from the OCCUP field of PDB file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CHARGE_OCCUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Ways to determine and generate a molecules. Default is to use GENERATE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CONN_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Specifies the filename that contains the molecular connectivity.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CONN_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Set up the way in which coordinates will be read.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.COORD_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Specifies the filename that contains coordinates.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Do not build any exclusion lists.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DISABLE_EXCLUSION_LISTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "Write the MM charges to the BETA field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.CHARGE_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "Write the MM charges to the very last field of the PDB file (starting from column 81)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.CHARGE_EXTENDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "Write the MM charges to the OCCUP field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.CHARGE_OCCUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF"
      ]
    }, {
      "description": "Specify the atom kinds involved in the bond for which 1-2 exclusion holds.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_EI_LIST.BOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_EI_LIST"
      ]
    }, {
      "description": "Specifies which kind of Electrostatic interaction to skip.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_EI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Specify the atom kinds involved in the bond for which 1-2 exclusion holds.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_VDW_LIST.BOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_VDW_LIST"
      ]
    }, {
      "description": "Specifies which kind of Van der Waals interaction to skip.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_VDW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Specifies two atomic index united by a covalent bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ANGLE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ANGLE"
      ]
    }, {
      "description": "controls the activation of the bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ANGLE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ANGLE"
      ]
    }, {
      "description": "Specifies two atomic index united by a covalent bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BOND.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BOND"
      ]
    }, {
      "description": "controls the activation of the bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BOND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BOND"
      ]
    }, {
      "description": "Maximum distance to generate neighbor lists to build connectivity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BONDLENGTH_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Minimum distance to generate neighbor lists to build connectivity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BONDLENGTH_MIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Used in conjunction with BONDPARM to help determine wheather there is bonding between two atoms based on a distance criteria.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BONDPARM_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Used in conjunction with BONDPARM_FACTOR to help determine wheather there is bonding between two atoms based on a distance criteria. Can use covalent radii information or VDW radii information",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BONDPARM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Create molecules names and definition. Can be used to override the  molecules specifications of a possible input connectivity or to create molecules specifications for file types as XYZ, missing of molecules definitions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.CREATE_MOLECULES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Specifies two atomic index united by a covalent bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.IMPROPER.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.IMPROPER"
      ]
    }, {
      "description": "controls the activation of the bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.IMPROPER.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.IMPROPER"
      ]
    }, {
      "description": "Specifies a list of atomic indexes of the isolated ion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ISOLATED_ATOMS.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ISOLATED_ATOMS"
      ]
    }, {
      "description": "This keyword enables the check that two atoms are never below the minimum value used to construct the splines during the construction of the neighbouring list. Disabling this keyword avoids CP2K to abort in case two atoms are below the minimum  value of the radius used to generate the splines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS.GEO_CHECK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "This keyword enables the building of the neighbouring list from scratch.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS.NEIGHBOR_LISTS_FROM_SCRATCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "Defines the Verlet Skin for the generation of the neighbor lists",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS.VERLET_SKIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS"
      ]
    }, {
      "description": "Reorder a list of atomic coordinates into order so it can be packed correctly.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.REORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Specifies two atomic index united by a covalent bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.TORSION.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.TORSION"
      ]
    }, {
      "description": "controls the activation of the bond",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.TORSION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.TORSION"
      ]
    }, {
      "description": "This keyword is quite technical and should normally not be changed by the user. It affects the memory allocation during the construction of the topology. It does NOT affect the memory used once the topology is built.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MEMORY_PROGRESSION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Check molecules have the same number of atom and names.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_CHECK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Three integer indexes per line defining the new angle Indexes must be relative to the full system and not to the single molecules",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.ANGLES.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.ANGLES"
      ]
    }, {
      "description": "Two integer indexes per line defining the new bond. Indexes must be relative to the full system and not to the single molecules",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.BONDS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.BONDS"
      ]
    }, {
      "description": "Four integer indexes per line defining the new improper Indexes must be relative to the full system and not to the single molecules",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.IMPROPERS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.IMPROPERS"
      ]
    }, {
      "description": "Four integer indexes per line defining the new torsion Indexes must be relative to the full system and not to the single molecules",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.TORSIONS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.TORSIONS"
      ]
    }, {
      "description": "Ways to determine and generate a molecules. Default is to use GENERATE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE.CONN_FILE_FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE"
      ]
    }, {
      "description": "Specifies the filename that contains the molecular connectivity.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE.CONN_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE"
      ]
    }, {
      "description": "number of molecules",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE.NMOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE"
      ]
    }, {
      "description": "Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the coordinates specification. The same keyword in SUBSYS%CELL%MULTIPLE_UNIT_CELL should be modified in order to affect the cell specification.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MULTIPLE_UNIT_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Optionally define the number of atoms read from an external file (see COORD_FILE_NAME) if the COORD_FILE_FORMAT CP2K is used",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.NUMBER_OF_ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "For a protein, each residue is now considered a molecule",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.PARA_RES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Use the velocities in the G96 coordinate files as the starting velocity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.TOPOLOGY.USE_G96_VELOCITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "The atomic velocities in the format:<p><tt><big>v<sub>x</sub> v<sub>y</sub> v<sub>z</sub></big></tt></p>The same order as for the atomic coordinates is assumed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.VELOCITY"
      ]
    }, {
      "description": "Specify the units of measurement for the velocities (currently works only for the path integral code). All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_FORCE_EVAL.SUBSYS.VELOCITY.PINT_UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.VELOCITY"
      ]
    }, {
      "description": "All-to-all communication (FFT) should use single precision",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.ALLTOALL_SGL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "how to distribute the processors on the 2d grid needed by BLACS (and thus SCALAPACK)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.BLACS_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Use a topology for BLACS collectives that is guaranteed to be repeatable on homegeneous architectures",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.BLACS_REPEATABLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Name of the callgraph file, which is writte a the end of the run. If not specified the project name will be used as filename.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.CALLGRAPH_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "At the end of the run write a callgraph to file, which contains detailed timing informations. This callgraph can be viewed e.g. with the open-source program kcachegrind.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.CALLGRAPH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "If enabled, stacks are not processed by the acc-driver after it has signaled congestion during a round of flushing. For the next round of flusing the driver is used again.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.AVOID_AFTER_BUSY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Size of bins used when ordering the stacks with the binning-scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.BINNING_BINSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Number of bins used when ordering the stacks with the binning-scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.BINNING_NBINS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Only process stacks with more than the given number of floating-point operations per stack-entry (2*m*n*k).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.MIN_FLOP_PROCESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Only sort stacks with more than the given number of floating-point operations per stack-entry (2*m*n*k). Alternatively, the stacks are roughly ordered through a binning-scheme by Peter Messmer.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.MIN_FLOP_SORT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Number of transfer-buffers associated with low priority streams.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.POSTERIOR_BUFFERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Number of acc streams created with low priority.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.POSTERIOR_STREAMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Number of transfer-buffers associated with high priority streams.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.PRIORITY_BUFFERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Number of acc streams created with high priority.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.PRIORITY_STREAMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "If enabled, inhomogenous stacks are also processed by the acc driver.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.ACC.PROCESS_INHOMOGENOUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR.ACC"
      ]
    }, {
      "description": "Combine matrix index and data into a single MPI derived data type for communication (avoid using).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.COMBINED_TYPES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "If a communications thread is used, specify how much multiplication workload (%) the thread should perform in addition to communication tasks. A negative value leaves the decision up to DBCSR.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.COMM_THREAD_LOAD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Default block size for turning dense matrices in blocked ones",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.MAX_ELEMENTS_PER_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Select which routines to use for matrix block multiplications.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.MM_DRIVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Size of multiplication parameter stack. A negative value leaves the decision up to DBCSR.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.MM_STACK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Recursion limit of cache oblivious multrec algorithm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.MULTREC_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Number of stacks to use for distinct atomic sizes (e.g., 2 for a system of mostly waters). A negative value leaves the decision up to DBCSR.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.N_SIZE_MNK_STACKS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Use MPI subcommunicators for transfers that are limited to process grid rows and columns.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.SUBCOMMUNICATORS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "During multiplication, use a thread to periodically poll MPI to progress outstanding message completions.  This is beneficial on systems without a DMA-capable network adapter e.g. Cray XE6.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.USE_COMM_THREAD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Allow use of MPI-allocated memory for potentially faster network communication.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.DBCSR.USE_MPI_ALLOCATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Echo a list of hostname and pid for all MPI processes.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.ECHO_ALL_HOSTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "If the input should be echoed to the output with all the defaults made explicit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.ECHO_INPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "This keywords enables the usage of unsupported features in a release version. It affects ONLY release versions of CP2K (no effects on development versions).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.ENABLE_UNSUPPORTED_FEATURES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Use fft library specific values for the allows number of points in FFTs. The default is to use the internal FFT lengths. For external fft libraries this may create an error at the external library level, because the length provided by cp2k is not supported by the external library. In this case switch on this keyword to obtain, with certain fft libraries, lengths matching the external fft library lengths, or larger allowed grids, or grids that more precisely match a given cutoff. IMPORTANT NOTE: in this case, the actual grids used in CP2K depends on the FFT library. A change of FFT library must therefore be considered equivalent to a change of basis, which implies a change of total energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.EXTENDED_FFT_LENGTHS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Limits the memory usage of the FFT scratch pool, potentially reducing efficiency a bit",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FFT_POOL_SCRATCH_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "FFTW can have improved performance if it is allowed to plan with explicit measurements which strategy is best for a given FFT. While a plan based on measurements is generally faster, differences in machine load will lead to different plans for the same input file, and thus numerics for the FFTs will be slightly different from run to run.PATIENT planning is recommended for long ab initio MD runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FFTW_PLAN_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "The name of the file that contains wisdom (pre-planned FFTs) for use with FFTW3. Using wisdom can significantly speed up the FFTs (see the FFTW homepage for details). Note that wisdom is not transferable between different computer (architectures). Wisdom can be generated using the fftw-wisdom tool that is part of the fftw installation. cp2k/tools/cp2k-wisdom is a script that contains some additional info, and can help to generate a useful default for /etc/fftw/wisdom or particular values for a given simulation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FFTW_WISDOM_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Flush output regularly, enabling this option might degrade performance significantly on certain machines.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FLUSH_SHOULD_FLUSH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Ensure for small matrices that the layout is compatible with bigger ones, i.e. no subdivision is performed (can break LAPACK!!!).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FM.FORCE_BLOCK_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.FM"
      ]
    }, {
      "description": "Defines the number of columns per scalapack block in the creation of vlock cyclic dense matrices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FM.NCOL_BLOCKS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.FM"
      ]
    }, {
      "description": "Defines the number of rows per scalapack block in the creation of block cyclic dense matrices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FM.NROW_BLOCKS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.FM"
      ]
    }, {
      "description": "Allows to switch between scalapack pdgemm and dbcsr_multiply. On normal systems pdgemm is recommended on system with GPU is optimized and can give better performance. NOTE: if DBCSR is employed FORCE_BLOCK_SIZE should be set. The perfomance on GPU's dependes crucially on the BLOCK_SIZES. Make sure optimized kernels are available.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.FM.TYPE_OF_MATRIX_MULTIPLICATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.FM"
      ]
    }, {
      "description": "Enable memory binding on the compute node.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.MEM_POL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "The memory banks ID for each MPI process. It will beuse to set memory bank of the MPI process",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Apply a global MPI reordering for the run",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.MPI_REORDERING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Print machine architecture component organization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PRINT_BRANCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Print full machine architecture",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PRINT_FULL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Print the process binding in the machine.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PRINT_PROC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Print the compute node architecture number of components.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PRINT_RESUME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Print the current threads binding in the machine.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PRINT_THREAD_CUR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Print the threads binding in the machine.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PRINT_THREAD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Core ID for each MPI process of a compute node. It will be used to place the MPI process.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.PROCESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Enable process scheduling on the compute node.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.SCHED_MPI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Enable thread scheduling on the compute node.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.SCHED_THREAD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Core ID for each thread of a compute node. It will be used to place the thread.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.MACHINE_ARCH.THREAD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.MACHINE_ARCH"
      ]
    }, {
      "description": "Name of the output file. Relevant only if automatically started (through farming for example). If empty uses the project name as basis for it.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.OUTPUT_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Specifies the DIAGONALIZATION library. If not availabe ....",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PREFERRED_DIAG_LIBRARY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Specifies the FFT library which should be preferred. If it is not available, use FFTW3 if this is linked in, if FFTW3 is not available use FFTSG. Improved performance with FFTW3 can be obtained specifying a proper value for FFTW_PLAN_TYPE. Contrary to earlier CP2K versions, all libraries will result in the same grids, i.e. the subset of grids which all FFT libraries can transform. See EXTENDED_FFT_LENGTHS if larger FFTs or grids that more precisely match a given cutoff are needed, or older results need to be reproduced. FFTW3 is often (close to) optimal, and well tested with CP2K.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PREFERRED_FFT_LIBRARY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "How much output is written out.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PRINT_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Which program should be run",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROGRAM_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Name of the project (used to build the name of the trajectory, and other files generated by the program)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.PROJECT_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.REFERENCES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.REFERENCES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.REFERENCES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.REFERENCES"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.REFERENCES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.REFERENCES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.REFERENCES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.REFERENCES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.REFERENCES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.REFERENCES"
      ]
    }, {
      "description": "Type of run that you want to perform Geometry optimization, md, montecarlo,...",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.RUN_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Some sections of the input structure are deallocated when not needed, and reallocated only when used. This reduces the required maximum memory",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.SAVE_MEM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Initial seed for the global (pseudo)random number generator to create a stream of normally Gaussian distributed random numbers.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.SEED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": "Sort the final timing report by the average self (exclusive) time instead of the total (inclusive) time of a routine",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.SORT_BY_SELF_TIME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": "Specify % of CPUTIME above which the contribution will be inserted in the final timing report (e.g. 0.02 = 2%)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TIMINGS.THRESHOLD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL.TIMINGS"
      ]
    }, {
      "description": "For parallel TRACEd runs: only the master node writes output.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TRACE_MASTER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Limit the total number a given subroutine is printed in the trace. Accounting is not influenced.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TRACE_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "A list of routines to trace. If left empty all routines are traced. Accounting is not influenced.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TRACE_ROUTINES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "If a debug trace of the execution of the program should be written",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.TRACE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Maximum execution time for this run. Time in seconds or in HH:MM:SS.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_GLOBAL.WALLTIME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Enables the alignment of the frames at the beginning of a BAND calculation. This keyword does not affect the rotation of the replicas during a BAND calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ALIGN_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Specifies the type of BAND calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.BAND_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.BANNER.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.BANNER"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.BANNER.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.BANNER"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.BANNER.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.BANNER"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.BANNER.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.BANNER"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.BANNER.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.BANNER"
      ]
    }, {
      "description": "Specify the number of steps of IT-NEB to perform before switching on the CI algorithm",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CI_NEB.NSTEPS_IT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CI_NEB"
      ]
    }, {
      "description": "Tolerance on the maximum value of the displacement on the BAND.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_CONTROL.MAX_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Tolerance on the maximum value of Forces on the BAND.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_CONTROL.MAX_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Tolerance on RMS displacements on the BAND.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_CONTROL.RMS_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Tolerance on RMS Forces on the BAND.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_CONTROL.RMS_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.CONVERGENCE_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_INFO"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ENERGY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.ENERGY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ENERGY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.ENERGY"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ENERGY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.ENERGY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ENERGY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.ENERGY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ENERGY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.ENERGY"
      ]
    }, {
      "description": "Specify the value of the spring constant",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.K_SPRING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Specify the number of processors to be used per replica environment (for parallel runs)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.NPROC_REP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Specify the number of Replica to use in the BAND",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.NUMBER_OF_REPLICA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Performes a series of checks on the DIIS solution in order to accept the DIIS step. If set to .FALSE. the only check performed is that the angle between the DIIS solution and the reference vector is less than Pi/2. Can be useful if many DIIS steps are rejected.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.CHECK_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO"
      ]
    }, {
      "description": "Specify the maximum number of SD steps to perform before switching on DIIS (the minimum number will always be equal to N_DIIS).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.MAX_SD_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Maximum stepsize used for the line search, sometimes this parametercan be reduced to stablize the LS for particularly difficult initial geometries",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.MAX_STEPSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Specify the maximum number of optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.MAX_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Number of history vectors to be used with DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.N_DIIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Does not perform LS during SD. Useful in combination with a proper STEPSIZE for particularly out of equilibrium starting geometries.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.NO_LS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Number of points used in the line search SD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.NP_LS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Initial stepsize used for the line search, sometimes this parametercan be reduced to stablize DIIS",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.STEPSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Specify the maximum number of MD steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.MAX_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD"
      ]
    }, {
      "description": "Specify the number of steps to apply a temperature control",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL.TEMP_TOL_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL"
      ]
    }, {
      "description": "Specify the tolerance on the temperature for rescaling",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL.TEMP_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL"
      ]
    }, {
      "description": "Specify the target temperature",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL"
      ]
    }, {
      "description": "Specify the initial temperature",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD"
      ]
    }, {
      "description": "The length of an integration step",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.TIMESTEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD"
      ]
    }, {
      "description": "Specify the annealing coefficient",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL.ANNEALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL"
      ]
    }, {
      "description": "Uses a Projected Velocity Verlet instead of a normal Velocity Verlet. Every time the cosine between velocities and forces is < 0 velocities are zeroed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL.PROJ_VELOCITY_VERLET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL"
      ]
    }, {
      "description": "Zeros velocity at each MD step emulating a steepest descent like(SD_LIKE) approach",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL.SD_LIKE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL"
      ]
    }, {
      "description": "Specifies the type optimizer used for the band",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.OPT_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND"
      ]
    }, {
      "description": "Performs also an optimization of the end points of the band.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.OPTIMIZE_BAND.OPTIMIZE_END_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND"
      ]
    }, {
      "description": "Specifies the type of potential used in the BAND calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.POT_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Specify the topology of the mapping of processors into replicas.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROC_DIST_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Print information for the setup of the initial configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROGRAM_RUN_INFO.INITIAL_CONFIGURATION_INFO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Specifies the value of the collective variables used in the projected BAND method. The order of the values is the order of the COLLECTIVE section in the constraints/restraints section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA.COLLECTIVE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA.COORD"
      ]
    }, {
      "description": "Name of the xyz file with coordinates (alternative to &COORD section)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA.COORD_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA.VELOCITY"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.REPLICA_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA_INFO"
      ]
    }, {
      "description": "Compute at each BAND step the RMSD and rotate the frames in order to minimize it.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.ROTATE_FRAMES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Smoothing parameter for the reparametrization of the frames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.STRING_METHOD.SMOOTHING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.STRING_METHOD"
      ]
    }, {
      "description": "Specify the oder of the spline used in the String Method.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.STRING_METHOD.SPLINE_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.STRING_METHOD"
      ]
    }, {
      "description": "Uses a version of the band scheme projected in a subspace of colvars.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.BAND.USE_COLVARS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Specifies the name of the file used to read the initial Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS"
      ]
    }, {
      "description": "Controls the reading of the initial Hessian from file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.RESTART_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS"
      ]
    }, {
      "description": "Trust radius used in BFGS. Previously set to 0.1. Large values can lead to instabilities",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.TRUST_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS"
      ]
    }, {
      "description": "Uses a model Hessian as initial guess instead of a unit matrix. Should lead in general to improved convergence might be switched off for exotic cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.USE_MODEL_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS"
      ]
    }, {
      "description": "Includes a rational function optimization to determine the step. Previously default but did not improve convergence in many cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.BFGS.USE_RAT_FUN_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS"
      ]
    }, {
      "description": "Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate Gradients",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.FLETCHER_REEVES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG"
      ]
    }, {
      "description": "Use only the gradient, not the energy for line minimizations (e.g. in conjugate gradients).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.2PNT.LINMIN_GRAD_ONLY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Max allowed value for the line search step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.2PNT.MAX_ALLOWED_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Limit in 1D bracketing during line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD.BRACK_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Maximum number of iterations in brent algorithm (used for the line search in Conjugated Gradients Optimization)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD.BRENT_MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Tolerance requested during Brent line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD.BRENT_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Initial step size used, e.g. for bracketing or minimizers. Might need to be reduced for systems with close contacts",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD.INITIAL_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "1D line search algorithm to be used with the CG optimizer, in increasing order of robustness and cost.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.LINE_SEARCH.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Maximum number of steepest descent steps before starting the conjugate gradients optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.MAX_STEEP_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG"
      ]
    }, {
      "description": "Cosine of the angle between two consecutive searching directions. If the angle during a CG optimization is less than the one corresponding to  to the RESTART_LIMIT the CG is reset and one step of steepest descent is  performed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.CG.RESTART_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG"
      ]
    }, {
      "description": "Specifies the external pressure (1 value or the full 9 components of the pressure tensor) applied during the cell optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.EXTERNAL_PRESSURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Keep angles between the cell vectors constant, but allow the lenghts of the cell vectors to change independently. Albeit general, this is most useful for triclinic cells, to enforce higher symmetry, see KEEP_SYMMETRY.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.KEEP_ANGLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Keep the requested initial cell symmetry (e.g. during a cell optimisation). The initial symmetry must be specified in the &CELL section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.KEEP_SYMMETRY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Maximum number of force evaluations per iteration(used for the line search)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.LBFGS.MAX_F_PER_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.LBFGS"
      ]
    }, {
      "description": "Maximum rank (and consequently size) of the approximate Hessian matrix used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate the convergence behaviour at the cost of a larger memory consumption.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.LBFGS.MAX_H_RANK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested norm threshold of the gradient multiplied by the approximate Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.LBFGS.WANTED_PROJ_GRADIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested relative error on the objective functionof the optimizer (the energy)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.LBFGS.WANTED_REL_F_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.MAX_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Convergence criterium for the maximum force component of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.MAX_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Specify which method to use to perform a geometry optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.OPTIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Specifies the Pressure tolerance (compared to the external pressure) to achieve during the cell optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.PRESSURE_TOLERANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.RMS_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) force of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.RMS_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "The starting step value for the CELL_OPT module.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.STEP_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Specify which kind of method to use for the optimization of the simulation cell",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CELL_OPT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Specifies the index (in input file order) of the type of colvar to constrain.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.COLVAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Does not apply the constraint to the MM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.EXCLUDE_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Does not apply the constraint to the QM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.EXCLUDE_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Specify if the constraint/restraint is intermolecular.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.INTERMOLECULAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Specifies the index of the molecule kind (in input file order)on which the constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.MOLECULE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Specifies the name of the molecule on which the constraint will be applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.RESTRAINT.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE.RESTRAINT"
      ]
    }, {
      "description": "Specifies the growth speed of the target value of the constrained collective variable.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.TARGET_GROWTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Specifies the limit of the growth of the target value of the constrained collective variable. By default no limit at the colvar growth is set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.TARGET_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Specifies the target value of the constrained collective variable (units depend on the colvar).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLLECTIVE.TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "The restarting values for COLVAR restraints. The order is an internal order. So if you decide to modify these values by hand first think what you're doing!",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.COLVAR_RESTART.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLVAR_RESTART"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.CONSTRAINT_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.CONSTRAINT_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.CONSTRAINT_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.CONSTRAINT_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.CONSTRAINT_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.CONSTRAINT_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.CONSTRAINT_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.CONSTRAINT_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.CONSTRAINT_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.CONSTRAINT_INFO"
      ]
    }, {
      "description": "Apply constraints to the initial position and velocities. Default is to apply constraints only after the first MD step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.CONSTRAINT_INIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "The restarting position of fixed atoms for restraints. The order is an internal order. So if you decide to modify these values by hand first think what you're doing!",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIX_ATOM_RESTART.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIX_ATOM_RESTART"
      ]
    }, {
      "description": "Specify which components (X,Y,Z or combinations) of the atoms specified in the sectionwill be constrained/restrained.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.COMPONENTS_TO_FIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "Does not apply the constraint to the MM region within a QM/MM calculation. This keyword is active only together with MOLNAME",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.EXCLUDE_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "Does not apply the constraint to the QM region within a QM/MM calculation. This keyword is active only together with MOLNAME",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.EXCLUDE_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "Specifies a list of atoms to freeze.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "In a QM/MM run all  MM atoms are fixed according to the argument.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.MM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "Specifies the name of the molecule to fix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "In a QM/MM run all QM atoms are fixed according to the argument.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.QM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.FIXED_ATOMS.RESTRAINT.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS.RESTRAINT"
      ]
    }, {
      "description": "Atoms' index on which apply the constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "The constrained distances' values.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.DISTANCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "Does not apply the constraint to the MM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.EXCLUDE_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "Does not apply the constraint to the QM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.EXCLUDE_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "Specify if the constraint/restraint is intermolecular.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.INTERMOLECULAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "Specifies the molecule kind number on which constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.MOLECULE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "Specifies the name of the molecule on which the constraint will be applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G3X3.RESTRAINT.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3.RESTRAINT"
      ]
    }, {
      "description": "Atoms' index on which apply the constraint",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "The constrained distances' values.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.DISTANCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "Does not apply the constraint to the MM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.EXCLUDE_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "Does not apply the constraint to the QM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.EXCLUDE_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "Specify if the constraint/restraint is intermolecular.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.INTERMOLECULAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "Specifies the molecule number on which constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.MOLECULE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "Specifies the name of the molecule on which the constraint will be applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.G4X6.RESTRAINT.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6.RESTRAINT"
      ]
    }, {
      "description": "Defines the atoms' type forming a bond with an hydrogen. If not specified  the default bond value of the first molecule is used as constraint target",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.ATOM_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "Does not shake HBONDS in the MM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.EXCLUDE_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "Does not shake HBONDS in the QM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.EXCLUDE_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "Specifies the indexes of the molecule kind (in input file order)on which the constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.MOLECULE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "Specifies the names of the molecule on which the constraint will be applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.RESTRAINT.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS.RESTRAINT"
      ]
    }, {
      "description": "The constrained distances' values  for the types defines in ATOM_TYPE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.HBONDS.TARGETS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS"
      ]
    }, {
      "description": "Set the tolerance for the roll constraint algorithm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.ROLL_TOLERANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Set the tolerance for the shake/rattle constraint algorithm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.SHAKE_TOLERANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Atoms' index on which apply the constraint (v i j k), first is virtual site",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "Does not apply the constraint to the MM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.EXCLUDE_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "Does not apply the constraint to the QM region within a QM/MM calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.EXCLUDE_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "Specify if the constraint/restraint is intermolecular.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.INTERMOLECULAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "Specifies the molecule number on which constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.MOLECULE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "Specifies the name of the molecule on which the constraint will be applied.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "The constrained paramters' values to construct virtual site.r_v=a*r_ij+b*r_kj",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.CONSTRAINT.VIRTUAL_SITE.RESTRAINT.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE.RESTRAINT"
      ]
    }, {
      "description": "Host name for the i-PI server.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.DRIVER.HOST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.DRIVER"
      ]
    }, {
      "description": "Port number for the i-PI server.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.DRIVER.PORT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.DRIVER"
      ]
    }, {
      "description": "Use a UNIX socket rather than an INET socket.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.DRIVER.UNIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.DRIVER"
      ]
    }, {
      "description": "If a bias potential counter-acting the weight term should be applied (recommended).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.BIAS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "Specifies the central atom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.CENTRAL_ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL"
      ]
    }, {
      "description": "Specifies the list of atoms that should remain close to the central atom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.INNER_ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "radius of the inner wall",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.INNER_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "Specifies the list of atoms that should remain far from the central atom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.OUTER_ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "radius of the outer wall",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.OUTER_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "Sets the width of the smooth counting function.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.SMOOTH_WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "Sets the force constant of the repulsive harmonic potential",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.STRENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "Sets the temperature parameter that is used in the baising potential.It is recommended to use the actual simulation temperature",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS"
      ]
    }, {
      "description": "Set the relative tolerance for the convergence of the free energy derivative",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE.EPS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE"
      ]
    }, {
      "description": "Set the number of equilibration steps, skipped to compute averages",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE.NEQUIL_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE"
      ]
    }, {
      "description": "Defines the perturbing parameter of the alchemical change tranformation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE.PARAMETER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE"
      ]
    }, {
      "description": "Specifies the weighting function (umbrella potential, part of the mixing function)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE.WEIGHTING_FUNCTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO"
      ]
    }, {
      "description": "COLVAR average temperature. Only for restarting purposes.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.COLVAR_AVG_TEMPERATURE_RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "If Well-tempered metaD is used, the temperature parameter must be specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.DELTA_T",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "This keyword enables the spawning of the hills. Default .FALSE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.DO_HILLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specified the theta",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_FS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_FS"
      ]
    }, {
      "description": "Specified the theta",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_SS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_SS"
      ]
    }, {
      "description": "Specified the positions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_SS0.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_SS0"
      ]
    }, {
      "description": "Specified the velocities",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_VVP.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_VVP"
      ]
    }, {
      "description": "By setting this variable larger than 0 the tail of the Gaussian hill  is damped to zero faster. The Gaussian function is multiplied by a cutoff function that becomes active at |x-X0|>HILL_TAIL_CUTOFF*SCALE, where X0 is the location of the Gaussian and SCALE is the width of the Gaussian. For more than one METAVAR X0 and SCALE are METAVAR-dependent.  (1-(|x-X0|/HILL_TAIL_CUTOFF*SCALE)^P_EXP)/(1-(|x-X0|/HILL_TAIL_CUTOFF*SCALE)^Q_EXP)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.HILL_TAIL_CUTOFF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specifies whether an extended-lagrangian should be used. Default .FALSE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.LAGRANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "If a Lagrangian scheme is used the eq. motion of the COLVARS are integrated with a LANGEVIN scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.LANGEVIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specifies the colvar on which to apply metadynamics.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.COLVAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR"
      ]
    }, {
      "description": "Specifies the friction term in Langevin integration of the collective variable in the extended lagrangian scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR"
      ]
    }, {
      "description": "Specifies the lambda parameter of the collective variable in the extended lagrangian scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.LAMBDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR"
      ]
    }, {
      "description": "Specifies the mass parameter of the collective variable in the extended lagrangian scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.MASS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR"
      ]
    }, {
      "description": "Specifies the scale factor for the following collective variable. The history dependent term has the expression: WW * Sum_{j=1}^{nhills} Prod_{k=1}^{ncolvar} [EXP[-0.5*((ss-ss0(k,j))/SCALE(k))^2]], where ncolvar is the number of defined METAVAR and nhills is the number of spawned hills.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR"
      ]
    }, {
      "description": "Specify the width of the gaussian: WW*e^(-((CV-POS)/sigma)^2)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.GAUSSIAN.SIGMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.GAUSSIAN"
      ]
    }, {
      "description": "Specify the height of the gaussian: WW*e^(-((CV-POS)/sigma)^2)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.GAUSSIAN.WW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.GAUSSIAN"
      ]
    }, {
      "description": "Specify the value of the colvar for the wall position",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.POSITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL"
      ]
    }, {
      "description": "Specify the direction of the wall.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUADRATIC.DIRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUADRATIC"
      ]
    }, {
      "description": "Specify the value of the quadratic potential constant: K*(CV-POS)^2",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUADRATIC.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUADRATIC"
      ]
    }, {
      "description": "Specify the direction of the wall.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUARTIC.DIRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUARTIC"
      ]
    }, {
      "description": "Specify the value of the quartic potential constant: K*(CV-(POS+/-(1/K^(1/4))))^4",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUARTIC.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUARTIC"
      ]
    }, {
      "description": "Specify the direction of the wall.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.REFLECTIVE.DIRECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.REFLECTIVE"
      ]
    }, {
      "description": "Specify the type of wall",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL"
      ]
    }, {
      "description": "Minimum displacement between hills before placing a new hill.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MIN_DISP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specify the minimum MD step interval between spawning two hills. If specified, it must be >= than NT_HILLS. In case MIN_DISP is used, if MIN_DISP is satisfied before MIN_NT_HILLS MD steps have been performed, the MD will continue without any spawning until MIN_NT_HILLS is reached. The default value has the net effect of skipping this check.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MIN_NT_HILLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Sets the total number of walkers in the metadynamic run.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.NUMBER_OF_WALKERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS"
      ]
    }, {
      "description": "Controls the usage of the multiple walkers in a metadynamics run.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS"
      ]
    }, {
      "description": "Sets the frequency (in unit of spawned hills) for the communication between the several walkers, in order to update the local list of hills with the ones coming from the other walkers",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.WALKER_COMM_FREQUENCY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS"
      ]
    }, {
      "description": "Sets the walker ID for the local metadynamics run.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.WALKER_ID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS"
      ]
    }, {
      "description": "Specified the communication filename for each walker.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.WALKERS_FILE_NAME.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.WALKERS_FILE_NAME"
      ]
    }, {
      "description": "Stores the status of the several walkers in the local run.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.WALKERS_STATUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS"
      ]
    }, {
      "description": "The starting value of previously spawned hills",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.NHILLS_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specify the maximum MD step interval between spawning two hills. When negative, no new hills are spawned and only the hills read from SPAWNED_HILLS_* are in effect. The latteris useful when one wants to add a custom constant bias potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.NT_HILLS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Index of the last hill spawned for this walker.Needed to calculate MIN_DISP",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.OLD_HILL_NUMBER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Timestep of the last hill spawned for this walker.Needed to calculate MIN_DISP",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.OLD_HILL_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Exponent at the numerator of the cutoff function to damp the tail of the Gaussian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.P_EXPONENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specify the file name of the external plumed input file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.PLUMED_INPUT_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Exponent at the denominator of the cutoff function to damp the tail of the Gaussian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.Q_EXPONENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Let the last hill grow slowly over NT_HILLS.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.SLOW_GROWTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specify the spawned hills",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_HEIGHT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_HEIGHT"
      ]
    }, {
      "description": "Specify the spawned hills",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_INVDT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_INVDT"
      ]
    }, {
      "description": "Specify the spawned hills",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_POS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_POS"
      ]
    }, {
      "description": "Specify the spawned hills",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_SCALE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_SCALE"
      ]
    }, {
      "description": "The starting step value for metadynamics",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.STEP_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Number of sampling points for z",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.TAMCSTEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "If a Lagrangian scheme is used the temperature tolerance for the collective variables is specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.TEMP_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "If a Lagrangian scheme is used the temperature for the collective variables is specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "The length of an integration step for colvars (TAMC only)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.TIMESTEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specify whether to use plumed as an external metadynamics driver.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.USE_PLUMED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "This keyword enables Well-tempered metadynamics. Default .FALSE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.WELL_TEMPERED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "If Well-tempered metaD is used, the gamma parameter must be specified if not DELTA_T.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.WTGAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specifies the height of the gaussian to spawn. Default 0.1 .",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METADYN.WW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Defines the method to use to compute free energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY"
      ]
    }, {
      "description": "Set the minimum amount of coarse grained points to collect before starting the statistical analysis",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.COARSE_GRAINED_POINTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Width of segments in MD steps to generate the set of coarse grained data, providing a correlation independent data set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.COARSE_GRAINED_WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Set the relative tolerance for the convergence of the collective variable averages used to compute the free energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.EPS_CONV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Set the confidence limit for the Mann-Kendall trend test.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.K_CONFIDENCE_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Max Width of segments in MD steps to generate the set of coarse grained data.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.MAX_COARSE_GRAINED_WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Set the confidence limit for the Shapiro-Wilks normality test.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.SW_CONFIDENCE_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Set the confidence limit for the Von Neumann serial correlation test.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL.VN_CONFIDENCE_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL"
      ]
    }, {
      "description": "Specifies the colvar used to compute free energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.UVAR.COLVAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.UVAR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS.RESTART"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Specifies the name of the file used to read the initial Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS"
      ]
    }, {
      "description": "Controls the reading of the initial Hessian from file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.RESTART_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS"
      ]
    }, {
      "description": "Trust radius used in BFGS. Previously set to 0.1. Large values can lead to instabilities",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.TRUST_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS"
      ]
    }, {
      "description": "Uses a model Hessian as initial guess instead of a unit matrix. Should lead in general to improved convergence might be switched off for exotic cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.USE_MODEL_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS"
      ]
    }, {
      "description": "Includes a rational function optimization to determine the step. Previously default but did not improve convergence in many cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.BFGS.USE_RAT_FUN_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS"
      ]
    }, {
      "description": "Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate Gradients",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.FLETCHER_REEVES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG"
      ]
    }, {
      "description": "Use only the gradient, not the energy for line minimizations (e.g. in conjugate gradients).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.2PNT.LINMIN_GRAD_ONLY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Max allowed value for the line search step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.2PNT.MAX_ALLOWED_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Limit in 1D bracketing during line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD.BRACK_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Maximum number of iterations in brent algorithm (used for the line search in Conjugated Gradients Optimization)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD.BRENT_MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Tolerance requested during Brent line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD.BRENT_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Initial step size used, e.g. for bracketing or minimizers. Might need to be reduced for systems with close contacts",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD.INITIAL_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "1D line search algorithm to be used with the CG optimizer, in increasing order of robustness and cost.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.LINE_SEARCH.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Maximum number of steepest descent steps before starting the conjugate gradients optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.MAX_STEEP_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG"
      ]
    }, {
      "description": "Cosine of the angle between two consecutive searching directions. If the angle during a CG optimization is less than the one corresponding to  to the RESTART_LIMIT the CG is reset and one step of steepest descent is  performed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.CG.RESTART_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG"
      ]
    }, {
      "description": "Maximum number of force evaluations per iteration(used for the line search)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.LBFGS.MAX_F_PER_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.LBFGS"
      ]
    }, {
      "description": "Maximum rank (and consequently size) of the approximate Hessian matrix used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate the convergence behaviour at the cost of a larger memory consumption.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.LBFGS.MAX_H_RANK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested norm threshold of the gradient multiplied by the approximate Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.LBFGS.WANTED_PROJ_GRADIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested relative error on the objective functionof the optimizer (the energy)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.LBFGS.WANTED_REL_F_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.MAX_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Convergence criterium for the maximum force component of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.MAX_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Specify which method to use to perform a geometry optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.OPTIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.RMS_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) force of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.RMS_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "The starting step value for the GEO_OPT module.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.STEP_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "This keyword sets the value of the tolerance angle for the line search  performed to optimize the orientation of the dimer.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ANGLE_TOLERANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER"
      ]
    }, {
      "description": "Specify on each line the components of the dimer vector.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.DIMER_VECTOR.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.DIMER_VECTOR"
      ]
    }, {
      "description": "This keyword sets the value for the DR parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER"
      ]
    }, {
      "description": "This keyword controls the interpolation of the gradient whenever possible during the optimization of the Dimer. The use of this keywords saves 1 evaluation  of energy/forces.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.INTERPOLATE_GRADIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Specifies the name of the file used to read the initial Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS"
      ]
    }, {
      "description": "Controls the reading of the initial Hessian from file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS"
      ]
    }, {
      "description": "Trust radius used in BFGS. Previously set to 0.1. Large values can lead to instabilities",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.TRUST_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS"
      ]
    }, {
      "description": "Uses a model Hessian as initial guess instead of a unit matrix. Should lead in general to improved convergence might be switched off for exotic cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.USE_MODEL_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS"
      ]
    }, {
      "description": "Includes a rational function optimization to determine the step. Previously default but did not improve convergence in many cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.USE_RAT_FUN_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS"
      ]
    }, {
      "description": "Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate Gradients",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.FLETCHER_REEVES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG"
      ]
    }, {
      "description": "Use only the gradient, not the energy for line minimizations (e.g. in conjugate gradients).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.2PNT.LINMIN_GRAD_ONLY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Max allowed value for the line search step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.2PNT.MAX_ALLOWED_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Limit in 1D bracketing during line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD.BRACK_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Maximum number of iterations in brent algorithm (used for the line search in Conjugated Gradients Optimization)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD.BRENT_MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Tolerance requested during Brent line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD.BRENT_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Initial step size used, e.g. for bracketing or minimizers. Might need to be reduced for systems with close contacts",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD.INITIAL_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "1D line search algorithm to be used with the CG optimizer, in increasing order of robustness and cost.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Maximum number of steepest descent steps before starting the conjugate gradients optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.MAX_STEEP_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG"
      ]
    }, {
      "description": "Cosine of the angle between two consecutive searching directions. If the angle during a CG optimization is less than the one corresponding to  to the RESTART_LIMIT the CG is reset and one step of steepest descent is  performed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.RESTART_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG"
      ]
    }, {
      "description": "Maximum number of force evaluations per iteration(used for the line search)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS.MAX_F_PER_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS"
      ]
    }, {
      "description": "Maximum rank (and consequently size) of the approximate Hessian matrix used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate the convergence behaviour at the cost of a larger memory consumption.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS.MAX_H_RANK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested norm threshold of the gradient multiplied by the approximate Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS.WANTED_PROJ_GRADIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested relative error on the objective functionof the optimizer (the energy)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS.WANTED_REL_F_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.MAX_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Convergence criterium for the maximum force component of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.MAX_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Specify which method to use to perform a geometry optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.OPTIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.RMS_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) force of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.RMS_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "The starting step value for the ROT_OPT module.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.STEP_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Specify which kind of method to use for locating transition states",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TRANSITION_STATE.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE"
      ]
    }, {
      "description": "Specify which kind of geometry optimization to perform",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.GEO_OPT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "The target atom for an AVBMC swap move for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.AVBMC.AVBMC_ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.AVBMC"
      ]
    }, {
      "description": "The outer radius for an AVBMC swap move, in angstroms, for every molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.AVBMC.AVBMC_RMAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.AVBMC"
      ]
    }, {
      "description": "The inner radius for an AVBMC swap move, in angstroms for every molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.AVBMC.AVBMC_RMIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.AVBMC"
      ]
    }, {
      "description": "The probability of swapping to an inner region in an AVBMC swap move for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.AVBMC.PBIAS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.AVBMC"
      ]
    }, {
      "description": "For GEMC, the name of the input file for the other box.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.BOX2_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The file to print current cell length info to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The file to print the current coordinates to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.COORDINATE_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The file to print current configurational info to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.DATA_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The size of the discrete volume move step, in angstroms.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.DISCRETE_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The file to print current energies to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.ENERGY_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Specify the type of simulation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.ENSEMBLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The free energy bias (in Kelvin) for swapping a molecule of each type into this box.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.ETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Prints coordinate/cell/etc information every IPRINT steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.IPRINT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Dictates if we presample moves with a different potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.LBIAS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Changes the volume of the box in discrete steps, one side at a time.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.LDISCRETE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Makes nstep in terms of steps, instead of cycles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.LSTOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The file to print current maximum displacement info to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISP_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Maximum volume displacement, in angstrom**3.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISPLACEMENTS.BOX_DISPLACEMENTS.RMVOLUME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.BOX_DISPLACEMENTS"
      ]
    }, {
      "description": "Maximum bond angle displacement, in degrees, for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS.RMANGLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS"
      ]
    }, {
      "description": "Maximum bond length displacement, in angstroms, for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS.RMBOND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS"
      ]
    }, {
      "description": "Maximum dihedral angle distplacement, in degrees, for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS.RMDIHEDRAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS"
      ]
    }, {
      "description": "Maximum rotational displacement, in degrees, for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS.RMROT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS"
      ]
    }, {
      "description": "Maximum translational displacement, in angstroms, for each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS.RMTRANS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS"
      ]
    }, {
      "description": "The file to print the number of molecules to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOLECULES_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The probability of attempting a HMC move on this box.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.BOX_PROBABILITIES.PMHMC_BOX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.BOX_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a volume move on this box (GEMC_NpT).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.BOX_PROBABILITIES.PMVOL_BOX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.BOX_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting an AVBMC swap move on each molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES.PMAVBMC_MOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a molecule rotation of a given molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES.PMROT_MOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a molecule swap of a given molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES.PMSWAP_MOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a conformational change of a given molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES.PMTRAION_MOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a molecule translation of a given molecule type.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES.PMTRANS_MOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting an AVBMC swap move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.PMAVBMC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a hybrid MC move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.PMHMC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a swap move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.PMSWAP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a conformational change.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.PMTRAION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a molecule translation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.PMTRANS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "The probability of attempting a volume move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_PROBABILITIES.PMVOLUME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "Every iuptrans steps update maximum translation/rotation/configurational changes.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_UPDATES.IUPTRANS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_UPDATES"
      ]
    }, {
      "description": "Every iupvolume steps update maximum volume displacement.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVE_UPDATES.IUPVOLUME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_UPDATES"
      ]
    }, {
      "description": "The file to print the move statistics to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.MOVES_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Specifies the number of classical moves between energy evaluations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.NMOVES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Specifies the number of MC cycles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.NSTEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "How many insertions to try per swap move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.NSWAPMOVES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Use this many random orientations to compute the second virial coefficient (ENSEMBLE=VIRIAL)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.NVIRIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The pressure for NpT simulations, in bar.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.PRESSURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Number of random numbers from the acceptance/rejection stream to skip",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.RANDOMTOSKIP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Name of the restart file for MC information.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Read initial configuration from restart file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The temperature of the simulation, in Kelvin.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "The temperatures you wish to compute the virial coefficient for.  Only used if ensemble=VIRIAL.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MC.VIRIAL_TEMPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "number of respa steps for fast degrees of freedom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.N_RESP_FAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "Temperature in K used to control the fast degrees of freedom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.TEMP_FAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "Temperature in K used to control the slow degrees of freedom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.TEMP_SLOW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "Maximum accepted temperature deviation from the expected value, for the fast motion.If 0, no rescaling is performed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.TEMP_TOL_FAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "Maximum accepted temperature deviation from the expected value, for the slow motion.If 0, no rescaling is performed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.TEMP_TOL_SLOW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "Specifies a list of atoms to thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION.MM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION"
      ]
    }, {
      "description": "Specifies the name of the molecules to thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION.QM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.COORD"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.FORCE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.FORCE"
      ]
    }, {
      "description": "length of the Nose-Hoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.MASS"
      ]
    }, {
      "description": "number of multiple timesteps to be used for the NoseHoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.MTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "timeconstant of the thermostat chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.VELOCITY"
      ]
    }, {
      "description": "order of the yoshida integretor used for the thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.YOSHIDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "Determines the defined region for fast thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.REGION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST"
      ]
    }, {
      "description": "Specify the thermostat used for the constant temperature ensembles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST"
      ]
    }, {
      "description": "Specifies a list of atoms to thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION.MM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION"
      ]
    }, {
      "description": "Specifies the name of the molecules to thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION.QM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.COORD"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.FORCE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.FORCE"
      ]
    }, {
      "description": "length of the Nose-Hoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.MASS"
      ]
    }, {
      "description": "number of multiple timesteps to be used for the NoseHoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.MTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "timeconstant of the thermostat chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.VELOCITY"
      ]
    }, {
      "description": "order of the yoshida integretor used for the thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.YOSHIDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "Determines the defined region for slow thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.REGION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW"
      ]
    }, {
      "description": "Specify the thermostat used for the constant temperature ensembles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW"
      ]
    }, {
      "description": "The maximum accepted angular velocity. This option is ignored when the system is periodic. Removes the components of the velocities thatproject on the external rotational degrees of freedom.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ANGVEL_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Set the initial angular velocity to zero. This option is ignored when the system is periodic or when initial velocities are defined. Technically, the part of the random initial velocities that projects on the external rotational degrees of freedom is subtracted.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ANGVEL_ZERO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Specifies the rescaling factor for annealing velocities of the CELL Automatically enables the annealing procedure for the CELL. This scheme works only for ensambles that do not have thermostat on CELLS velocities.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ANNEALING_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Specifies the rescaling factor for annealing velocities. Automatically enables the annealing procedure. This scheme works only for ensembles that do not have thermostats on particles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ANNEALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Setup up the simulation time when the acquisition process to compute  averages is started.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.ACQUISITION_START_TIME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES"
      ]
    }, {
      "description": "Switch for computing the averages of COLVARs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.AVERAGE_COLVAR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.PRINT_AVERAGES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.PRINT_AVERAGES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.PRINT_AVERAGES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.PRINT_AVERAGES"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.PRINT_AVERAGES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.PRINT_AVERAGES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.PRINT_AVERAGES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.PRINT_AVERAGES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.PRINT_AVERAGES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.PRINT_AVERAGES"
      ]
    }, {
      "description": "COLVARS averages",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_COLVARS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "CONSTANT ENERGY average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_ECONS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "METRIC TENSOR averages",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_MMATRIX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PRESSURE average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PRESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PV CONSTRAINTS average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PV_CNSTR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PV XC average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PV_FOCK_4C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PV KINETIC average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PV_KIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PV TOTAL average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PV_TOT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PV VIRIAL average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PV_VIR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "PV XC average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PV_XC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "P_{XX} average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVE_PXX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "ALPHA cell angle average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "BETA cell angle average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEBETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "CELL VECTOR A average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVECELL_A",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "CELL VECTOR B average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVECELL_B",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "CELL VECTOR C average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVECELL_C",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "CPU average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVECPU",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "GAMMA cell angle average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEGAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "HUGONIOT average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEHUGONIOT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "QM KINETIC ENERGY average in QMMM runs",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEKIN_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "KINETIC ENERGY average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEKIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "POTENTIAL ENERGY average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEPOT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "BAROSTAT TEMPERATURE average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVETEMP_BARO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "QM TEMPERATURE average in QMMM runs",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVETEMP_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "TEMPERATURE average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVETEMP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "VOLUME average",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.AVEVOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "TIME STEP starting the evaluation of averages",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.RESTART_AVERAGES.ITIMES_START",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES"
      ]
    }, {
      "description": "Controls the calculations of the averages.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.AVERAGES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.MASS"
      ]
    }, {
      "description": "Initial pressure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.PRESSURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Maximum oscillation of the Barostat temperature imposed by rescaling.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.TEMP_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Barostat initial temperature. If not set, the ensemble temperature is used instead.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.CHI.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.CHI"
      ]
    }, {
      "description": "Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.MASS"
      ]
    }, {
      "description": "Time constant of the Langevin part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.TIMECON_LANGEVIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.TIMECON_NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.RNG_INIT"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "Time constant of the CSVR thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "A matrix The defaults give optimal sampling for most cristalline and liquid compounds. Generated with the parameters set kv_4-4.acentered on w_0=40 cm^-1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.A_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "scaling factor for matrix A (for generic matrix A, depends on the characteristic frequency of the system).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.A_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "C matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.C_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Size of the gle matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.NDIM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.RNG_INIT"
      ]
    }, {
      "description": "Specify s variable for GLE thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.S.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.S"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.COORD"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.FORCE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.FORCE"
      ]
    }, {
      "description": "length of the Nose-Hoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.MASS"
      ]
    }, {
      "description": "number of multiple timesteps to be used for the NoseHoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.MTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "timeconstant of the thermostat chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.VELOCITY"
      ]
    }, {
      "description": "order of the yoshida integretor used for the thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.YOSHIDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify the thermostat used for the constant temperature ensembles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.THERMOSTAT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT"
      ]
    }, {
      "description": "Barostat time constant",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.VELOCITY"
      ]
    }, {
      "description": "For NPT_F only: allows the screening of one or more components of the virial in order to relax the cell only along specific cartesian axis",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.BAROSTAT.VIRIAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Defines the list of atoms for which the velocities are modified. Each record consists of the atomic index, the velocity vector, and a weight to define which fraction of the total energy is assigned to the current atom:<p><tt><big>Atomic_index v<sub>x</sub> v<sub>y</sub> v<sub>x</sub> Weight</big></tt></p>",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.CASCADE.ATOM_LIST.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.CASCADE.ATOM_LIST"
      ]
    }, {
      "description": "Total energy transferred to the system during the cascade event.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.CASCADE.ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.CASCADE"
      ]
    }, {
      "description": "Controls the activation of the CASCADE section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.CASCADE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.CASCADE"
      ]
    }, {
      "description": "The maximum accepted velocity of the center of mass. With Shell-Model, comvel may drift if MD%THERMOSTAT%REGION /= GLOBAL",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.COMVEL_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "This keyword sets a maximum atomic displacement  in each Cartesian direction.The maximum velocity is evaluated and if it is too large to remainwithin the assigned limit, the time step is rescaled accordingly,and the first half step of the velocity verlet is repeated.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.DISPLACEMENT_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The starting  value of the conserved quantity",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ECONS_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The ensemble/integrator that you want to use for MD propagation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.ENSEMBLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Gamma parameter for the Langevin dynamics (LD)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.LANGEVIN.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.LANGEVIN"
      ]
    }, {
      "description": "Imaginary Langevin Friction term for LD with noisy forces.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.LANGEVIN.NOISY_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.LANGEVIN"
      ]
    }, {
      "description": "Shadow Langevin Friction term for LD with noisy forces in order to adjust Noisy_Gamma.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.LANGEVIN.SHADOW_GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.LANGEVIN"
      ]
    }, {
      "description": "Effective cell mass",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.MSST.CMASS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.MSST"
      ]
    }, {
      "description": "Initial energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.MSST.ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.MSST"
      ]
    }, {
      "description": "Damping coefficient for cell volume",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.MSST.GAMMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.MSST"
      ]
    }, {
      "description": "Initial pressure",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.MSST.PRESSURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.MSST"
      ]
    }, {
      "description": "Initial volume",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.MSST.VOLUME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.MSST"
      ]
    }, {
      "description": "Velocity shock",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.MSST.VSHOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.MSST"
      ]
    }, {
      "description": "Specify the filename where the cell is stored (for trajectories generated within variable cell ensembles).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Evaluate energy and forces for each retrieved snapshot during a REFTRAJ run",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.EVAL_ENERGY_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Index of the snapshot stored in the trajectory file from which to start a REFTRAJ run",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.FIRST_SNAPSHOT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Index of the last snapshot stored in the trajectory file that is read along a REFTRAJ run",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.LAST_SNAPSHOT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Specifies a list of atoms to thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION.MM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION"
      ]
    }, {
      "description": "Specifies the name of the molecules to thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION.QM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION"
      ]
    }, {
      "description": "Identify the atoms that moved from their initialposition of a distance larger than a given tolerance (see msd%displacement_tol).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.DISPLACED_ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "Lower limit to define displaced atoms",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.DISPLACEMENT_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "Set up the calculation of the MSD for each atomic kind",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.MSD_PER_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "Set up the calculation of the MSD for each molecule kind.The position of the center of mass of the molecule is considered.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.MSD_PER_MOLKIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "Set up the calculation of the MSD for each defined region.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.MSD_PER_REGION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "Specify the filename where the initial reference configuration is stored.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.REF0_FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "controls the activation of core-level spectroscopy simulations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.MSD.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": " Stride in number of snapshot for the  reftraj analysis",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.STRIDE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Specify the filename where the trajectory is stored.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.TRAJ_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Enables the possibility to read a CELL file with information on the CELL size during the MD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.REFTRAJ.VARIABLE_VOLUME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "The number of reference MD steps between two RESPA corrections.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.RESPA.FREQUENCY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.RESPA"
      ]
    }, {
      "description": "When necessary rescale the temperature per each kind separately",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SCALE_TEMP_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "This keyword sets a maximum variation of the shell core distance in each Cartesian direction.The maximum internal core-shell velocity is evaluated and if it is too large to remainwithin the assigned limit, the time step is rescaled accordingly,and the first half step of the velocity verlet is repeated.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.DISPLACEMENT_SHELL_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL"
      ]
    }, {
      "description": "If nvt or npt, the core and shell velocities are controlled by the same thermostat used for the particle. This might favour heat exchange and additional rescaling of the internal core-shell velocity is needed (TEMP_TOL)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.NOSE_PARTICLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL"
      ]
    }, {
      "description": "Maximum accepted temperature deviation from the expected value, for the internal core-shell motion.If 0, no rescaling is performed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.TEMP_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL"
      ]
    }, {
      "description": "Temperature in K used to control the internal velocities of the core-shell motion",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL"
      ]
    }, {
      "description": "Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.CHI.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.CHI"
      ]
    }, {
      "description": "Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.MASS"
      ]
    }, {
      "description": "Time constant of the Langevin part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.TIMECON_LANGEVIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.TIMECON_NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.RNG_INIT"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "Time constant of the CSVR thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Specifies a list of atoms to thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION.MM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "Specifies the name of the molecules to thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION.QM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "A matrix The defaults give optimal sampling for most cristalline and liquid compounds. Generated with the parameters set kv_4-4.acentered on w_0=40 cm^-1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.A_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "scaling factor for matrix A (for generic matrix A, depends on the characteristic frequency of the system).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.A_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "C matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.C_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Size of the gle matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.NDIM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE.RNG_INIT"
      ]
    }, {
      "description": "Specify s variable for GLE thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.S.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE.S"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.GLE.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.COORD"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.FORCE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.FORCE"
      ]
    }, {
      "description": "length of the Nose-Hoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.MASS"
      ]
    }, {
      "description": "number of multiple timesteps to be used for the NoseHoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.MTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "timeconstant of the thermostat chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.VELOCITY"
      ]
    }, {
      "description": "order of the yoshida integretor used for the thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.YOSHIDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Determines the region each thermostat is attached to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.REGION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "Specify the thermostat used for the constant temperature ensembles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.SHELL.THERMOSTAT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "The starting step value for the MD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.STEP_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The number of MD steps to perform",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Compute the temperature per each kind separately",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.TEMP_KIND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The maximum accepted deviation of the (global) temperaturefrom the desired target temperature before a rescaling of the velocites is performed. If it is 0 no rescaling is performed. NOTE: This keyword is obsolescent; Using a CSVR thermostat with a short timeconstant is recommended as a better alternative.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.TEMP_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The temperature in K used to initialize the velocities with init and pos restart, and in the NPT/NVT simulations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "When ENSEMBLE is set to LANGEVIN, Controls whether the atoms in the thermal region should undergo Langevin MD. If not, then they will undergo NVE Born-Oppenheimer MD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION.DO_LANGEVIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION"
      ]
    }, {
      "description": "Specifies a list of atoms belonging to the region.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION"
      ]
    }, {
      "description": "Maximum accepted temperature deviation from the expected value for this region. If temp_tol=0 no rescaling is performed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION.TEMP_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION"
      ]
    }, {
      "description": "The temperature in K used to initialize the velocities of the atoms in this region",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION"
      ]
    }, {
      "description": "If ENSEMBLE is set to LANGEVIN, controls whether the atoms NOT defined in the thermal regions to undergo langevin MD or not. If not, then the atoms will undergo NVE Born-Oppenheimer MD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMAL_REGION.DO_LANGEVIN_DEFAULT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION"
      ]
    }, {
      "description": "Control the rescaling ot the velocities in all the regions, according to the temperature assigned to each reagion, when RESTART_VELOCITY in EXT_RESTART is active.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMAL_REGION.FORCE_RESCALING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION"
      ]
    }, {
      "description": "Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.CHI.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.CHI"
      ]
    }, {
      "description": "Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.MASS"
      ]
    }, {
      "description": "Time constant of the Langevin part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.TIMECON_LANGEVIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.TIMECON_NH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.CSVR.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR.RNG_INIT"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.CSVR.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "Time constant of the CSVR thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.CSVR.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Specifies a list of atoms to thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.DEFINE_REGION.LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.DEFINE_REGION.MM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "Specifies the name of the molecules to thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.DEFINE_REGION.MOLNAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.DEFINE_REGION.QM_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.DEFINE_REGION"
      ]
    }, {
      "description": "A matrix The defaults give optimal sampling for most cristalline and liquid compounds. Generated with the parameters set kv_4-4.acentered on w_0=40 cm^-1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.A_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "scaling factor for matrix A (for generic matrix A, depends on the characteristic frequency of the system).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.A_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "C matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.C_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Size of the gle matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.NDIM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE.RNG_INIT"
      ]
    }, {
      "description": "Specify s variable for GLE thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.S.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE.S"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.GLE.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.COORD"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.FORCE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.FORCE"
      ]
    }, {
      "description": "length of the Nose-Hoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify masses of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.MASS.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.MASS"
      ]
    }, {
      "description": "number of multiple timesteps to be used for the NoseHoover chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.MTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "timeconstant of the thermostat chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.TIMECON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.VELOCITY"
      ]
    }, {
      "description": "order of the yoshida integretor used for the thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.NOSE.YOSHIDA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "Determines the region each thermostat is attached to.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.REGION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "Specify the thermostat used for the constant temperature ensembles.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.THERMOSTAT.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "The starting timer value for the MD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.TIME_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The length of an integration step (in case RESPA the large TIMESTEP)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.TIMESTEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Mixing factor used for updating velocities.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.VELOCITY_SOFTENING.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.VELOCITY_SOFTENING"
      ]
    }, {
      "description": "Displacement used to obtain y.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.VELOCITY_SOFTENING.DELTA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.VELOCITY_SOFTENING"
      ]
    }, {
      "description": "Number of softening iterations performed. Typical values are around 40 steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.MD.VELOCITY_SOFTENING.STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.VELOCITY_SOFTENING"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.BEADS.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.BEADS.COORD"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.BEADS.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.BEADS.VELOCITY"
      ]
    }, {
      "description": "timestep (might be subdivised in nrespa subtimesteps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.DT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Propagate all DOF but the centroid - useful for equilibration of the non-centroid modes (activated only if TRANSFORMATION==NORMAL)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.FIX_CENTROID_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "A matrix The defaults give optimal sampling for most cristalline and liquid compounds. Generated with the parameters set kv_4-4.acentered on w_0=40 cm^-1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.A_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "scaling factor for matrix A (for generic matrix A, depends on the characteristic frequency of the system).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.A_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "C matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.C_LIST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "Size of the gle matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.NDIM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "Specify an initial RNG stream record",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.RNG_INIT.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE.RNG_INIT"
      ]
    }, {
      "description": "Specify s variable for GLE thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.S.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE.S"
      ]
    }, {
      "description": "Specify an initial thermostat energy for CSVR thermostat.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.GLE.THERMOSTAT_ENERGY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE.THERMOSTAT_ENERGY"
      ]
    }, {
      "description": "how many time slices to change at once (+1). Must be a power of 2 currently",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.BISECTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "PBC unit cell shape for helium",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.CELL_SHAPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "PBC unit cell size (NOTE 1: density, number of atoms and volume are interdependent - give only two of them; NOTE 2: for small cell sizes specify NATOMS instead)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.CELL_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.COORD"
      ]
    }, {
      "description": "trial density of helium for determining the helium box size",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Drop He environments if N_restart > N_runtime (Warning: this will cause data loss in the restart file!)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.DROP_UNUSED_ENVS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Number of real values should be 3 * <num_solute_atoms> * <num_solute_beads>",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.FORCE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.FORCE"
      ]
    }, {
      "description": "Simulate helium solvent only, disregard solute entirely",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.HELIUM_ONLY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Number of MC iterations at the same time slice(s)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.INOROT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "how often to reselect the time slice(s) to work on",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.IROT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Probability ratio betw M-VALUE and other cycle lengths",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.M-SAMPLING.M-RATIO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.M-SAMPLING"
      ]
    }, {
      "description": "Value of m treated in a special way",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.M-SAMPLING.M-VALUE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.M-SAMPLING"
      ]
    }, {
      "description": "how large cyclic permutations to try",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.MAX_PERM_CYCLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Number of helium atoms",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.NATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Number of helium path integral beads",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.NBEADS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Number of independent helium environments (only for restarts, do not set explicitly)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.NUM_ENV",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Use periodic boundary conditions for helium",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Specify particle index permutation for every helium atom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.PERM.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.PERM"
      ]
    }, {
      "description": "Name of the Helium interaction potential file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.POTENTIAL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Presample He coordinates before first PIMD step",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.PRESAMPLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Maximum RDF range, defaults to unit cell size",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RDF.MAXR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RDF"
      ]
    }, {
      "description": "Number of bins",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RDF.NBIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RDF"
      ]
    }, {
      "description": "Cubefile data",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RHO.CUBE_DATA.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO.CUBE_DATA"
      ]
    }, {
      "description": "Weight the restarted density should be given (number of MC steps used to average the restarted density, negative value - the same weight as the run-time density, usually should not be changed)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RHO.IWEIGHT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO"
      ]
    }, {
      "description": "Number of bins",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RHO.NBIN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO"
      ]
    }, {
      "description": "Whether or not to actually calculate densities (requires significant amount of memory, depending on the value of NBIN)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RHO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO"
      ]
    }, {
      "description": "Three real arrays of DIMENSION(3,2) times two RNG streams - 36 real values per processor",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.RNG_STATE.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RNG_STATE"
      ]
    }, {
      "description": "Whether or not to actually use this section",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.HELIUM.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "adds random velocity component to the centroid modes (useful to correct for the averaging out of the speed of various beads)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.CENTROID_SPEED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "Use the same Levy path for all atoms, though with mass-dependent variances (might help at very low T)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.LEVY_CORRELATED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "Sample bead positions assuming free particle behavior (performs a Levy random walk of length P around the classical position of each atom at the physical temperature defined in PINT%TEMP)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.LEVY_POS_SAMPLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "Initial seed for the (pseudo)random number generator that controls Levy walk for bead positions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.LEVY_SEED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "Multiplicative correction factor for the temperature at which the Levy walk is performed (correction is due to the interactions that modify the spread of a free particle)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.LEVY_TEMP_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "add gaussian noise to the positions of the beads",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.RANDOMIZE_POS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "set the initial velocities to zero",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.VELOCITY_QUENCH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "scale initial velocities to the temperature given in MOTION%PINT%TEMP",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.INIT.VELOCITY_SCALE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.INIT"
      ]
    }, {
      "description": "Specify the iteration number from which it should be counted",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.ITERATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Maximum step number (the program will stop if ITERATION >= MAX_STEP even if NUM_STEPS has not been reached)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.MAX_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "mass scale factor for non-centroid degrees of freedom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NORMALMODE.MODEFACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NORMALMODE"
      ]
    }, {
      "description": "Value of the thermostat mass of non-centroid degrees of freedom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NORMALMODE.Q_BEAD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NORMALMODE"
      ]
    }, {
      "description": "Value of the thermostat mass of centroid degree of freedom",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NORMALMODE.Q_CENTROID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NORMALMODE"
      ]
    }, {
      "description": "Specify positions of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NOSE.COORD.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NOSE.COORD"
      ]
    }, {
      "description": "length of nose-hoover chain. 0 means no thermostat",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NOSE.NNOS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NOSE"
      ]
    }, {
      "description": "Specify velocities of the system",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NOSE.VELOCITY.DEFAULT_KEYWORD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NOSE.VELOCITY"
      ]
    }, {
      "description": "number of respa steps for the bead for each md step",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NRESPA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Number of steps (if MAX_STEP is not explicitly given the program will perform this number of steps)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.NUM_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Specify number of processors to use for each replica",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.PROC_PER_REPLICA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Specify number beads to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.P",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Value of the j parameter for the staging transformation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.STAGING.J",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.STAGING"
      ]
    }, {
      "description": "Value of the nose-hoover mass for the endbead (Q_end)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.STAGING.Q_END",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.STAGING"
      ]
    }, {
      "description": "threshold for the oscillations of the temperature excedeed which the temperature is rescaled. 0 means no rescaling.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.T_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "The temperature you want to simulate",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.TEMP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Specifies the coordinate transformation to use",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PINT.TRANSFORMATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CELL.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "Specifies the format of the output file for the forces on cores.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_FORCES.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the BETA field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.CHARGE_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the very last field of the PDB file (starting from column 81)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.CHARGE_EXTENDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the OCCUP field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.CHARGE_OCCUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Specifies the format of the output file for the trajectory of cores.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_TRAJECTORY.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "Specifies the format of the output file for the velocities of cores.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.CORE_VELOCITIES.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "Specifies the format of the output file for the force mixing labels.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCE_MIXING_LABELS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "Specifies the format of the output file for the forces.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.FORCES.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.MIXED_ENERGIES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "Specifies the maximum number of backup copies.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.BACKUP_COPIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "If specified selected input sections, which are growing with the number of atoms in the system, are written to another restart file in binary format instead of the default restart file in human readable ASCII format. This split of the restart file may provide significant memory savings and an accelerated I/O for systems with a very large number of atoms",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART.SPLIT_RESTART_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.RESTART_HISTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "Specifies the format of the output file for the forces on shells.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_FORCES.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the BETA field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.CHARGE_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the very last field of the PDB file (starting from column 81)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.CHARGE_EXTENDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the OCCUP field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.CHARGE_OCCUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Specifies the format of the output file for the trajectory of shells.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_TRAJECTORY.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "Specifies the format of the output file for the velocities of shells.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.SHELL_VELOCITIES.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRESS.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Print the angle formed by the atoms specified by their indices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.ANGLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Print the dihedral angle between the planes defined by the atoms (a,b,c) and the atoms (b,c,d) specified by their indices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.DIHEDRAL_ANGLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Print the distance between the atoms a and b specified by their indices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.DISTANCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Print the position vectors in scaled coordinates of the atoms specified by a list of their indices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.POSITION_SCALED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Print the position vectors in Cartesian coordinates of the atoms specified by a list of their indices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.POSITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.STRUCTURE_DATA.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the BETA field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.CHARGE_BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the very last field of the PDB file (starting from column 81)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.CHARGE_EXTENDED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Write the MM charges to the OCCUP field of the PDB file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.CHARGE_OCCUP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Specifies the format of the output file for the trajectory.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRAJECTORY.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.TRANSLATION_VECTOR.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "Iteration level for the Band Calculation Steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.BAND",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Basis Set Superposition Error (BSSE) Calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.BSSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Cell optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.CELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Energy Perturbation (EP) linear solver",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.EP_LIN_SOLVER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Geometry optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.GEO_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for an ENERGY/ENERGY_FORCE calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.JUST_ENERGY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the MD steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.MD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the METADYNAMICS steps (number of hills added).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.METADYNAMICS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for POWELL based optimization steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.POWELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.QS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the evaluation of the Replica Environment",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.REPLICA_EVAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Rotational optimization steps in the Dimer Calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.ROT_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the Shell-Core distances optimization steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.SHELL_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the solution of the coefficients of the splines",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.SPLINE_FIND_COEFFS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": "Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.EACH.XAS_SCF",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "Specifies the format of the output file for the velocities.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.FORMAT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.PRINT.VELOCITIES.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS.RESTART"
      ]
    }, {
      "description": "Specifies the name of the file used to read the initial Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS"
      ]
    }, {
      "description": "Controls the reading of the initial Hessian from file.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.RESTART_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS"
      ]
    }, {
      "description": "Trust radius used in BFGS. Previously set to 0.1. Large values can lead to instabilities",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.TRUST_RADIUS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS"
      ]
    }, {
      "description": "Uses a model Hessian as initial guess instead of a unit matrix. Should lead in general to improved convergence might be switched off for exotic cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.USE_MODEL_HESSIAN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS"
      ]
    }, {
      "description": "Includes a rational function optimization to determine the step. Previously default but did not improve convergence in many cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.BFGS.USE_RAT_FUN_OPT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS"
      ]
    }, {
      "description": "Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate Gradients",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.FLETCHER_REEVES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG"
      ]
    }, {
      "description": "Use only the gradient, not the energy for line minimizations (e.g. in conjugate gradients).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.2PNT.LINMIN_GRAD_ONLY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Max allowed value for the line search step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.2PNT.MAX_ALLOWED_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.2PNT"
      ]
    }, {
      "description": "Limit in 1D bracketing during line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD.BRACK_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Maximum number of iterations in brent algorithm (used for the line search in Conjugated Gradients Optimization)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD.BRENT_MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Tolerance requested during Brent line search in Conjugate Gradients Optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD.BRENT_TOL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "Initial step size used, e.g. for bracketing or minimizers. Might need to be reduced for systems with close contacts",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD.INITIAL_STEP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD"
      ]
    }, {
      "description": "1D line search algorithm to be used with the CG optimizer, in increasing order of robustness and cost.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Maximum number of steepest descent steps before starting the conjugate gradients optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.MAX_STEEP_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG"
      ]
    }, {
      "description": "Cosine of the angle between two consecutive searching directions. If the angle during a CG optimization is less than the one corresponding to  to the RESTART_LIMIT the CG is reset and one step of steepest descent is  performed.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.CG.RESTART_LIMIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG"
      ]
    }, {
      "description": "Maximum number of force evaluations per iteration(used for the line search)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.LBFGS.MAX_F_PER_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.LBFGS"
      ]
    }, {
      "description": "Maximum rank (and consequently size) of the approximate Hessian matrix used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate the convergence behaviour at the cost of a larger memory consumption.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.LBFGS.MAX_H_RANK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested norm threshold of the gradient multiplied by the approximate Hessian.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.LBFGS.WANTED_PROJ_GRADIENT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium (overrides the general ones):Requested relative error on the objective functionof the optimizer (the energy)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.LBFGS.WANTED_REL_F_ERROR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.LBFGS"
      ]
    }, {
      "description": "Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.MAX_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Convergence criterium for the maximum force component of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.MAX_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Specify which method to use to perform a geometry optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.OPTIMIZER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.RMS_DR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Convergence criterium for the root mean square (RMS) force of the current configuration.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.RMS_FORCE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "The starting step value for the SHELL_OPT module.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.SHELL_OPT.STEP_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "file name for printing every single calculated configuration (e.g. for fitting).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.ALL_CONF_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "file name for GrapgViz dot file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.DOT_TREE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "input file name for the exact potential energy calculation.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.ENERGY_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "set the estimation of the acceptance probability using run time information of the energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.ESIMATE_ACC_PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "amount of groups (cores) for analysing the configurations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.GROUP_ANLYSIS_NR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "amount of of CPUs per group for configurational change",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.GROUP_CC_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "amount of groups for exact energy calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.GROUP_ENERGY_NR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "amount of CPUs per group for energy calculation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.GROUP_ENERGY_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "the number the amount of calculated configurations between to output printings.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.INFO_OUT_STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Moves the center of mass of defined molecules (in volume moves)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.MOVE_CENTER_OF_MASS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the move. Up to now only used for the atom swap.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.MOVE_TYPE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the initial probability of accepting the move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.MOVE_TYPE.INIT_ACC_PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the probability of the move (considering the ration between the selected moves)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.MOVE_TYPE.PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.MOVE_TYPE"
      ]
    }, {
      "description": "The name of the move type described in this section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.MOVE_TYPE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the size of the move:ATOM_TRANS [A], MOL_TRANS [A], MOL_ROT [degree], PROT_REORDER [], VOL_MOVE [A], ATOM_SWAP",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.MOVE_TYPE.SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the initial probability of accepting the move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.INIT_ACC_PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES"
      ]
    }, {
      "description": "Defines the atomic kinds involved in the move. Up to now only used for the atom swap.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the initial probability of accepting the move.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE.INIT_ACC_PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the probability of the move (considering the ration between the selected moves)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE.PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE"
      ]
    }, {
      "description": "The name of the move type described in this section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE"
      ]
    }, {
      "description": "Defines the size of the move:ATOM_TRANS [A], MOL_TRANS [A], MOL_ROT [degree], PROT_REORDER [], VOL_MOVE [A], ATOM_SWAP",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE.SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE"
      ]
    }, {
      "description": "input file name for the approximate potential for Nested Monte Carlo.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.NMC_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES"
      ]
    }, {
      "description": "the number of Nested Mont Carlo moves with in one MC move should be huge enough to reach euilibrium state",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.NR_NMC_STEPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES"
      ]
    }, {
      "description": "Defines the probability of the NMC move (considering the ration between the selected other moves)the probabilities of the move types in the NMC section defines only the weight within the NMC steps",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NMC_MOVES.PROB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES"
      ]
    }, {
      "description": "the number of different temperature for parallel tempering",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NR_TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "the minimum Markov Chain elements, to be sampled",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NUM_MC_ELEM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "the number of elements (atoms or molecules) moves in cell or sub box.if 0 all elements are moved once in a MC move",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.NUM_MV_ELEM_IN_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "enables NPT calculation with specified constant pressure [bar]",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRESSURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "printing the cell vectors of the Markov Chain elements",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_CELL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "printing coordinates of the Markov Chain elements",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_COORDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "enables the calculation and printing the exact cell dipoles (only for QS methods)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_DIPOLE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "printing the different calculated energies (approximated, scf and exact)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_ENERGIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "printing forces of the Markov Chain elements",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_FORCES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "printing only accepted elements of the Markov Chain.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_ONLY_ACC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "printing different values for regtest comparison",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.PRINT_TEST_OUTPUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "if existing use the last restart file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.RESTART_IN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Defines the frequency to write restart files. If no frequency is specified (lone keyword) the restart file is written at the end (only). If the value is 0, no restart file is written at all. The frequency specifies is related to the calculated Markov chain elements",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.RESTART_OUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "enables the storing of the whole Markov Chain",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.RESULT_LIST_IN_MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "the initialisation number for the random number generator",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.RND_DETERMINISTIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "enables or disables the speculative canceling. If we have further knowledge of acceptance probabilities using parent acceptance or the estimated energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.SPECULATIVE_CANCELING",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "specifies the size ot the sub box. Standard moves only within subbox of random position, to compensate the potential difference of the approximate potential.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.SUB_BOX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Select specialized types. Selectable:IDEAL_GAS (constant configuration energy E=0.0),",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TASK_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "one temperatue OR for parallel tempering: Tmin Tmax or each temperature T1 T2 T3 ... If every single temperature is specified, do NOT use keyword NR_TEMPERATURE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Defines the atomic kind of the charge.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.CHARGE.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS.CHARGE"
      ]
    }, {
      "description": "Defines the charge of the MM atom in electron charge unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.CHARGE.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS.CHARGE"
      ]
    }, {
      "description": "calculates the classical dipole Moment. Following flag specifies if they should be written. Class. Dip. Mom. are also used to unfold the exact dipole moment.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.CLASSICAL_DIPOLE_MOMENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "Mass density in the simulation cell, or if specified in sub cubes",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "Calculates the deviation of the position from the last configuration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.DEVIATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "Enables analysis of dipole moments, espacially dielectric constant. An additional type can be specified, e.g. analyzing ice structures.using SYM_XYZ also dipoles (-x,y,z) .. .. (-x,-y,z).... (-x,-y-z) are regarded, only use it if this configurations have all the same energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.DIPOLE_ANALYSIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "Radial Distribution Function for each pair of atomsusing the amount of specified bins within MAX(cell_lenght)/2",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.G_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "specifies a prefix for all analysis files.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.PREFIX_ANA_FILES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "Enables/disables the reading and writing of  analysis restart files",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "file name for analysing the cell file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.CELL_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Defines the atomic kind of the charge.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.CHARGE.ATOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES.CHARGE"
      ]
    }, {
      "description": "Defines the charge of the MM atom in electron charge unit.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.CHARGE.CHARGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES.CHARGE"
      ]
    }, {
      "description": "calculates the classical dipole Moment. Following flag specifies if they should be written. Class. Dip. Mom. are also used to unfold the exact dipole moment.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.CLASSICAL_DIPOLE_MOMENTS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Mass density in the simulation cell, or if specified in sub cubes",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.DENSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Calculates the deviation of the position from the last configuration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.DEVIATION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Enables analysis of dipole moments, espacially dielectric constant. An additional type can be specified, e.g. analyzing ice structures.using SYM_XYZ also dipoles (-x,y,z) .. .. (-x,-y,z).... (-x,-y-z) are regarded, only use it if this configurations have all the same energy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.DIPOLE_ANALYSIS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "file name for analysing the dipole file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.DIPOLE_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Analysing multiple directories, created by standard parallel MC (e.g. using TMC farming",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.DIRECTORIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "end analysis at element with number #",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.END_ELEM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "input file name for force env, to get initial configuration with dimensions and cell",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.FORCE_ENV_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Radial Distribution Function for each pair of atomsusing the amount of specified bins within MAX(cell_lenght)/2",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.G_R",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "the number of different temperature for parallel tempering",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.NR_TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "file name for analysing the position file",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.POSITION_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "specifies a prefix for all analysis files.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.PREFIX_ANA_FILES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Enables/disables the reading and writing of  analysis restart files",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.RESTART",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "start analysis at element with number #",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.START_ELEM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "one temperatue OR for parallel tempering: Tmin Tmax or each temperature T1 T2 T3 ... If every single temperature is specified, do NOT use keyword NR_TEMPERATURE",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.TMC_ANALYSIS_FILES.TEMPERATURE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "enables or disables the usage of SCF energy information for  estimating the acceptance probability.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.USE_SCF_ENERGY_INFO",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "volume move is equal in each direction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MOTION.TMC.VOLUME_ISOTROPIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Specify the orders of the different force_eval. When using a MIXED force_eval this does not need to be specified in this list, because it that takes into account only the real energy contributions",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MULTIPLE_FORCE_EVALS.FORCE_EVAL_ORDER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MULTIPLE_FORCE_EVALS"
      ]
    }, {
      "description": "Specify if force_eval have different subsys. In case they share the same subsys, it needs to be specified only in the MIXED force_eval (if using MIXED) or in the force_eval corresponding to first force_eval of the previous order (when not using MIXED).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_MULTIPLE_FORCE_EVALS.MULTIPLE_SUBSYS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_MULTIPLE_FORCE_EVALS"
      ]
    }, {
      "description": "If multiple atomic kinds are fitted at the same time, this keyword allows to specify which basis sets should be used together in optimization (underived set ID=0). If skipped all combinations are used. The order is taken as the kinds and sets are specified in the input",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.BASIS_COMBINATIONS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "Name of the basis set file containing the optimized basis",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.BASIS_OUTPUT_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "Name of the basis set file, containing the structure of the new basis set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.BASIS_TEMPLATE_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "Name of the basis set file which is created to be read as initial guess",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.BASIS_WORK_FILE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "This keyword allows to give different weight factors to the condition number of different basis combinations (LOG(cond) is used). The first entry corresponds to the original basis sets. Every further value is assigned to the combinations in the order given for BASIS_COMBINATIONS.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.CONDITION_WEIGHT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "The name of the basis set for the kind. Has to be specified in BASIS_TEMPLATE_FILE.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.BASIS_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "Defines the boundaries to which the optimization is restricted. First value is the lower bound, second value is the upper bound.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS.BOUNDARIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS"
      ]
    }, {
      "description": "Defines the maximum fractionr by which the exponent is allowed to vary. e.g. 0.5 allows the exp to vary by 0.5*exp in both directions.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS.MAX_VAR_FRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS"
      ]
    }, {
      "description": "Defines the exponent to be constraint. The two integers indicate the set number and i'th exponent. The value -1 can be used to mark all sets/expoenents in a set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS.USE_EXP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS"
      ]
    }, {
      "description": "Specifies the reference basis ID which is used as template to create the new set. The original basis has ID 0. All follwing sets are counted in order as specified in the Input. The decriptors always assume the structure of the input basis set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS.REFERENCE_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS"
      ]
    }, {
      "description": "Can be used to remove a contraction from the reference basis set. The contraction is speciefied by set number, angular momentum and number of contraction. The decriptors always assume the structure of the input basis set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS.REMOVE_CONTRACTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS"
      ]
    }, {
      "description": "Can be used to remove a set from the reference basis set.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS.REMOVE_SET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS"
      ]
    }, {
      "description": "Specifies the initial degrees of freedom in the basis optimization.This can be used to make further specifications easier",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.INITIAL_DEGREES_OF_FREEDOM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "The name of the kind described in this section.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "Allows to switch the state of a given coefficient from current state (varibale/fixed)) to the opposite state. The three integers indicate the set number, the angular momentum i'th contraction and i'th coefficient",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.SWITCH_COEFF_STATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "Allows to switch the state of a given contraction from current state (varibale/fixed)) to the opposite state. The three integers indicate the set number, the angular momentum and i'th contraction",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.SWITCH_CONTRACTION_STATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "Allows to switch the state of a given exponent from current state (varibale/fixed)) to the opposite state. The two integers indicate the set number and i'th exponent",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.SWITCH_EXP_STATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "Allows to switch the states of in a set from current state (varibale/fixed)) to the opposite state. The two integers indicate the affected part (0=ALL,1=EXPS,2=COEFF) and i'th set",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.FIT_KIND.SWITCH_SET_STATE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "Allows the specification of the group mpi group sizes in parallel runs. If less Groups than tasks are speciefied, consecutive calculations  Will be assigned to one group (derived basis sets and then training sets) If keyword is skipped, equal group sizes will be generated trying to fit all calculations.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.GROUP_PARTITION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "Final accuracy requested in optimization (RHOEND)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.OPTIMIZATION.ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.OPTIMIZATION"
      ]
    }, {
      "description": "Maximum number of function evaluations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.OPTIMIZATION.MAX_FUN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.OPTIMIZATION"
      ]
    }, {
      "description": "Initial step size for search algorithm (RHOBEG)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.OPTIMIZATION.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.OPTIMIZATION"
      ]
    }, {
      "description": "This keyword allows to give different weight factors to the residuum of the different basis combinations. The first entry corresponds to the original basis sets. Every further value is assigned to the combinations in the order given for BASIS_COMBINATIONS.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.RESIDUUM_WEIGHT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "the directory in which the files are placed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.TRAINING_FILES.DIRECTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.TRAINING_FILES"
      ]
    }, {
      "description": "the filename of the input file used to run the original calcuation",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.TRAINING_FILES.INPUT_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.TRAINING_FILES"
      ]
    }, {
      "description": "Determines whether condition number should be part of optimization or not",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.USE_CONDITION_NUMBER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "Frequency at which the intermediate results should be written",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_BASIS.WRITE_FREQUENCY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "Final accuracy requested in optimization (RHOEND)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.ACCURACY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES"
      ]
    }, {
      "description": "Relative weight of the energy RMSD vs the force RMSD",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.ENERGY_WEIGHT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "Use at most FRAME_COUNT frames from the reference trajectory, adjusting the stride to have them as fas apart as possible (all=-1).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.FRAME_COUNT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "starting frame to be used from the reference trajectory",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.FRAME_START",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "final frame to be used from the reference trajectory (all=-1)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.FRAME_STOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "stride when using the reference trajectory",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.FRAME_STRIDE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "Gives the preferred size of a working group, groups will always be equal or larger than this size.Usually this should take the number of cores per socket into account for good performance.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.GROUP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "the filename of the input file which contains the parameters to be optimized",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.OPTIMIZE_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "the filename of the reference cell",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.REF_CELL_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "the filename of the reference forces, should also contain the energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.REF_FORCE_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "the filename of the reference coordinates.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.REF_TRAJ_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "Shift averages of the energies before computing energy RMSD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.SHIFT_AVERAGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "Shift of the fit energies applied before computing energy RMSD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.SHIFT_MM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "Shift of the reference energies applied before computing energy RMSD.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.FORCE_MATCHING.SHIFT_QM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.HISTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.HISTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.HISTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.HISTORY"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.HISTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.HISTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.HISTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.HISTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.HISTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.HISTORY"
      ]
    }, {
      "description": "Used for restarting, starting value of the iteration",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.ITER_START_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "Maximum number of function evaluations",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.MAX_FUN",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "What kind of input optimization to perform.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "Percentage randomization of the free variables applied initially",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RANDOMIZE_VARIABLES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RESTART.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART"
      ]
    }, {
      "description": "Specifies the maximum index of backup copies.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RESTART.BACKUP_COPIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RESTART.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RESTART.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RESTART.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.RESTART.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART"
      ]
    }, {
      "description": "Initial step size for search algorithm (RHOBEG)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.STEP_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "Is this variable fixed or should it be optimized.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.VARIABLE.FIXED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.VARIABLE"
      ]
    }, {
      "description": "The label used in the input file, i.e. ${LABEL} will be replaced by the VALUE specified.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.VARIABLE.LABEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.VARIABLE"
      ]
    }, {
      "description": "Initial value of the variable",
      "dtypeStr": "C",
      "name": "x_cp2k_input_OPTIMIZE_INPUT.VARIABLE.VALUE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.VARIABLE"
      ]
    }, {
      "description": "Which behaviour should control the swarm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.BEHAVIOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM"
      ]
    }, {
      "description": "Number of MD steps with potential energy decreases required for a bump.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.BUMP_STEPS_DOWNWARDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Number of MD steps with potential energy increases required for a bump.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.BUMP_STEPS_UPWARDS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Target Energy, the optimization will quit once a lower potential energy is reached.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.E_TARGET",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Threshold for atom distance used for detecting fragmentation of clusters.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.FRAGMENTATION_THRESHOLD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "If the difference of two energies is below this threshold they are considert equal.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.HISTORY.ENERGY_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.HISTORY"
      ]
    }, {
      "description": "If the euclidean distance of two fingerprints is below this threshold, they are considert equal.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.HISTORY.FINGERPRINT_PRECISION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.HISTORY"
      ]
    }, {
      "description": "Number of bumps in potential energy after which MD runs ends.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MD_BUMPS_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Methods to use for optimization.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Number of escapes averaged for scoring of minima.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.ESCAPE_HISTORY_LENGTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY"
      ]
    }, {
      "description": "Initial width of temperature distribution.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.TEMPDIST_INIT_WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Height of gaussian used to update temperature distribution.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.TEMPDIST_UPDATE_HEIGHT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Width of gaussian used to update temperature distribution.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.TEMPDIST_UPDATE_WIDTH",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Initial temperature in Kelvin",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.TEMPERATURE_INIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Base used to calculate temperature steps base**n",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.TEMPSTEP_BASE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Maximum number of temperature steps.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.TEMPSTEP_MAX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Maximum number of active workers per Minima.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.WORKER_PER_MINIMA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Factor used to decrease acceptance energy, when minima was accepted, should be smaller than 1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.ALPHA_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "Factor used to increase acceptance energy, when minima was rejected, should be larger than 1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.ALPHA_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "Factor used to increase temperature when escape failed, should be larger than 1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.BETA_1",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "Factor used to increase temperature when escape found known minima, should be larger than 1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.BETA_2",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "Factor used to decrease temperature when escape succeeded, should be smaller than 1.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.BETA_3",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "Initial value of acceptance energy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.E_ACCEPT_INIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "If set all worker will use a single share history of visited minima.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.SHARE_HISTORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "Initially temperature in Kelvin",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING.TEMPERATURE_INIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY"
      ]
    }, {
      "description": "Specify the unit of measurement for the quantity in output. All available CP2K units can be used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY.UNIT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY"
      ]
    }, {
      "description": "The maximum number iterations the master should perform",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.MAX_ITER",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM"
      ]
    }, {
      "description": "Number of workers used for swarm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.NUMBER_OF_WORKERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM"
      ]
    }, {
      "description": "Filename of communication log of previous run. Use this to restart a swarm.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_SWARM.REPLAY_COMMUNICATION_LOG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_SWARM"
      ]
    }, {
      "description": "Tests the Clebsch-Gordon Coefficients. Tests are repeated the given number of times.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CLEBSCH_GORDON",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Tests the performance to copy two vectors.The results of these tests allow to determine the size of the cache of the CPU. This can be used to optimize the performance of theFFTSG library. Tests are repeated the given number of times.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.COPY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Multiplication factor",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.ALPHA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "perform a checksum after each multiplication",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.ALWAYS_CHECKSUM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Sparsity of A matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.ASPARSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Matrix A type",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.ATYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Product premultiplication factor",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.BETA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Block sizes of inner dimension",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.BS_K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Row block sizes of C",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.BS_M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Column block sizes of C",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.BS_N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Sparsity of B matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.BSPARSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Matrix B type",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.BTYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Sparsity of C matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.CSPARSITY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Matrix C type",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.CTYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Data type of the matrices",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.DATA_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Threshold for on-the-fly and final filtering.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.FILTER_EPS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Keep product sparse",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.KEEPSPARSE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Inner dimension M",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Dimension 1 of C",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Number of operations being timed (useful for small matrices).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.N_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Number of processors to test",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.NPROC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Dimension 2 of C",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Which part of DBCSR is tested",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.TEST_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Transpose matrix A",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.TRANSA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Transpose matrix B",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_DBCSR.TRANSB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_DBCSR"
      ]
    }, {
      "description": "Forces the blocksize, even if this implies that a few processes might have no data",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.FORCE_BLOCKSIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Explicitly set the blacs 2D processor layout. If the product differs from the number of MPI ranks, it is ignored and a default nearly square layout is used.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.GRID_2D",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Dimension 1 of C",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.K",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Inner dimension M",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.M",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Number of cp_fm_gemm operations being timed (useful for small matrices).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.N_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "block_size for cols",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.NCOL_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "block_size for rows",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.NROW_BLOCK",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Dimension 2 of C",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Use a row major blacs grid",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.ROW_MAJOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Transpose matrix A",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.TRANSA",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Transpose matrix B",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.CP_FM_GEMM.TRANSB",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.CP_FM_GEMM"
      ]
    }, {
      "description": "Tests the performance of different kinds of matrix matrix multiply kernels for the BLAS INTRINSIC DGEMM. Matrices up to 2**N+1 will be tested.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.DGEMM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Diagonalization strategy",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.EIGENSOLVER.DIAG_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.EIGENSOLVER"
      ]
    }, {
      "description": "number of eigenvalues to be computed (all=<0)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.EIGENSOLVER.EIGENVALUES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.EIGENSOLVER"
      ]
    }, {
      "description": "Initialization approach",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.EIGENSOLVER.INIT_METHOD",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.EIGENSOLVER"
      ]
    }, {
      "description": "Number of operations being timed (useful for small matrices).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.EIGENSOLVER.N_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.EIGENSOLVER"
      ]
    }, {
      "description": "Dimension of the square matrix",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.EIGENSOLVER.N",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.EIGENSOLVER"
      ]
    }, {
      "description": "Tests the performance and correctness of ERI libraries",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.ERI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Tests the performance of all available FFT libraries for 3D FFTs Tests are repeated the given number of times.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.FFT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.GRID_INFORMATION.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.GRID_INFORMATION"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.GRID_INFORMATION.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.GRID_INFORMATION"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.GRID_INFORMATION.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.GRID_INFORMATION"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.GRID_INFORMATION.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.GRID_INFORMATION"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.GRID_INFORMATION.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.GRID_INFORMATION"
      ]
    }, {
      "description": "Tests the performance of different kinds of matrix matrix multiply kernels for the F95 INTRINSIC matmul. Matrices up to 2**N+1 will be tested.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.MATMUL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Set the maximum amount of memory allocated for a given test (in bytes)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.MEMORY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Tests mpi, quickly adapted benchmark code,will ONLY work on an even number of CPUs. comm is the relevant, initialized communicator. This test will produce messages of the size 8*10**requested_size, where requested_size is the value given to this keyword",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.MPI",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "If the last iteration should be added, and if it should be marked symbolically (with lowercase letter l) or with the iteration number. Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PROGRAM_RUN_INFO.ADD_LAST",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PROGRAM_RUN_INFO.COMMON_ITERATION_LEVELS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": " controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PROGRAM_RUN_INFO.FILENAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PROGRAM_RUN_INFO.LOG_PRINT_KEY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Level starting at which this proprety is printed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PROGRAM_RUN_INFO.SECTION_PARAMETERS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Do the FFT in debug mode in all cases",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.DEBUG",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": "Specify the number of grid points (not all grid points are allowed)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": "Number of pw_transfers (backward&forward) being timed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.N_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": "Expert use only, leave the default...Can be used to set the distribution in g-space for the pw grids and their FFT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.PW_GRID_BLOCKED",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": "loop overal all PW_GRID_LAYOUTs that are compatible with a given number of CPUs",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.PW_GRID_LAYOUT_ALL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": "Expert use only, leave the default...Can be used to set the distribution for ray-distributed FFT.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.PW_GRID_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": "What kind of PW_GRID should be employed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.PW_TRANSFER.PW_GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.PW_TRANSFER"
      ]
    }, {
      "description": " Tests the parallel random number generator (RNG)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RANDOM_NUMBER_GENERATOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Specify the number of grid points (not all grid points are allowed)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.GRID",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER"
      ]
    }, {
      "description": "number of grid points of the halo",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.HALO_SIZE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER"
      ]
    }, {
      "description": "Number of rs_pw_transfers being timed",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.N_LOOP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER"
      ]
    }, {
      "description": "should the direction be rs2pw (pw2rs otherwise)",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS2PW",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER"
      ]
    }, {
      "description": "Specifies the number of slices in the x, y and z directions.-1 specifies that any number of slices is OK.If a given distribution can not be satisfied, a replicated grid will result.Also see LOCK_DISTRIBUTION.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS_GRID.DISTRIBUTION_LAYOUT",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID"
      ]
    }, {
      "description": "Parallelization strategy.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS_GRID.DISTRIBUTION_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID"
      ]
    }, {
      "description": "Can be used to reduce the halo of the distributed grid (experimental features).",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS_GRID.HALO_REDUCTION_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID"
      ]
    }, {
      "description": "Expert use only, only basic QS deals correctly with a non-default value.If the distribution is locked, a grid will have the same distribution asthe next finer multigrid (provided it is distributed).If unlocked, all grids can be distributed freely.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS_GRID.LOCK_DISTRIBUTION",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID"
      ]
    }, {
      "description": "If the multigrid-level of a grid is larger than the parameter, it will not be distributed in the automatic scheme.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS_GRID.MAX_DISTRIBUTED_LEVEL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID"
      ]
    }, {
      "description": "A grid will only be distributed if the memory usage for that grid (including halo) is smaller than a replicated grid by this parameter.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_TEST.RS_PW_TRANSFER.RS_GRID.MEMORY_FACTOR",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID"
      ]
    }, {
      "description": "Specify the increment to be used to construct the HESSIAN with finite difference method",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.DX",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS"
      ]
    }, {
      "description": "Avoids to clean rotations from the Hessian matrix.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.FULLY_PERIODIC",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS"
      ]
    }, {
      "description": "Calculation of the IR-Intensities. Calculation of dipols has to be specified explicitly",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.INTENSITIES",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS"
      ]
    }, {
      "description": "Specifies the list of atoms which should be displaced for the Initial guess",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "Convergence criterium for the davidson algorithm. Specifies the maximal value in the residuum vectors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.EPS_MAX_VAL",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "Convergence criterium for the davidson algorithm. Specifies the maximal value of the norm of the residuum vectors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.EPS_NORM",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "value close to the expected value of the frequency for to look for. If the block Davidson algorithm is applied, the nrep closest frequencies are tracked.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.FREQUENCY",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "The type of initial guess for the normal modes",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.INITIAL_GUESS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "Specifies the list of atoms on which the tracked eigenvector should have the highest value similar to looking for the vibration of a set of atoms",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.INVOLVED_ATOMS.INVOLVED_ATOMS",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.INVOLVED_ATOMS"
      ]
    }, {
      "description": " Specifies the range of wavenumbers in which the modes related to the ATOMS have to be tracked.  If not specified frequencies >400cm-1 will be used to avoid tracking of translational or rotational modes",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.INVOLVED_ATOMS.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.INVOLVED_ATOMS"
      ]
    }, {
      "description": "Track modes in a given range of frequencies. No warranty that the set of frequencies is complete.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.RANGE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "Specifies the name of the file used to create the restarted vectors",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.RESTART_FILE_NAME",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "Specify the number of processors to be used per replica environment (for parallel runs). In case of mode selective calculations more than one replica will start a block Davidson algorithm to track more than only one frequency",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.NPROC_REP",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS"
      ]
    }, {
      "description": "Specify the topology of the mapping of processors into replicas.",
      "dtypeStr": "C",
      "name": "x_cp2k_input_VIBRATIONAL_ANALYSIS.PROC_DIST_TYPE",
      "shape": [],
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS"
      ]
    }, {
      "description": "Section used to specify a general basis set for QM calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.AE_BASIS.BASIS",
      "superNames": [
        "x_cp2k_section_input_ATOM.AE_BASIS"
      ]
    }, {
      "description": "Section of basis set information for all-electron calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.AE_BASIS",
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Section used to specify exernal VXC Potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.EXTERNAL_VXC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD"
      ]
    }, {
      "description": "Parameters for self interation corrected hybrid functionals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.ADIABATIC_RESCALING",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Controls the printing basic info about hf method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.HF_INFO",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "All parameters needed in a HFX RI calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.HFX_RI",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Sets up interaction potential if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Parameters influencing the load balancing of the HF",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.LOAD_BALANCE",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the ERI's if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.MEMORY",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Sets up periodic boundary condition parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Sets up screening parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF.SCREENING",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.HF"
      ]
    }, {
      "description": "Sets up the Hartree-Fock parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.HF",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Information on the non local dispersion functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.NON_LOCAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "Controls the printing of some info about DFTD contributions",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Information on the pair potential to calculate dispersion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL.PAIR_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "This section combines all possible additional dispersion corrections to the normal XC functionals. This can be more functionals or simple empirical pair potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.VDW_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Parameters influencing the solution of the Z-vector equations in MP2 gradients calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.CPHF",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the direct canonical method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.DIRECT_CANONICAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters the interaction potential in computing the biel integrals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Controls the printing basic info about MP2 method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.MP2_INFO",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the optimization of the RI MP2 basis. Only exponents of non-contracted auxiliary basis can be optimized. An initial RI auxiliary basis has to be specified.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.OPT_RI_BASIS",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the RI-SOS-MP2-Laplace method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_LAPLACE",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the RI MP2 method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_MP2",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Controls the printing basic info about hf method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "All parameters needed in a HFX RI calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up interaction potential if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Parameters influencing the load balancing of the HF",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the ERI's if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.MEMORY",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up periodic boundary condition parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up screening parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF.SCREENING",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up the Hartree-Fock parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA.HF",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Parameters influencing the RI RPA method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.RI_RPA",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters for the GPW approach in Wavefunction-based Correlation methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION.WFC_GPW",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Sets up the Wavefunction-based Correlation parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.WF_CORRELATION",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Uses the Becke 88 longrange exchange functional in an adiabatic fashion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 88 longrange exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88_LR",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 88 exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE88",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 97 exchange correlation functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE97",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Becke Roussel exchange hole model. Can be usedas long range correction with a truncated coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BECKE_ROUSSEL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the BEEFvdW exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.BEEF",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the CS1 functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.CS1",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Combination of three different exchange hole models",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.GV09",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the HCTH class of functionals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.HCTH",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses one of the KE_GGA functionals (optimized versions of some of these functionals might be available outside this section). These functionals are needed for the computation of the kinetic energy in the Kim-Gordon method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_GGA",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "To be used for KG runs. Uses kinetic energy functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.KE_LIBXC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "LDA exchange hole model in truncated coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LIBXC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the LYP correlation functional in an adiabatic fashion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP_ADIABATIC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the LYP functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.LYP",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the OPTX functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.OPTX",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the P86C functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.P86C",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PADE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PADE",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "PBE exchange hole model in trucanted coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PBE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PBE",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PerdewWang correlation functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PW92",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PZ functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.PZ81",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TFW functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TFW",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TF functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TF",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TPSS functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.TPSS",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the VWN functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.VWN",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the XALPHA (SLATER) functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XALPHA",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses one of the XGGA functionals (optimized versions of some of these functionals might be available outside this section).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XGGA",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the short range PBE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL.XWPBE",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "The xc functional to use",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_FUNCTIONAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "The xc parameters used when calculating the xc on the grid",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_GRID",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "Uses the SAOP potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL.SAOP",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL"
      ]
    }, {
      "description": "The xc potential to use (CAREFUL: xc potential here refers to potentials that are not derived from an xc functional, but rather are modelled directly. Therefore there is no consistent xc energy available. To still get an energy expression, see ENERGY below",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC.XC_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.XC"
      ]
    }, {
      "description": "parameters needed calculate the xc potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.XC",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD"
      ]
    }, {
      "description": "Section used to specify the restart option in the ZMPprocedure, and the file that must be read.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.ZMP.RESTART",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD.ZMP"
      ]
    }, {
      "description": "Section used to specify ZMP Potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD.ZMP",
      "superNames": [
        "x_cp2k_section_input_ATOM.METHOD"
      ]
    }, {
      "description": "Section of information on method to use.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.METHOD",
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Section of information on optimization thresholds and algorithms.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.OPTIMIZATION",
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Section used to specify Potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.POTENTIAL.GTH_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM.POTENTIAL"
      ]
    }, {
      "description": "Section of information on potential.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Section defines basic parameters for Powell optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.POWELL",
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Section used to specify a general basis set for QM calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.PP_BASIS.BASIS",
      "superNames": [
        "x_cp2k_section_input_ATOM.PP_BASIS"
      ]
    }, {
      "description": "Section of basis set information for pseudopotential calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM.PP_BASIS",
      "superNames": [
        "x_cp2k_section_input_ATOM"
      ]
    }, {
      "description": "Section handling input for atomic calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_ATOM",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Controls the printing of the DEBUG specific output",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_DEBUG.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_DEBUG"
      ]
    }, {
      "description": "Section to setup parameters for debug runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_DEBUG",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Section for external restart, specifies an external input file where to take positions,...",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_EXT_RESTART",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "description of the jobs to be executed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FARMING.JOB",
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "controls the printing of FARMING specific output",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FARMING.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "controls the printing of the restart for FARMING.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FARMING.RESTART",
      "superNames": [
        "x_cp2k_section_input_FARMING"
      ]
    }, {
      "description": "Describes a farming job, in which multiple inputs are executed.\nThe RUN_TYPE in the global section has to be set to NONE for FARMING.\nThe different groups are executed in parallel. The jobs inside the same groups in series.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FARMING",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Specify additional parameters for the combinatorial configurations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.BSSE.CONFIGURATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE"
      ]
    }, {
      "description": "This section contains the energies of the fragments already computed. It is useful as a summary and specifically for restarting BSSE runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.BSSE.FRAGMENT_ENERGIES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE"
      ]
    }, {
      "description": "Specify the atom number belonging to this fragment.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.BSSE.FRAGMENT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.BSSE"
      ]
    }, {
      "description": "This section is used to set up the BSSE calculation. It also requires that for each atomic kind X a kind X_ghost is present, with the GHOST keyword specified, in addition to the other required fields.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.BSSE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Controls the iterative DIIS-accelerated optimization of block-diagonal ALMOs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_DIIS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Controls the PCG optimization of block-diagonal ALMOs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.ALMO_OPTIMIZER_PCG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Controls the PCG optimization of extended ALMOs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF.XALMO_OPTIMIZER_PCG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF"
      ]
    }, {
      "description": "Settings for a class of efficient linear scaling methods based on absolutely localized orbitals (ALMOs). ALMO methods are currently restricted to closed-shell molecular systems.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.ALMO_SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Parameters needed for the ADMM method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.AUXILIARY_DENSITY_MATRIX_METHOD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Controls the printing of basic information during the run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING"
      ]
    }, {
      "description": "Setup parameters for density fitting (Bloechl charges or density derived  atomic point charges (DDAPC) charges)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.DENSITY_FITTING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "parameters for a constant envelop",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.CONSTANT_ENV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "parameters for a gaussian envelop",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.GAUSSIAN_ENV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "Parameters for an trapeziodal envelop",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD.RAMP_ENV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD"
      ]
    }, {
      "description": "parameters for finite, time dependent, nonperiodic electric fields",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EFIELD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Section for the use of the ZMP technique on external densities.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_DENSITY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Section controlling the presence of an electrostatic external potential dependent on the atomic positions (X,Y,Z)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "SCF convergence with external v_xc calculated through previous ZMPcalculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.EXTERNAL_VXC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Specifies the parameters for a Kim-Gordon-like partitioning into molecular subunits",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.KG_METHOD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Sets up the kpoints.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.KPOINTS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Use one of the available methods to define the localization  and possibly to optimize it to a minimum or a maximum.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LOCALIZE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Specify the details of the low spin ROKS method.In particular, one can specify various terms added to the energy of the high spin roks configuration with a energy scaling factor, and a prescription of the spin state.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LOW_SPIN_ROKS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Controls the printing of the Density of States (DOS).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.DOS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV"
      ]
    }, {
      "description": "Controls the printing of cube files with the electronic density (states) contributing to the density of states within the specific energy range (MIN_ENERGY â¤ E â¤ MAX_ENERGY). MIN_ENERGY and MAX_ENERGY need to be specified explicitly.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV.PRINT_SPECIFIC_E_DENSITY_CUBE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV"
      ]
    }, {
      "description": "Specifies the parameters needed for the chebyshev expansion based properties.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CHEBYSHEV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Specifies the parameters of the linear scaling SCF routines",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF.CURVY_STEPS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF"
      ]
    }, {
      "description": "Specifies the parameters of the linear scaling SCF routines",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.LS_SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "Set options that influence how the realspace grids are being distributed in parallel runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID.RS_GRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID"
      ]
    }, {
      "description": "multigrid information",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.MGRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "parameters for finite periodic electric field computed using the Berry phase approach. IMPORTANT: Can only be used in combination  with OT. Can not be used in combination with RTP or EMD.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.PERIODIC_EFIELD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Enables the use of multipoles in the treatment of the electrostatics.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.MULTIPOLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "Set options that influence how the realspace grids are being distributed in parallel runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD.RS_GRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD"
      ]
    }, {
      "description": "Ewald parameters controlling electrostatic only for CLASSICAL MM.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.EWALD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON"
      ]
    }, {
      "description": "Sets up parameters of  Martyna-Tuckerman poisson solver. Note that exact results are only guaranteed if the unit cell is twice as large as charge density (and serious artefacts can result if the cell is much smaller).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON"
      ]
    }, {
      "description": "Controls the checking of the G-space term Spline Interpolation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.CHECK_SPLINE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "controls the interpolation for the G-space term",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "Controls the printing of basic information during the run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "This section is used to set up the decoupling of QM periodic images with the use of density derived atomic point charges.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.MULTIPOLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON"
      ]
    }, {
      "description": "Sets up parameters of  wavelet based poisson solver.This solver allows for non-periodic (PERIODIC NONE) boundary conditions and slab-boundary conditions (but only PERIODIC XZ).It does not require very large unit cells, only that the density goes to zero on the faces of the cell.The use of PREFERRED_FFT_LIBRARY FFTSG is required",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON.WAVELET",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON"
      ]
    }, {
      "description": "Sets up the poisson resolutor.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.POISSON",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT"
      ]
    }, {
      "description": "Use Becke weight population in a restraint/constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.BECKE_RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT"
      ]
    }, {
      "description": "Use DDAPC charges in a restraint (check code for details)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DDAPC_RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Information on where to find DFTB parameters",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB.PARAMETER",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB"
      ]
    }, {
      "description": "Parameters needed to set up the DFTB methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DFTB",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "can be used used to tune the parallel distribution of the data",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.DISTRIBUTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "This section specifies the flags for the calculation of the harris functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.HARRIS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Use mulliken charges in a restraint (check code for details)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.MULLIKEN_RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "specifies constraints for the exponents of the lri auxiliary basis sets in the optimization.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS.CONSTRAIN_EXPONENTS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS"
      ]
    }, {
      "description": "This section specifies the parameters for optimizing the lri auxiliary basis sets for LRIGPW. The Powell optimizer is used.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.OPTIMIZE_LRI_BASIS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Use S2 in a re/constraint (OT only)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.S2_RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Parameters needed to set up the SCPTB methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SCPTB",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "Setup parameters for the evaluation of the COULOMB term in SE calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.COULOMB",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Setup parameters for the evaluation of the EXCHANGE and  core Hamiltonian terms in SE calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.EXCHANGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the integrals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.GA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Setup parameters for the evaluation of the long-range correction term in SE calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.LR_CORRECTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the integrals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.MEMORY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "This section specifies the input parameters for the construction of neighbor lists.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.NEIGHBOR_LISTS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Setup parameters for the tapering of the Coulomb/Exchange Screening in KDSO-D integral scheme,",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE.SCREENING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE"
      ]
    }, {
      "description": "Parameters needed to set up the Semi-empirical methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS.SE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.QS"
      ]
    }, {
      "description": "parameters needed to set up the Quickstep framework",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.QS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Parameters needed to set up the real time propagation for the electron dynamics",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.REAL_TIME_PROPAGATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "parameters needed and setup for relativistic calculations",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.RELATIVISTIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Define the parameters of the dielectric smoothing function proposed by Andreussi et al.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS.ANDREUSSI",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Define the parameters of the dielectric smoothing function proposed by Fattebert and Gygi",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS.FATTEBERT-GYGI",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS"
      ]
    }, {
      "description": "Define the parameters for self-consistent continuum solvation (SCCS) model",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCCS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Settings for DAVIDSON",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DAVIDSON",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Define type and parameters for mixingprocedures to be applied to the density matrix. Normally, only one type of mixing method should be accepted. The mixing procedures activated by this section are only active for diagonalization methods, i.e. not with minimization methods based on OT.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Activation of self-consistenf subspace refinement by diagonalization of H by adjusting the occupation but keeping the MOS unchanged.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.DIAG_SUB_SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Settings for KRYLOV",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.KRYLOV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Sets the various options for the orbital transformation (OT) method. Default settings already provide an efficient, yet robust method. Most systems benefit from using the FULL_ALL preconditioner combined with a small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit from using a DIIS minimizer.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION.OT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Set up type and parameters for Kohn-Sham matrix diagonalization.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.DIAGONALIZATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Define type and parameters for mixingprocedures to be applied to the density matrix. Normally, only one type of mixing method should be accepted. The mixing procedures activated by this section are only active for diagonalization methods, i.e. not with minimization methods based on OT.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.MIXING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Sets the various options for the orbital transformation (OT) method. Default settings already provide an efficient, yet robust method. Most systems benefit from using the FULL_ALL preconditioner combined with a small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit from using a DIIS minimizer.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "parameters controlling the outer SCF loop",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.OUTER_SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "Define the smearing of the MO occupation numbers",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF.SMEAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCF"
      ]
    }, {
      "description": "parameters needed perform an scf run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF"
      ]
    }, {
      "description": "Defines the center of the sphere.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE.CENTER",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE"
      ]
    }, {
      "description": "Treats the implicit solvent environment like a sphere",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF.SPHERE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF"
      ]
    }, {
      "description": "Adds an implicit solvation model to the DFT calculation. Know also as Self Consistent Reaction Field.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SCRF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "parameters for the self interaction correction",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.SIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "parameters for the self interaction correction",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.SIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "Parameters for self interation corrected hybrid functionals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.ADIABATIC_RESCALING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Controls the printing basic info about hf method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HF_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "All parameters needed in a HFX RI calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.HFX_RI",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Sets up interaction potential if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Parameters influencing the load balancing of the HF",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.LOAD_BALANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the ERI's if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.MEMORY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Sets up periodic boundary condition parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Sets up screening parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF.SCREENING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF"
      ]
    }, {
      "description": "Sets up the Hartree-Fock parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.HF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Information on the non local dispersion functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.NON_LOCAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "Controls the printing of some info about DFTD contributions",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Information on the pair potential to calculate dispersion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL.PAIR_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "This section combines all possible additional dispersion corrections to the normal XC functionals. This can be more functionals or simple empirical pair potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.VDW_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Parameters influencing the solution of the Z-vector equations in MP2 gradients calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.CPHF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the direct canonical method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.DIRECT_CANONICAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters the interaction potential in computing the biel integrals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Controls the printing basic info about MP2 method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.MP2_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the optimization of the RI MP2 basis. Only exponents of non-contracted auxiliary basis can be optimized. An initial RI auxiliary basis has to be specified.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.OPT_RI_BASIS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the RI-SOS-MP2-Laplace method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_LAPLACE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the RI MP2 method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_MP2",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Controls the printing basic info about hf method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "All parameters needed in a HFX RI calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up interaction potential if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Parameters influencing the load balancing of the HF",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the ERI's if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up periodic boundary condition parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up screening parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up the Hartree-Fock parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA.HF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Parameters influencing the RI RPA method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.RI_RPA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters for the GPW approach in Wavefunction-based Correlation methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION.WFC_GPW",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Sets up the Wavefunction-based Correlation parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.WF_CORRELATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Uses the Becke 88 longrange exchange functional in an adiabatic fashion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 88 longrange exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88_LR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 88 exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE88",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 97 exchange correlation functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE97",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Becke Roussel exchange hole model. Can be usedas long range correction with a truncated coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the BEEFvdW exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.BEEF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the CS1 functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.CS1",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Combination of three different exchange hole models",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.GV09",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the HCTH class of functionals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.HCTH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses one of the KE_GGA functionals (optimized versions of some of these functionals might be available outside this section). These functionals are needed for the computation of the kinetic energy in the Kim-Gordon method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_GGA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "To be used for KG runs. Uses kinetic energy functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.KE_LIBXC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "LDA exchange hole model in truncated coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LIBXC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the LYP correlation functional in an adiabatic fashion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP_ADIABATIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the LYP functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.LYP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the OPTX functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.OPTX",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the P86C functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.P86C",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PADE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PADE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "PBE exchange hole model in trucanted coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PBE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PBE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PerdewWang correlation functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PW92",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PZ functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.PZ81",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TFW functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TFW",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TF functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TPSS functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.TPSS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the VWN functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.VWN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the XALPHA (SLATER) functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XALPHA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses one of the XGGA functionals (optimized versions of some of these functionals might be available outside this section).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XGGA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the short range PBE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL.XWPBE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "The xc functional to use",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_FUNCTIONAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "The xc parameters used when calculating the xc on the grid",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_GRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "Uses the SAOP potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL.SAOP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL"
      ]
    }, {
      "description": "The xc potential to use (CAREFUL: xc potential here refers to potentials that are not derived from an xc functional, but rather are modelled directly. Therefore there is no consistent xc energy available. To still get an energy expression, see ENERGY below",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC.XC_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC"
      ]
    }, {
      "description": "parameters needed calculate the xc potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT.XC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT"
      ]
    }, {
      "description": "parameters needed to set up the Time Dependent Density Functional PT",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TDDFPT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Specifies the parameters for transport, sets parameters for the OMEN code, see also http://www.nano-tcad.ethz.ch/",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.TRANSPORT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Use one of the available methods to define the localization  and possibly to optimize it to a minimum or a maximum.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.LOCALIZE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Settings for DAVIDSON",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DAVIDSON",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Define type and parameters for mixingprocedures to be applied to the density matrix. Normally, only one type of mixing method should be accepted. The mixing procedures activated by this section are only active for diagonalization methods, i.e. not with minimization methods based on OT.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF.MIXING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF"
      ]
    }, {
      "description": "Activation of self-consistenf subspace refinement by diagonalization of H by adjusting the occupation but keeping the MOS unchanged.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.DIAG_SUB_SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Settings for KRYLOV",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.KRYLOV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Sets the various options for the orbital transformation (OT) method. Default settings already provide an efficient, yet robust method. Most systems benefit from using the FULL_ALL preconditioner combined with a small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit from using a DIIS minimizer.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION.OT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION"
      ]
    }, {
      "description": "Set up type and parameters for Kohn-Sham matrix diagonalization.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.DIAGONALIZATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Define type and parameters for mixingprocedures to be applied to the density matrix. Normally, only one type of mixing method should be accepted. The mixing procedures activated by this section are only active for diagonalization methods, i.e. not with minimization methods based on OT.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.MIXING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Sets the various options for the orbital transformation (OT) method. Default settings already provide an efficient, yet robust method. Most systems benefit from using the FULL_ALL preconditioner combined with a small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit from using a DIIS minimizer.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "parameters controlling the outer SCF loop",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.OUTER_SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "Define the smearing of the MO occupation numbers",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF.SMEAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF"
      ]
    }, {
      "description": "parameters needed perform an scf run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS.SCF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XAS"
      ]
    }, {
      "description": "Sets the method of choice to calculate core-level excitation spectra. The occupied states from  which we calculate the excitation should be specified. Localization of the orbitals may be useful.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XAS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "Parameters for self interation corrected hybrid functionals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.ADIABATIC_RESCALING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Controls the printing basic info about hf method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HF_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "All parameters needed in a HFX RI calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.HFX_RI",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Sets up interaction potential if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Parameters influencing the load balancing of the HF",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.LOAD_BALANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the ERI's if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.MEMORY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Sets up periodic boundary condition parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Sets up screening parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF.SCREENING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF"
      ]
    }, {
      "description": "Sets up the Hartree-Fock parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.HF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Information on the non local dispersion functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.NON_LOCAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "Controls the printing of some info about DFTD contributions",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL.PRINT_DFTD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL"
      ]
    }, {
      "description": "Information on the pair potential to calculate dispersion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL.PAIR_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL"
      ]
    }, {
      "description": "This section combines all possible additional dispersion corrections to the normal XC functionals. This can be more functionals or simple empirical pair potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.VDW_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Parameters influencing the solution of the Z-vector equations in MP2 gradients calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.CPHF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the direct canonical method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.DIRECT_CANONICAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters the interaction potential in computing the biel integrals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Controls the printing basic info about MP2 method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.MP2_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the optimization of the RI MP2 basis. Only exponents of non-contracted auxiliary basis can be optimized. An initial RI auxiliary basis has to be specified.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.OPT_RI_BASIS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the RI-SOS-MP2-Laplace method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_LAPLACE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters influencing the RI MP2 method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_MP2",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Controls the printing basic info about hf method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HF_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "All parameters needed in a HFX RI calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.HFX_RI",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up interaction potential if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.INTERACTION_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Parameters influencing the load balancing of the HF",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.LOAD_BALANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up memory parameters for the storage of the ERI's if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.MEMORY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up periodic boundary condition parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up screening parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF.SCREENING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF"
      ]
    }, {
      "description": "Sets up the Hartree-Fock parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA.HF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA"
      ]
    }, {
      "description": "Parameters influencing the RI RPA method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.RI_RPA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Parameters for the GPW approach in Wavefunction-based Correlation methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION.WFC_GPW",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION"
      ]
    }, {
      "description": "Sets up the Wavefunction-based Correlation parameters if requested",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.WF_CORRELATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Uses the Becke 88 longrange exchange functional in an adiabatic fashion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR_ADIABATIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 88 longrange exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88_LR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 88 exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE88",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the Becke 97 exchange correlation functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE97",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Becke Roussel exchange hole model. Can be usedas long range correction with a truncated coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BECKE_ROUSSEL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the BEEFvdW exchange functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.BEEF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the CS1 functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.CS1",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Combination of three different exchange hole models",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.GV09",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the HCTH class of functionals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.HCTH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses one of the KE_GGA functionals (optimized versions of some of these functionals might be available outside this section). These functionals are needed for the computation of the kinetic energy in the Kim-Gordon method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_GGA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "To be used for KG runs. Uses kinetic energy functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.KE_LIBXC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "LDA exchange hole model in truncated coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LDA_HOLE_T_C_LR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LIBXC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the LYP correlation functional in an adiabatic fashion",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP_ADIABATIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the LYP functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.LYP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the OPTX functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.OPTX",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the P86C functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.P86C",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PADE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PADE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "PBE exchange hole model in trucanted coulomb potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE_HOLE_T_C_LR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PBE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PBE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PerdewWang correlation functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PW92",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the PZ functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.PZ81",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TFW functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TFW",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TF functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the TPSS functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.TPSS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the VWN functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.VWN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the XALPHA (SLATER) functional.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XALPHA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses one of the XGGA functionals (optimized versions of some of these functionals might be available outside this section).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XGGA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "Uses the short range PBE functional",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL.XWPBE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL"
      ]
    }, {
      "description": "The xc functional to use",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_FUNCTIONAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "The xc parameters used when calculating the xc on the grid",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_GRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "Uses the SAOP potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL.SAOP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL"
      ]
    }, {
      "description": "The xc potential to use (CAREFUL: xc potential here refers to potentials that are not derived from an xc functional, but rather are modelled directly. Therefore there is no consistent xc energy available. To still get an energy expression, see ENERGY below",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC.XC_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT.XC"
      ]
    }, {
      "description": "parameters needed calculate the xc potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT.XC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.DFT"
      ]
    }, {
      "description": "parameter needed by dft programs",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.DFT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "This section contains all information to run an Empirical Interatomic Potential (EIP) calculation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.EIP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "parameter needed by an ep calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.EP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Section controlling the presence of an external potential dependent  on the atomic positions (X,Y,Z)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.EXTERNAL_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Coupling between two force_eval: E=(E1+E2 - sqrt((E1-E2)**2+4*H12**2))/2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.COUPLING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "User driven coupling between two or more force_eval.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.GENERIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "Linear combination between two force_eval:  F= lambda F1 + (1-lambda) F2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.LINEAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "Fragment definition",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL.FRAGMENT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL"
      ]
    }, {
      "description": "Fragment definition",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED.FRAGMENT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED"
      ]
    }, {
      "description": "Defines the fragments for the mixed force_eval (reference)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL_MIXED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING"
      ]
    }, {
      "description": "Defines the fragments and the mapping for each force_eval (an integer index (ID) needs to be provided as parameter)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING.FORCE_EVAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING"
      ]
    }, {
      "description": "Defines the mapping of atoms for the different force_eval with the mixed force_eval. The default is to have a mapping 1-1 between atom index (i.e. all force_eval share the same geometrical structure). The mapping is based on defining fragments and the mapping the  fragments between the several force_eval and the mixed force_eval",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.MAPPING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "Restraint between two force_eval: E = E1 + k*(E1-E2-t)**2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MIXED"
      ]
    }, {
      "description": "This section contains all information to run with a hamiltonian defined by a mixing of force_evals",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MIXED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Specifies the Urey-Bradley potential between the external atoms defining the angle",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND.UB",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND"
      ]
    }, {
      "description": "Specifies the bend potential of the MM system.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BEND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Specifies the bond potential",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.BOND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Allow to specify an array of classical charges, thus avoiding the packing and permitting the usage of different charges for same atomic types.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.CHARGES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This section specifies the charge of the MM atoms",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This section specifies optional electric field damping for the polarizable atoms.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE.DAMPING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE"
      ]
    }, {
      "description": "This section specifies that we will perform an SCF dipole calculation of the MM atoms. Needs KEYWORD POL_SCF in POISSON secton",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.DIPOLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Specifies the improper torsion potential of the MM system.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.IMPROPER",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This section specifies the input parameters for BMHFTD potential type.Functional form: V(r) = A*exp(-B*r) - f_6*(r)C/r^6 - f_8(r)*D/r^8.where f_order(r)=1-exp(-BD * r) * \\sum_{k=0}^order (BD * r)^k / k! .(Tang-Toennies damping function)No values available inside cp2k.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFTD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for BMHFT potential type.Functional form: V(r) = A * EXP(-B*r) - C/r^6 - D/r^8.Values available inside cp2k only for the Na/Cl pair.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BMHFT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for the Buckingham 4-ranges potential type. Functional form:<ul><li>V(r) = A*EXP(-B*r) for r &#60; r<sub>1</sub></li><li>V(r) = Sum_n POLY1(n)*r<sup>n</sup> for r<sub>1</sub> â¤ r &#60; r<sub>2</sub></li><li>V(r) = Sum_n POLY2(n)*r<sup>n</sup> for r<sub>2</sub> â¤ r &#60; r<sub>3</sub></li><li>V(r) = -C/r<sup>6</sup> for r â¥ r<sub>3</sub></li></ul>",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCK4RANGES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for Buckingham plus Morse potential type  Functional Form: V(r) = F0*(B1+B2)*EXP([A1+A2-r]/[B1+B2])-C/r^6+D*{EXP[-2*beta*(r-R0)]-2*EXP[-beta*(r-R0)]}.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.BUCKMORSE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for EAM potential type.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.EAM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for a generic potential type.A functional form is specified. Mathematical Operators recognized are +, -, *, /, ** or alternatively ^, whereas symbols for brackets must be (). The function parser recognizes the (single argument) Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh, tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions is CASE INsensitive.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GENPOT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for GOODWIN potential type.Functional form: V(r) = EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.GOODWIN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for IPBV potential type.Functional form: Implicit table function.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.IPBV",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for LENNARD-JONES potential type.Functional form: V(r) = 4.0 * EPSILON * [(SIGMA/r)^12-(SIGMA/r)^6].",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.LENNARD-JONES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for QUIP potential type. Mainly intended for things like GAP corrections to DFT to achieve correlated-wavefunction-like accuracy. Requires linking with quip library from <a href=\"http://www.libatoms.org\" target=\"_blank\">http://www.libatoms.org</a> .",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.QUIP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for the Siepmann-Sprik potential type. Consist of 4 terms: T1+T2+T3+T4. The terms T1=A/rij^alpha and T2=-C/rij^6 have to be given via the GENPOT section. The terms T3+T4 are obtained from the SIEPMANN section.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.SIEPMANN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for Tersoff potential type.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.TERSOFF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for WILLIAMS potential type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED.WILLIAMS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for a generic potential type.A functional form is specified. Mathematical Operators recognized are +, -, *, /, ** or alternatively ^, whereas symbols for brackets must be (). The function parser recognizes the (single argument) Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh, tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions is CASE INsensitive.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GENPOT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for GOODWIN potential type.Functional form: V(r) = EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.GOODWIN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for LENNARD-JONES potential type.Functional form: V(r) = 4.0 * EPSILON * [(SIGMA/r)^12-(SIGMA/r)^6].",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.LENNARD-JONES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for WILLIAMS potential type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14.WILLIAMS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for 1-4 NON-BONDED interactions.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED14",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This section specifies the input parameters for NON-BONDED interactions.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.NONBONDED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Specifies the out of plane bend potential of the MM system.(Only defined for atom quadruples which are also defined as an improper pattern in the topology.)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.OPBEND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This section specifies that we will perform an SCF quadrupole calculation of the MM atoms. Needs KEYWORD POL_SCF in POISSON secton",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.QUADRUPOLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "This section specifies the parameters for shell-model potentials",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SHELL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "specifies parameters to set up the splines used in the nonboned interactions (both pair body potential and many body potential)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.SPLINE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Specifies the torsion potential of the MM system.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD.TORSION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD"
      ]
    }, {
      "description": "Section specifying information regarding how to set up properly a force_field for the classical calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.FORCEFIELD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM"
      ]
    }, {
      "description": "This section specifies the input parameters for the construction of neighbor lists.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.NEIGHBOR_LISTS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM"
      ]
    }, {
      "description": "Enables the use of multipoles in the treatment of the electrostatics.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.MULTIPOLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "Set options that influence how the realspace grids are being distributed in parallel runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD.RS_GRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD"
      ]
    }, {
      "description": "Ewald parameters controlling electrostatic only for CLASSICAL MM.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.EWALD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON"
      ]
    }, {
      "description": "Sets up parameters of  Martyna-Tuckerman poisson solver. Note that exact results are only guaranteed if the unit cell is twice as large as charge density (and serious artefacts can result if the cell is much smaller).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON"
      ]
    }, {
      "description": "Controls the checking of the G-space term Spline Interpolation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.CHECK_SPLINE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "controls the interpolation for the G-space term",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "Controls the printing of basic information during the run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "This section is used to set up the decoupling of QM periodic images with the use of density derived atomic point charges.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.MULTIPOLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON"
      ]
    }, {
      "description": "Sets up parameters of  wavelet based poisson solver.This solver allows for non-periodic (PERIODIC NONE) boundary conditions and slab-boundary conditions (but only PERIODIC XZ).It does not require very large unit cells, only that the density goes to zero on the faces of the cell.The use of PREFERRED_FFT_LIBRARY FFTSG is required",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON.WAVELET",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM.POISSON"
      ]
    }, {
      "description": "Sets up the poisson resolutor.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM.POISSON",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.MM"
      ]
    }, {
      "description": "This section contains all information to run a MM calculation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.MM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D"
      ]
    }, {
      "description": "Each node prints out its distribution info ...",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION1D",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D"
      ]
    }, {
      "description": "Controls the printing of the distribution of matrix blocks,...",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION2D",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "Controls the printing of the distribution of molecules, atoms, ...",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.DISTRIBUTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES"
      ]
    }, {
      "description": "Controls the printing of the forces after each force evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.FORCES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION"
      ]
    }, {
      "description": "Controls the printing of information regarding the PW and RS grid structures.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.GRID_INFORMATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO"
      ]
    }, {
      "description": "Controls the printing of basic information generated by force_eval",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR"
      ]
    }, {
      "description": "Controls the printing of the stress tensor",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.STRESS_TENSOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS.EACH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS"
      ]
    }, {
      "description": "Controls the printing of the total number of atoms, kinds,...",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT.TOTAL_NUMBERS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PRINT"
      ]
    }, {
      "description": "Properties that you want to output and that are common to all methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PRINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Controls the calculation of atomic properties. Printing is controled by FORCE_EVAL / PRINT / PROGRAM_RUN_INFO",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ATOMIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A"
      ]
    }, {
      "description": "Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_A",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B"
      ]
    }, {
      "description": "Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.BECKE_RESTRAINT_B",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A"
      ]
    }, {
      "description": "Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_A",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B"
      ]
    }, {
      "description": "Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.DDAPC_RESTRAINT_B",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING"
      ]
    }, {
      "description": "Controls the printing basic info about the method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING"
      ]
    }, {
      "description": "specifies the two constraints/restraints for extracting ET coupling elements",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.ET_COUPLING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES"
      ]
    }, {
      "description": "This section is used to print the density derived atomic point charges.The fit of the charges is controlled through the DENSITY_FITTING section",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.FIT_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT"
      ]
    }, {
      "description": "The induced current density is calculated by DFPT.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.CURRENT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR"
      ]
    }, {
      "description": "The g tensor is calculated by DFPT",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.EPR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "Use one of the available methods to define the localization  and possibly to optimize it to a minimum or a maximum.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.LOCALIZE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR"
      ]
    }, {
      "description": "The chemical shift is calculated by DFPT.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.NMR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR"
      ]
    }, {
      "description": "Compute polarizabilities.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.POLAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN"
      ]
    }, {
      "description": "Compute indirect spin-spin coupling constants.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES.SPINSPIN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES"
      ]
    }, {
      "description": "The linear response is used to calculate one of the  following properties: nmr, epr, raman, ...",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.LINRES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES"
      ]
    }, {
      "description": "specifies a linear constraint on the fitted charges.This can be used to give equal values to equivalent atoms.sum over atom_list c_i * q_i = t",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.CONSTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Specifies the parameter for sampling the RESP fitting points for non-periodic systems, i.e. systems that do not involve surfaces. This section can be used with periodic and nonperiodic Poisson solvers, it only affects the sampling of grid points. All grid points in the shell defined by rmin and rmax are accepted for fitting.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.NONPERIODIC_SYS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Specifies the parameter for sampling the RESP fitting points for periodic systems, i.e. systems that involve surfaces. This section can only be used with periodic  Poisson solver and cell. To see, which grid points were used, switch on COORD_FIT_POINTS in the PRINT section.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.PERIODIC_SYS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "specifies a restraint on the fitted charges.This can be used to restrain values to zero.s*(sum over atom_list q_i - t)**2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP"
      ]
    }, {
      "description": "Requests a RESP fit of charges. When using a periodic Poisson solver and a periodic cell, the periodic RESP routines are used. If the Hartree potential matches with the one of an isolated system (i.e. isolated Poisson solver and big, nonperiodic cells), the nonperiodic RESP routines are automatically used. The subsections NONPERIODIC_SYS and PERIODIC_SYS do not request a nonperiodic or periodic solution, they only determine the sampling of the fitting points. All restraints are harmonic!",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES.RESP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.PROPERTIES"
      ]
    }, {
      "description": "This section is used to set up the PROPERTIES calculation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.PROPERTIES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Input parameters needed to set up the CELL_REF.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL.CELL_REF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL"
      ]
    }, {
      "description": "Input parameters needed to set up the CELL.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.CELL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Specify information to add a classical charge before the QM/MM energies and forces evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.ADD_MM_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specify information to move a classical charge before the QM/MM energies and forces evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK.MOVE_MM_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK"
      ]
    }, {
      "description": "Specify information on the QM/MM link treatment",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS.LINK",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS"
      ]
    }, {
      "description": "Information about possible links for automatic covalent bond breaking for the buffer QM/MM calculation.Ignored - need to implement buffer selection by atom and walking of connectivity data.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_LINKS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Specify information to add a classical charge before the QM/MM energies and forces evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.ADD_MM_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specify information to move a classical charge before the QM/MM energies and forces evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK.MOVE_MM_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK"
      ]
    }, {
      "description": "Specify information on the QM/MM link treatment",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.LINK",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE"
      ]
    }, {
      "description": "Information about the qm kind in the qm/mm scheme",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE.QM_KIND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE"
      ]
    }, {
      "description": "List of atoms always in buffer region, non-adaptively, and any needed LINK sections",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.BUFFER_NON_ADAPTIVE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "Information about the qm kind in the qm/mm scheme",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE.QM_KIND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE"
      ]
    }, {
      "description": "List of atoms always in QM region, non-adaptively",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.QM_NON_ADAPTIVE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "This section provides information about old force-mixing indices and labels, for restarts.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING.RESTART_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING"
      ]
    }, {
      "description": "This section enables and defines parameters for force-mixing based QM/MM, which actually does two conventional QM/MM calculations, on a small  and a large QM region, and combines the MM forces from one and QM  forces from the other to create a complete set of forces.  Energy is  not conserved (although the QM/MM energy from the large QM region calculation is reported)  so a proper thermostat (i.e. massive, and able to handle dissipation, such as  Adaptive Langevin (AD_LANGEVIN)) must be used. For some propagation algorithms  (NVT and REFTRAJ MD ensembles) algorithm is adaptive,  including molecules hysteretically based on their instantaneous distance from the core region.  Information on core/QM/buffer labels can be written in PDB file using  MOTION&PRINT&FORCE_MIXING_LABELS.  Will fail if calculation requires a  meaningfull stress, or an energy that is consistent with the forces.  For GEO_OPT this means  only MOTION&GEO_OPT&TYPE CG, MOTION&GEO_OPT&CG&LINE_SEARCH&TYPE 2PNT, and  MOTION&GEO_OPT&CG&LINE_SEARCH&2PNT&LINMIN_GRAD_ONLY T",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCE_MIXING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "This section specifies the input parameters for a generic potential type.A functional form is specified. Mathematical Operators recognized are +, -, *, /, ** or alternatively ^, whereas symbols for brackets must be (). The function parser recognizes the (single argument) Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh, tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions is CASE INsensitive.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GENPOT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for GOODWIN potential type.Functional form: V(r) = EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.GOODWIN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for LENNARD-JONES potential type.Functional form: V(r) = 4.0 * EPSILON * [(SIGMA/r)^12-(SIGMA/r)^6].",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.LENNARD-JONES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for WILLIAMS potential type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED.WILLIAMS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED"
      ]
    }, {
      "description": "This section specifies the input parameters for a generic potential type.A functional form is specified. Mathematical Operators recognized are +, -, *, /, ** or alternatively ^, whereas symbols for brackets must be (). The function parser recognizes the (single argument) Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh, tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions is CASE INsensitive.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GENPOT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for GOODWIN potential type.Functional form: V(r) = EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.GOODWIN",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for LENNARD-JONES potential type.Functional form: V(r) = 4.0 * EPSILON * [(SIGMA/r)^12-(SIGMA/r)^6].",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.LENNARD-JONES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for WILLIAMS potential type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14.WILLIAMS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14"
      ]
    }, {
      "description": "This section specifies the input parameters for 1-4 NON-BONDED interactions.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED14",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD"
      ]
    }, {
      "description": "Specify information on the QM/MM non-bonded forcefield",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD.NONBONDED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD"
      ]
    }, {
      "description": "Specify information on the QM/MM forcefield",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.FORCEFIELD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Inclusion of polarization effects within the image charge approach for systems where QM molecules are physisorbed on e.g. metal surfaces described by MM. QM box size has to be equal to MM box size.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.IMAGE_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "outputs a cube with the coefficents calculated for the spline interpolation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR.SPL_COEFFS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR"
      ]
    }, {
      "description": "kind of interpolation used between the multigrids",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Specify information to add a classical charge before the QM/MM energies and forces evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.ADD_MM_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specify information to move a classical charge before the QM/MM energies and forces evaluation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK.MOVE_MM_CHARGE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK"
      ]
    }, {
      "description": "Specify information on the QM/MM link treatment",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.LINK",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Information about the mm kind in the qm/mm scheme",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.MM_KIND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Controls the checking of the G-space term Spline Interpolation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.CHECK_SPLINE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR"
      ]
    }, {
      "description": "controls the interpolation for the G-space term",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "Controls the checking of the G-space term Spline Interpolation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.CHECK_SPLINE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "controls the interpolation for the G-space term",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "Controls the printing of basic information during the run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE"
      ]
    }, {
      "description": "This section is used to set up the decoupling of QM periodic images with the use of density derived atomic point charges. Switched on by default even if not explicitly given. Can be switched off if e.g. QM and MM box are of the same size.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.MULTIPOLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "Enables the use of multipoles in the treatment of the electrostatics.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.MULTIPOLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "Set options that influence how the realspace grids are being distributed in parallel runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD.RS_GRID",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD"
      ]
    }, {
      "description": "Ewald parameters controlling electrostatic only for CLASSICAL MM.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.EWALD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON"
      ]
    }, {
      "description": "Sets up parameters of  Martyna-Tuckerman poisson solver. Note that exact results are only guaranteed if the unit cell is twice as large as charge density (and serious artefacts can result if the cell is much smaller).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON"
      ]
    }, {
      "description": "Controls the checking of the G-space term Spline Interpolation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.CHECK_SPLINE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "if convergence information about the linear solver of the spline methods should be printed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR.CONV_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR"
      ]
    }, {
      "description": "controls the interpolation for the G-space term",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.INTERPOLATOR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "Controls the printing of basic information during the run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE"
      ]
    }, {
      "description": "This section is used to set up the decoupling of QM periodic images with the use of density derived atomic point charges.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.MULTIPOLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON"
      ]
    }, {
      "description": "Sets up parameters of  wavelet based poisson solver.This solver allows for non-periodic (PERIODIC NONE) boundary conditions and slab-boundary conditions (but only PERIODIC XZ).It does not require very large unit cells, only that the density goes to zero on the faces of the cell.The use of PREFERRED_FFT_LIBRARY FFTSG is required",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON.WAVELET",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON"
      ]
    }, {
      "description": "Sets up the poisson resolutor.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC.POISSON",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC"
      ]
    }, {
      "description": "Specify parameters for QM/MM periodic boundary conditions calculations",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.PERIODIC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Information about the qm kind in the qm/mm scheme",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.QM_KIND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Enables Walls for the QM box. This can be used to avoid that QM  atoms move out of the QM box.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM.WALLS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.QMMM"
      ]
    }, {
      "description": "Input for QM/MM calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.QMMM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Section controlling the rescaling of forces. Useful when starting from quite bad geometries with unphysically large forces.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.RESCALE_FORCES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "Input parameters needed to set up the CELL_REF.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL.CELL_REF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL"
      ]
    }, {
      "description": "Input parameters needed to set up the CELL.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CELL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE"
      ]
    }, {
      "description": "This section defines the plane. When using this colvar, two plane section must be defined!",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "This section defines the angle between two planes as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE_PLANE_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Section to define the angle as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.ANGLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Section to define the rotation of a bond/line with respect toanother bond/line",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.BOND_ROTATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Specify further data possibly used by colvars, depending on the starting geometry, for computing the functions value.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COLVAR_FUNC_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE"
      ]
    }, {
      "description": "This section defines the plane. When using this colvar, two plane section must be defined!",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "This section defines the angle between two planes as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE_PLANE_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Section to define the angle as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.ANGLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Section to define the rotation of a bond/line with respect toanother bond/line",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.BOND_ROTATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Specify further data possibly used by colvars, depending on the starting geometry, for computing the functions value.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COLVAR_FUNC_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Section to define the conditioned distance as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.CONDITIONED_DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Section to define the coordination number as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.COORDINATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Section to define functions between two distances as collective variables. The function is defined as d1+coeff*d2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_FUNCTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Section to define the distance of a point from a plane as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE_POINT_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Section to define the distance as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Section to define the gyration radius as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.GYRATION_RADIUS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HBP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Section to define the formation of a hydronium as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.HYDRONIUM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION"
      ]
    }, {
      "description": "Section to define the population of specie as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.POPULATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM"
      ]
    }, {
      "description": "Section to define the Q parameter (crystalline order parameter) as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.QPARM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Section to define general ring puckering collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RING_PUCKERING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "The positions for RMSD used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Specify coordinates of the frame (number of frames can be either 1 or 2)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD.FRAME",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD"
      ]
    }, {
      "description": "Section to define a CV as function of RMSD computed with respect to given reference configurations. For 2 configurations the colvar is equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1 configuration is given, then the colvar is just the RMSD from that frame.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.RMSD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION"
      ]
    }, {
      "description": "Section to define the torsion as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.TORSION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "This section allows to use any function of the energy subsystems  in a mixed_env calculation as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U.MIXED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U"
      ]
    }, {
      "description": "Section to define the energy as a generalized collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.U",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.WC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Section to define the distance of an atom from its starting position ((X-X(0))^2+(Y-Y(0))^2+(Z-Z(0))^2) or part of its components as a collective variable.If absolute_position is specified, instead the CV is represented by the instantaneous position of the atom (only available for X, Y or Z components).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_DIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-YB(0)) or part of its components as a collective variable. The final term is given by the product  of the components of A with the components of B.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR.XYZ_OUTERDIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR"
      ]
    }, {
      "description": "This section specifies the nature of the collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR.COLVAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR"
      ]
    }, {
      "description": "Allows the possibility to combine several COLVARs into one COLVAR with a generic function.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COMBINE_COLVAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Section to define the conditioned distance as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.CONDITIONED_DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Section to define the coordination number as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.COORDINATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE"
      ]
    }, {
      "description": "This section defines the plane. When using this colvar, two plane section must be defined!",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "This section defines the angle between two planes as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE_PLANE_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Section to define the angle as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.ANGLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Section to define the rotation of a bond/line with respect toanother bond/line",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.BOND_ROTATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Specify further data possibly used by colvars, depending on the starting geometry, for computing the functions value.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COLVAR_FUNC_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Section to define the conditioned distance as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.CONDITIONED_DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Section to define the coordination number as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.COORDINATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Section to define functions between two distances as collective variables. The function is defined as d1+coeff*d2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_FUNCTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Section to define the distance of a point from a plane as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE_POINT_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Section to define the distance as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Section to define the gyration radius as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.GYRATION_RADIUS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HBP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Section to define the formation of a hydronium as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.HYDRONIUM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Section to define the population of specie as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.POPULATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Section to define the Q parameter (crystalline order parameter) as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.QPARM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Section to define general ring puckering collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RING_PUCKERING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "The positions for RMSD used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Specify coordinates of the frame (number of frames can be either 1 or 2)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD.FRAME",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Section to define a CV as function of RMSD computed with respect to given reference configurations. For 2 configurations the colvar is equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1 configuration is given, then the colvar is just the RMSD from that frame.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.RMSD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION"
      ]
    }, {
      "description": "Section to define the torsion as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.TORSION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "This section allows to use any function of the energy subsystems  in a mixed_env calculation as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U.MIXED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U"
      ]
    }, {
      "description": "Section to define the energy as a generalized collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.U",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.WC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Section to define the distance of an atom from its starting position ((X-X(0))^2+(Y-Y(0))^2+(Z-Z(0))^2) or part of its components as a collective variable.If absolute_position is specified, instead the CV is represented by the instantaneous position of the atom (only available for X, Y or Z components).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_DIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-YB(0)) or part of its components as a collective variable. The final term is given by the product  of the components of A with the components of B.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR.XYZ_OUTERDIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR"
      ]
    }, {
      "description": "This section specifies the nature of the collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.COLVAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "The positions for RMSD used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME"
      ]
    }, {
      "description": "Specify coordinates of the frame",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.FRAME",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Activating this print key will print once a file with the values of the FUNCTION on a grid of COLVAR values in a specified range. GRID_SPACING and RANGE for every COLVAR has to be specified again in the same order as they are in the input.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH.MAP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH"
      ]
    }, {
      "description": "Section defining the distance from a one dimensional reaction path in an Q-dimensional space of colvars. Constraining this colvar, allows to sample the space equidistant to the reaction path, both in the Q-dimensional colvar and 3N-Q remaining coordinates. For the details of the function see cited literature.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FROM_PATH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Section to define functions between two distances as collective variables. The function is defined as d1+coeff*d2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_FUNCTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Section to define the distance of a point from a plane as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE_POINT_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Section to define the distance as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Section to define the gyration radius as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.GYRATION_RADIUS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HBP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Section to define the formation of a hydronium as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.HYDRONIUM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION"
      ]
    }, {
      "description": "Section to define the population of specie as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.POPULATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM"
      ]
    }, {
      "description": "Section to define the Q parameter (crystalline order parameter) as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.QPARM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE"
      ]
    }, {
      "description": "This section defines the plane. When using this colvar, two plane section must be defined!",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE"
      ]
    }, {
      "description": "This section defines the angle between two planes as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE_PLANE_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Section to define the angle as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.ANGLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION"
      ]
    }, {
      "description": "Section to define the rotation of a bond/line with respect toanother bond/line",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.BOND_ROTATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Specify further data possibly used by colvars, depending on the starting geometry, for computing the functions value.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COLVAR_FUNC_INFO",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE"
      ]
    }, {
      "description": "Section to define the conditioned distance as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.CONDITIONED_DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION"
      ]
    }, {
      "description": "Section to define the coordination number as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.COORDINATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION"
      ]
    }, {
      "description": "Section to define functions between two distances as collective variables. The function is defined as d1+coeff*d2",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_FUNCTION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE"
      ]
    }, {
      "description": "Section to define the distance of a point from a plane as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE_POINT_PLANE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Section to define the distance as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.DISTANCE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS"
      ]
    }, {
      "description": "Section to define the gyration radius as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.GYRATION_RADIUS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HBP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM"
      ]
    }, {
      "description": "Section to define the formation of a hydronium as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.HYDRONIUM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION"
      ]
    }, {
      "description": "Section to define the population of specie as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.POPULATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM"
      ]
    }, {
      "description": "Section to define the Q parameter (crystalline order parameter) as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.QPARM",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Section to define general ring puckering collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RING_PUCKERING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "The positions for RMSD used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Specify coordinates of the frame (number of frames can be either 1 or 2)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD.FRAME",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD"
      ]
    }, {
      "description": "Section to define a CV as function of RMSD computed with respect to given reference configurations. For 2 configurations the colvar is equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1 configuration is given, then the colvar is just the RMSD from that frame.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.RMSD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION"
      ]
    }, {
      "description": "Section to define the torsion as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.TORSION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "This section allows to use any function of the energy subsystems  in a mixed_env calculation as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U.MIXED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U"
      ]
    }, {
      "description": "Section to define the energy as a generalized collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.U",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.WC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Section to define the distance of an atom from its starting position ((X-X(0))^2+(Y-Y(0))^2+(Z-Z(0))^2) or part of its components as a collective variable.If absolute_position is specified, instead the CV is represented by the instantaneous position of the atom (only available for X, Y or Z components).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_DIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-YB(0)) or part of its components as a collective variable. The final term is given by the product  of the components of A with the components of B.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR.XYZ_OUTERDIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR"
      ]
    }, {
      "description": "This section specifies the nature of the collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.COLVAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "The positions for RMSD used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME"
      ]
    }, {
      "description": "Specify coordinates of the frame",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.FRAME",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Activating this print key will print once a file with the values of the FUNCTION on a grid of COLVAR values in a specified range. GRID_SPACING and RANGE for every COLVAR has to be specified again in the same order as they are in the input.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH.MAP",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH"
      ]
    }, {
      "description": "Section defining a one dimensional reaction path in an Q-dimensional space of colvars. Constraining this colvar, allows to sample the space orthogonal to the reaction path, both in the Q-dimensional colvar and 3N-Q remaining coordinates. For the details of the function see cited literature.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.REACTION_PATH",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING"
      ]
    }, {
      "description": "Section to define general ring puckering collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RING_PUCKERING",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "The positions for RMSD used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME"
      ]
    }, {
      "description": "Specify coordinates of the frame (number of frames can be either 1 or 2)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD.FRAME",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD"
      ]
    }, {
      "description": "Section to define a CV as function of RMSD computed with respect to given reference configurations. For 2 configurations the colvar is equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1 configuration is given, then the colvar is just the RMSD from that frame.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.RMSD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION"
      ]
    }, {
      "description": "Section to define the torsion as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.TORSION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "This section allows to use any function of the energy subsystems  in a mixed_env calculation as a collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U.MIXED",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U"
      ]
    }, {
      "description": "Section to define the energy as a generalized collective variable.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.U",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC"
      ]
    }, {
      "description": "Section to define the hbond wannier centre as a collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.WC",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG"
      ]
    }, {
      "description": "Section to define the distance of an atom from its starting position ((X-X(0))^2+(Y-Y(0))^2+(Z-Z(0))^2) or part of its components as a collective variable.If absolute_position is specified, instead the CV is represented by the instantaneous position of the atom (only available for X, Y or Z components).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_DIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "Enables the possibility to use geometrical centers instead of single atoms to define colvars",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG.POINT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG"
      ]
    }, {
      "description": "Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-YB(0)) or part of its components as a collective variable. The final term is given by the product  of the components of A with the components of B.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR.XYZ_OUTERDIAG",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR"
      ]
    }, {
      "description": "This section specifies the nature of the collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COLVAR",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "The coordinates for simple systems (like the QM ones) xyz format by default. More complex systems should be given with an external pdb file.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "The core coordinates for the shell-model potentials xyz format with an additional column for the index of the corresponding particle",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CORE_COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "The velocities of cores for shell-model potentials, in xyz format",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.CORE_VELOCITY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "Section used to specify a general basis set for QM calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BASIS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "alpha spin",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.ALPHA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS"
      ]
    }, {
      "description": "beta spin",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS.BETA",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS"
      ]
    }, {
      "description": "Define the required atomic orbital occupation assigned in initialization of the density matrix, by adding or subtracting electrons from specific angular momentum channels. It works only with GUESS ATOMIC.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.BS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Enforce and control a special (initial) orbital occupation. Note, this feature works only for the methods MULLIKEN and LOWDIN. It should only be used to prepare an initial configuration. An inadequate parameter choice can easily inhibit SCF convergence.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U.ENFORCE_OCCUPATION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U"
      ]
    }, {
      "description": "Define the parameters for a DFT+U run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.DFT_PLUS_U",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Section used to specify a geminal basis set for QM calculations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.GEMINAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Section used to specify KG Potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.KG_POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "Section used to specify Potentials.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND.POTENTIAL",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND"
      ]
    }, {
      "description": "The description of the kind of the atoms (mostly for QM)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.KIND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "Specifies the dipoles of the particles.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES.DIPOLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES"
      ]
    }, {
      "description": "Specifies the quadrupoles of the particles.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES.QUADRUPOLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES"
      ]
    }, {
      "description": "Specifies the dipoles and quadrupoles for particles.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.MULTIPOLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "The shell coordinates for the shell-model potentials xyz format with an additional column for the index of the corresponding particle",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.SHELL_COORD",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "The velocities of shells for shell-model potentials, in xyz format",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.SHELL_VELOCITY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "Allows centering the coordinates of the system in the box. The centering point can be defined by the user.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.CENTER_COORDINATES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "controls the dumping of the PDB at the starting geometry",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PDB",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "controls the dumping of the PSF connectivity",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.DUMP_PSF",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Speficy bonds (via atom kinds) for fine tuning of 1-2 exclusion lists. If this section is not present the 1-2 exclusion is applied to all bond kinds. When this section is present the 1-2 exclusion is applied ONLY to the bonds defined herein. This section allows ONLY fine tuning of 1-2 interactions.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_EI_LIST",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Speficy bonds (via atom kinds) for fine tuning of 1-2 exclusion lists. If this section is not present the 1-2 exclusion is applied to all bond kinds. When this section is present the 1-2 exclusion is applied ONLY to the bonds defined herein. This section allows ONLY fine tuning of 1-2 interactions.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.EXCLUDE_VDW_LIST",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Section used to add/remove angles in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ANGLE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Section used to add/remove  bonds in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.BOND",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Section used to add/remove improper in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.IMPROPER",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": " This section specifies the  atoms that one considers isolated. Useful when present  ions in solution.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.ISOLATED_ATOMS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "This section specifies the input parameters for the construction of neighbor lists.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.NEIGHBOR_LISTS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Section used to add/remove torsion in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE.TORSION",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE"
      ]
    }, {
      "description": "Setup of keywords controlling the generation of the connectivity",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.GENERATE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Defines new angles",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.ANGLES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES"
      ]
    }, {
      "description": "Defines new bonds",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.BONDS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES"
      ]
    }, {
      "description": "Defines new impropers",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.IMPROPERS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES"
      ]
    }, {
      "description": "Defines new torsions",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES.TORSIONS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES"
      ]
    }, {
      "description": "Enables the creation of connecting bridges (bonds, angles, torsions, impropers) between the two or more molecules defined with independent connectivity.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MERGE_MOLECULES",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET"
      ]
    }, {
      "description": "Specify information about the connectivity of single molecules",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET.MOLECULE",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET"
      ]
    }, {
      "description": "Specify the connectivity of a full system specifying the connectivity of the fragments of the system.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY.MOL_SET",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY"
      ]
    }, {
      "description": "Section specifying information regarding how to handle the topology for classical runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.TOPOLOGY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "The velocities for simple systems or the centroid mode in PI runs, xyz format by default",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL.SUBSYS"
      ]
    }, {
      "description": "a subsystem: coordinates, topology, molecules and cell",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL.SUBSYS",
      "superNames": [
        "x_cp2k_section_input_FORCE_EVAL"
      ]
    }, {
      "description": "parameters needed to calculate energy and forces and describe the system you want to analyze.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_FORCE_EVAL",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Configuration options for the ACC-Driver.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.DBCSR.ACC",
      "superNames": [
        "x_cp2k_section_input_GLOBAL.DBCSR"
      ]
    }, {
      "description": "Configuration options for the DBCSR library.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.DBCSR",
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Configuration options for the full matrices.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.FM",
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Configuration options for the machine architecture.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.MACHINE_ARCH",
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "controls the printing of  initialization controlled by the global section",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Controls the printing of the references relevant to the calculations performed",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.REFERENCES",
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Controls the printing of the timing report at the end of CP2K execution",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL.TIMINGS",
      "superNames": [
        "x_cp2k_section_input_GLOBAL"
      ]
    }, {
      "description": "Section with general information regarding which kind of simulation to perform an parameters for the whole PROGRAM",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_GLOBAL",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Controls the printing of the BAND banner",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.BANNER",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Controls parameters for CI-NEB type calculation only.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.CI_NEB",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Setup parameters to control the convergence criteria for BAND",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_CONTROL",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Controls the printing of the convergence criteria during a BAND run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.CONVERGENCE_INFO",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Controls the printing of the ENER file in a BAND run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Controls the printing of diis info during a BAND run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS.DIIS_INFO",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS"
      ]
    }, {
      "description": "Activate the DIIS based optimization procedure for BAND",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.DIIS",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND"
      ]
    }, {
      "description": "Setup parameters to control the temperature during a BAND MD run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.TEMP_CONTROL",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD"
      ]
    }, {
      "description": "Setup parameters to control the velocity during a BAND MD run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD.VEL_CONTROL",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD"
      ]
    }, {
      "description": "Activate the MD based optimization procedure for BAND",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND.MD",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND"
      ]
    }, {
      "description": "Specify the optimization method for the band",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.OPTIMIZE_BAND",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Controls the printing basic info about the BAND run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "The positions for BAND used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.REPLICA.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA"
      ]
    }, {
      "description": "The velocities for BAND used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.REPLICA.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND.REPLICA"
      ]
    }, {
      "description": "Controls the printing of each replica info during a BAND run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.REPLICA_INFO",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Specify coordinates and velocities (possibly) of the replica",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.REPLICA",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "Controls parameters for String Method type calculation only.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND.STRING_METHOD",
      "superNames": [
        "x_cp2k_section_input_MOTION.BAND"
      ]
    }, {
      "description": "The section that controls a BAND run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.BAND",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Controls the printing of Hessian Restart file",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.BFGS.RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.BFGS"
      ]
    }, {
      "description": "Provides parameters to tune the BFGS optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.BFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the two point based line search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.2PNT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the gold search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH.GOLD",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search during the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.CG.LINE_SEARCH",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT.CG"
      ]
    }, {
      "description": "Provides parameters to tune the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.CG",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the limited memory BFGS (LBFGS) optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT.LBFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.CELL_OPT"
      ]
    }, {
      "description": "This section sets the environment for the optimization of the simulation cell. Two possible schemes are available: (1) Zero temperature optimization;  (2) Finite temperature optimization.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CELL_OPT",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Activate and specify information on restraint instead of constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE"
      ]
    }, {
      "description": "Used to constraint collective (general) degrees of freedom, writing langrangian multipliers to file.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.COLLECTIVE",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Specify restart position only for COLVAR restraints.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.COLVAR_RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Prints information about iterative constraints solutions",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.CONSTRAINT_INFO",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Specify restart position only for FIXED_ATOMS restraints.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.FIX_ATOM_RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Activate and specify information on restraint instead of constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS"
      ]
    }, {
      "description": "This section is used to constraint the overall atomic position (X,Y,Z). In case a restraint is specified the value of the TARGET is considered to be the value of the coordinates at the beginning of the run or alternatively the corresponding value in the section: FIX_ATOM_RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.FIXED_ATOMS",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Activate and specify information on restraint instead of constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3"
      ]
    }, {
      "description": "This section is used to set 3x3 (3 atoms and 3 distances) constraints.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.G3X3",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Activate and specify information on restraint instead of constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6"
      ]
    }, {
      "description": "This section is used to set 4x6 (4 atoms and 6 distances) constraints.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.G4X6",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Activate and specify information on restraint instead of constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS"
      ]
    }, {
      "description": "This section is used to set bonds constraints involving Hydrogen atoms",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.HBONDS",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Prints out the lagrange multipliers of the specified constraints during an MD.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.LAGRANGE_MULTIPLIERS",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Activate and specify information on restraint instead of constraint",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE.RESTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE"
      ]
    }, {
      "description": "This section is used to set a virtual interaction-site constraint.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT.VIRTUAL_SITE",
      "superNames": [
        "x_cp2k_section_input_MOTION.CONSTRAINT"
      ]
    }, {
      "description": "Section specifying information regarding how to impose constraints on the system.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.CONSTRAINT",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "This section defines the parameters needed to run in i-PI driver mode.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.DRIVER",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Controls the printing of FP info at startup",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.CONTROL",
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "Controls the printing of FP info during flexible partitioning simulations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING.WEIGHTS",
      "superNames": [
        "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING"
      ]
    }, {
      "description": "This section sets up flexible_partitioning",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FLEXIBLE_PARTITIONING",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Controls the calculation of delta free energies with the alchemical change method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.ALCHEMICAL_CHANGE",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY"
      ]
    }, {
      "description": "Controls the printing of basic and summary information during the Free Energy calculation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.FREE_ENERGY_INFO",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY"
      ]
    }, {
      "description": "Colvar force within an extended Lagrangian formalism.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_FS",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Colvar position within an extended Lagrangian formalism.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_SS0",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Colvar Theta within an extended Lagrangian formalism.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_SS",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Colvar velocities within an extended Lagrangian formalism.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.EXT_LAGRANGE_VVP",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Parameters controlling the gaussian wall.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.GAUSSIAN",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL"
      ]
    }, {
      "description": "Parameters controlling the quadratic wall",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUADRATIC",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL"
      ]
    }, {
      "description": "Parameters controlling the quartic wall",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.QUARTIC",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL"
      ]
    }, {
      "description": "Parameters controlling the reflective wall",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL.REFLECTIVE",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL"
      ]
    }, {
      "description": "Controls the activation of walls on COLVAR during a metadynamic run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR.WALL",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR"
      ]
    }, {
      "description": "This section specify the nature of the collective variables.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.METAVAR",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "Specify the basename for the NUMBER_OF_WALKERS files used to communicate between the walkers. Absolute path can be input as well together with the filename. One file will be created for each spawned hill.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS.WALKERS_FILE_NAME",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS"
      ]
    }, {
      "description": "Enables and configures the metadynamics using multiple walkers.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.MULTIPLE_WALKERS",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "The height of the spawned hills during metadynamics.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_HEIGHT",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "The inverse of the DELTA_T parameter used for Well-Tempered metadynamics.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_INVDT",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "The position of the spawned hills during metadynamics.Used for RESTART.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_POS",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "The scales of the spawned hills during metadynamics.Used for RESTART. When a scale is zero in one or more directions, the Gaussian hill is assumed to be infinitely wide in those directions. The latter can be used to combine spawned hills from multiple 1D metadynamics runs in one multidimensional metadynamics run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN.SPAWNED_HILLS_SCALE",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN"
      ]
    }, {
      "description": "This section sets parameters to set up a calculation of metadynamics.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.METADYN",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY"
      ]
    }, {
      "description": "This section specify parameters controlling the convergence of the free energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.CONVERGENCE_CONTROL",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION"
      ]
    }, {
      "description": "This section specify the nature of the collective variables used in computing the free energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION.UVAR",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION"
      ]
    }, {
      "description": "Controls the calculation of free energy derivatives with the umbrella integration method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY.UMBRELLA_INTEGRATION",
      "superNames": [
        "x_cp2k_section_input_MOTION.FREE_ENERGY"
      ]
    }, {
      "description": "Controls the calculation of free energy and free energy derivatives with different possible methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.FREE_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Controls the printing of Hessian Restart file",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.BFGS.RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.BFGS"
      ]
    }, {
      "description": "Provides parameters to tune the BFGS optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.BFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the two point based line search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.2PNT",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the gold search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH.GOLD",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search during the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.CG.LINE_SEARCH",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.CG"
      ]
    }, {
      "description": "Provides parameters to tune the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.CG",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the limited memory BFGS (LBFGS) optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.LBFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "Specifies the initial dimer vector (used frequently to restart DIMER calculations). If not provided the starting orientation of the dimer is chosen randomly.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.DIMER_VECTOR",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER"
      ]
    }, {
      "description": "Controls the printing of Hessian Restart file",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS.RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS"
      ]
    }, {
      "description": "Provides parameters to tune the BFGS optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.BFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the two point based line search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.2PNT",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the gold search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH.GOLD",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search during the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG.LINE_SEARCH",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG"
      ]
    }, {
      "description": "Provides parameters to tune the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.CG",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the limited memory BFGS (LBFGS) optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT.LBFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT"
      ]
    }, {
      "description": "This section sets the environment for the optimization of the rotation of the Dimer.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER.ROT_OPT",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER"
      ]
    }, {
      "description": "Specifies parameters for Dimer Method",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE.DIMER",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE"
      ]
    }, {
      "description": "Specifies parameters to perform a transition state search",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT.TRANSITION_STATE",
      "superNames": [
        "x_cp2k_section_input_MOTION.GEO_OPT"
      ]
    }, {
      "description": "This section sets the environment of the geometry optimizer.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.GEO_OPT",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Parameters for Aggregation Volume Bias Monte Carlo (AVBMC) which explores cluster formation and destruction. Chen and Siepmann, J. Phys. Chem. B 105, 11275-11282 (2001).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.AVBMC",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Maximum displacements for any move that is performed on each simulation box.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.BOX_DISPLACEMENTS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS"
      ]
    }, {
      "description": "Maximum displacements for every move type that requires a value for each molecular type in the simulation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS.MOL_DISPLACEMENTS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS"
      ]
    }, {
      "description": "The maximum displacements for all attempted moves.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MAX_DISPLACEMENTS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Probabilities of attempting various moves types on the box.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.BOX_PROBABILITIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "Probabilities of attempting various moves types on the various molecular types present in the simulation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES.MOL_PROBABILITIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES"
      ]
    }, {
      "description": "Parameters for fraction of moves performed for each move type.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MOVE_PROBABILITIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "Frequency for updating move maximum displacements.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC.MOVE_UPDATES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MC"
      ]
    }, {
      "description": "This section sets parameters to set up a MonteCarlo calculation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MC",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "This section provides the possibility to define arbitrary region  for the fast thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.DEFINE_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST"
      ]
    }, {
      "description": "The positions for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "The forces for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.FORCE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "The masses for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "The velocities for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE"
      ]
    }, {
      "description": "paramameters of the Nose Hoover thermostat chain",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST.NOSE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST"
      ]
    }, {
      "description": "Specify thermostat type and parameters controlling the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_FAST",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "This section provides the possibility to define arbitrary region  for the slow thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.DEFINE_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW"
      ]
    }, {
      "description": "The positions for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "The forces for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.FORCE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "The masses for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "The velocities for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE"
      ]
    }, {
      "description": "paramameters of the Nose Hoover thermostat chain",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW.NOSE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW"
      ]
    }, {
      "description": "Specify thermostat type and parameters controlling the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS.THERMOSTAT_SLOW",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS"
      ]
    }, {
      "description": "Parameters used in canonical adiabatic free energy sampling (CAFES).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.ADIABATIC_DYNAMICS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Controls the output the averaged quantities",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.AVERAGES.PRINT_AVERAGES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES"
      ]
    }, {
      "description": "Stores information for restarting averages.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.AVERAGES.RESTART_AVERAGES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.AVERAGES"
      ]
    }, {
      "description": "Controls the calculation of the averages during an MD run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.AVERAGES",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "The masses for BAROSTAT used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Information to initialize the Ad-Langevin thermostat DOF CHI",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.CHI",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Information to initialize the Ad-Langevin thermostat DOF MASS",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Parameters of the adaptive-Langevin thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.AD_LANGEVIN",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Parameters of the canonical sampling through velocity rescaling thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.CSVR",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "The s variable for GLE used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.S",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE"
      ]
    }, {
      "description": "paramameters of the gle thermostat. This section can be generated  from https://epfl-cosmo.github.io/gle4md/index.html?page=matrix",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.GLE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT"
      ]
    }, {
      "description": "The positions for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The forces for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.FORCE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The masses for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The velocities for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "paramameters of the Nose Hoover thermostat chain",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT.NOSE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT"
      ]
    }, {
      "description": "Specify thermostat type and parameters controlling the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.THERMOSTAT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "The velocities for BAROSTAT used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.BAROSTAT"
      ]
    }, {
      "description": "Parameters of barostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.BAROSTAT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Defines a list of atoms for which the initial velocities are modified",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.CASCADE.ATOM_LIST",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.CASCADE"
      ]
    }, {
      "description": "Defines the parameters for the setup of a cascade simulation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.CASCADE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Controls the set of parameters to run a Langevin MD. The integrator used follows that given in the article by Ricci et al. The user can define regions in the system where the atoms inside undergoes Langevin MD, while those outside the regions undergoes NVE Born Oppenheimer MD. To define the regions, the user should use THERMAL_REGION subsection of MOTION%MD. The theory for Langevin MD involving sub-regions can be found in articles by Kantorovitch et al. All the references can be found in the links below.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.LANGEVIN",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Parameters for Multi-Scale Shock Technique (MSST) which simulate the effect of a steady planar shock on a unit cell. Reed et. al. Physical Review Letters 90, 235503 (2003).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.MSST",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "This section provides the possibility to define arbitrary region  for the MSD calculation.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD.DEFINE_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD"
      ]
    }, {
      "description": "Loads an external trajectory file and performs analysis on the loaded snapshots.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.REFTRAJ.MSD",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.REFTRAJ"
      ]
    }, {
      "description": "Loads an external trajectory file and performs analysis on the loaded snapshots.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.REFTRAJ",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Multiple timestep integration based on RESPA (implemented for NVE only). RESPA exploits multiple force_eval. In this case the order of the force_eval maps  the order of the respa shells from the slowest to the fastest force evaluation. If force_evals share the same subsys, it's enough then to specify the  subsys in the force_eval corresponding at the first index in the multiple_force_eval list. Can be used to speedup classical and ab initio MD simulations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.RESPA",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Information to initialize the Ad-Langevin thermostat DOF CHI",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.CHI",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Information to initialize the Ad-Langevin thermostat DOF MASS",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Parameters of the adaptive-Langevin thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.AD_LANGEVIN",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Parameters of the canonical sampling through velocity rescaling thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.CSVR",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "This section provides the possibility to define arbitrary region  for the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.DEFINE_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "The s variable for GLE used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE.S",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE"
      ]
    }, {
      "description": "paramameters of the gle thermostat. This section can be generated  from https://epfl-cosmo.github.io/gle4md/index.html?page=matrix",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.GLE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "The positions for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The forces for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.FORCE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The masses for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The velocities for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "paramameters of the Nose Hoover thermostat chain",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT.NOSE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT"
      ]
    }, {
      "description": "Specify thermostat type and parameters controlling the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL.THERMOSTAT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.SHELL"
      ]
    }, {
      "description": "Parameters of shell model in adiabatic dynamics.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.SHELL",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "This section provides the possibility to define arbitrary region",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMAL_REGION.DEFINE_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMAL_REGION"
      ]
    }, {
      "description": "Define regions where different initialization and control of the temperature is used. When MOTION%MD%ENSEMBLE is set to LANGEVIN, this section controls if the atoms defined inside and outside the thermal regions should undergo Langevin MD or NVE Born-Oppenheimer MD. The theory behind Langevin MD using different regions can be found in articles by Kantorovitch et al. listed below.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMAL_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "Information to initialize the Ad-Langevin thermostat DOF CHI",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.CHI",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Information to initialize the Ad-Langevin thermostat DOF MASS",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN"
      ]
    }, {
      "description": "Parameters of the adaptive-Langevin thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.AD_LANGEVIN",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR"
      ]
    }, {
      "description": "Parameters of the canonical sampling through velocity rescaling thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.CSVR",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "This section provides the possibility to define arbitrary region  for the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.DEFINE_REGION",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "The s variable for GLE used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE.S",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE"
      ]
    }, {
      "description": "paramameters of the gle thermostat. This section can be generated  from https://epfl-cosmo.github.io/gle4md/index.html?page=matrix",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.GLE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "The positions for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The forces for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.FORCE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The masses for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.MASS",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "The velocities for NOSE HOOVER used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE"
      ]
    }, {
      "description": "paramameters of the Nose Hoover thermostat chain",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT.NOSE",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD.THERMOSTAT"
      ]
    }, {
      "description": "Specify thermostat type and parameters controlling the thermostat.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.THERMOSTAT",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "A method to initialize the velocities along low-curvature directions in order to favors MD trajectories to cross rapidly over small energy barriers into neighboring basins. In each iteration the forces are calculated at a point y, which is slightly displaced from the current positions x in the direction of the original velocities v. The velocities are then updated with the force component F_t, which is perpendicular to N. N = v / |v|;  y = x + delta * N;  F_t = F(y) - â© F(y) | N âª * N; v' = v + alpha * F_t",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD.VELOCITY_SOFTENING",
      "superNames": [
        "x_cp2k_section_input_MOTION.MD"
      ]
    }, {
      "description": "This section defines the whole set of parameters needed perform an MD run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.MD",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "The positions for BEADS used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.BEADS.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.BEADS"
      ]
    }, {
      "description": "The velocities for BEADS used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.BEADS.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.BEADS"
      ]
    }, {
      "description": "Sets positions and velocities of the beads",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.BEADS",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Information to initialize the parallel random number generator streams",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.GLE.RNG_INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "The s variable for GLE used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.GLE.S",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "Information to initialize the CSVR thermostat energy.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.GLE.THERMOSTAT_ENERGY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.GLE"
      ]
    }, {
      "description": "paramameters of the gle thermostat. This section can be generated  from https://epfl-cosmo.github.io/gle4md/index.html?page=matrix",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.GLE",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "The positions for HELIUM used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Forces exerted by the helium on the solute system (used for restarts)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.FORCE",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Permutation cycle length sampling settings",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.M-SAMPLING",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Permutation state used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.PERM",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Radial distribution function generation settings",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.RDF",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Density data used for restarts",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO.CUBE_DATA",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO"
      ]
    }, {
      "description": "Density distribution settings",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.RHO",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "Random number generator state for all processors",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM.RNG_STATE",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.HELIUM"
      ]
    }, {
      "description": "The section that controls optional helium solvent environment (highly experimental, not for general use yet)",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.HELIUM",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Controls the initialization if the beads are not present",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.INIT",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "Controls the normal mode transformation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.NORMALMODE",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "The positions for NOSE used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.NOSE.COORD",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NOSE"
      ]
    }, {
      "description": "The velocities for NOSE used for restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.NOSE.VELOCITY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT.NOSE"
      ]
    }, {
      "description": "Controls the Nose-Hoover thermostats",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.NOSE",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "The section that controls the staging transformation",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT.STAGING",
      "superNames": [
        "x_cp2k_section_input_MOTION.PINT"
      ]
    }, {
      "description": "The section that controls a path integral run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PINT",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CELL.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CELL"
      ]
    }, {
      "description": "Controls the output of the simulation cell. For later analysis of the trajectory it is recommendable that the frequency of printing is the same as the one used for the trajectory file.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CELL",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES"
      ]
    }, {
      "description": "controls the output of the forces on cores when shell-model is used",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CORE_FORCES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY"
      ]
    }, {
      "description": "Controls the output of the trajectory of cores when the shell-model is used",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CORE_TRAJECTORY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES"
      ]
    }, {
      "description": "controls the output of the velocities of cores when the shell model is used",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.CORE_VELOCITIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS"
      ]
    }, {
      "description": "Controls the output of the force mixing (FORCE_EVAL&QMMM&FORCE_MIXING) labels",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.FORCE_MIXING_LABELS",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.FORCES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.FORCES"
      ]
    }, {
      "description": "Controls the output of the forces",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.FORCES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES"
      ]
    }, {
      "description": "Controls the output of the energies of the tworegular FORCE_EVALS in the MIXED methodprinted is step,time,Etot,E_F1,E_F2,CONS_QNT",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.MIXED_ENERGIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.RESTART.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY"
      ]
    }, {
      "description": "Dumps unique restart files during the run keeping all of them.Most useful if recovery is needed at a later point.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.RESTART_HISTORY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "Controls the dumping of the restart file during runs. By default keeps a short history of three restarts. See also RESTART_HISTORY",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES"
      ]
    }, {
      "description": "controls the output of the forces on shells when shell-model is used",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.SHELL_FORCES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY"
      ]
    }, {
      "description": "Controls the output of the trajectory of shells when the shell-model is used",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.SHELL_TRAJECTORY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES"
      ]
    }, {
      "description": "Controls the output of the velocities of shells when the shell model is used",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.SHELL_VELOCITIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.STRESS.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRESS"
      ]
    }, {
      "description": "Controls the output of the stress tensor",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.STRESS",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA"
      ]
    }, {
      "description": "Request the printing of special structure data during a structure optimization (in MOTION%PRINT) or when setting up a subsys (in SUBSYS%PRINT).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.STRUCTURE_DATA",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY"
      ]
    }, {
      "description": "Controls the output of the trajectory",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.TRAJECTORY",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR"
      ]
    }, {
      "description": "Dumps the translation vector applied along an MD (if any). Useful for postprocessing of QMMM trajectories in which the QM fragment is continuously centered in the QM box",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.TRANSLATION_VECTOR",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.VELOCITIES.EACH",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT.VELOCITIES"
      ]
    }, {
      "description": "Controls the output of the velocities",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT.VELOCITIES",
      "superNames": [
        "x_cp2k_section_input_MOTION.PRINT"
      ]
    }, {
      "description": "Controls the printing properties during an MD run",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.PRINT",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "Controls the printing of Hessian Restart file",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS.RESTART",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS"
      ]
    }, {
      "description": "Provides parameters to tune the BFGS optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.BFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the two point based line search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.2PNT",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search for the gold search.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH.GOLD",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH"
      ]
    }, {
      "description": "Provides parameters to tune the line search during the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.CG.LINE_SEARCH",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT.CG"
      ]
    }, {
      "description": "Provides parameters to tune the conjugate gradient optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.CG",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "Provides parameters to tune the limited memory BFGS (LBFGS) optimization",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT.LBFGS",
      "superNames": [
        "x_cp2k_section_input_MOTION.SHELL_OPT"
      ]
    }, {
      "description": "This section sets the environment for the optimization of the shell-core distances that might turn to be necessary along a MD run using a shell-model potential.  The optimization procedure is activated when at least one of the shell-core pairs becomes too elongated,  i.e. when the assumption of point dipole is not longer valid.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.SHELL_OPT",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "This section specifies the TMC move type, and its properties. Selectable types are: ATOM_TRANS atom translation, MOL_TRANS molecule translation, MOL_ROT molecule rotation, PROT_REORDER proton reordering, PT_SWAP Parallel Tempering swap, VOL_MOVE volume change, ATOM_SWAP swaps two atoms of different type.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.MOVE_TYPE",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "This section specifies the TMC move type, and its properties. Selectable types are: ATOM_TRANS atom translation, MOL_TRANS molecule translation, MOL_ROT molecule rotation, PROT_REORDER proton reordering, PT_SWAP Parallel Tempering swap, VOL_MOVE volume change, ATOM_SWAP swaps two atoms of different type.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.NMC_MOVES.MOVE_TYPE",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.NMC_MOVES"
      ]
    }, {
      "description": "This section specifies the TMC move types, which are performed within the nested Monte Carlo (NMC). thus using the approximate potential.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.NMC_MOVES",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "This section specifies the charge of the MM atoms",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS.CHARGE",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS"
      ]
    }, {
      "description": "This section specifies the charge of the MM atoms",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES.CHARGE",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES"
      ]
    }, {
      "description": "Analysing the Markov Chain elments with the specified methods, reading form default or specified files",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS_FILES",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "Analysing the Markov Chain elments with the specified methods",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC.TMC_ANALYSIS",
      "superNames": [
        "x_cp2k_section_input_MOTION.TMC"
      ]
    }, {
      "description": "A parallelized MC algorithm, presampling the configurations, espacially the Markov chain elements",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION.TMC",
      "superNames": [
        "x_cp2k_section_input_MOTION"
      ]
    }, {
      "description": "This section defines a set of tool connected with the motion of the nuclei.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MOTION",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Describes how to handle multiple force_evals.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_MULTIPLE_FORCE_EVALS",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "specicifies contraints for the exponents to be fitted. Only a single constraint can be applied to an exponent",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.CONSTRAIN_EXPONENTS",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "This section can be used to create subsets of a basis  which will be fitted at the same time. This is especially useful if connected bsis sets e.g. TZVP, DZVP, SZV should be fitted.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND.DERIVED_BASIS_SETS",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND"
      ]
    }, {
      "description": "specicifies the atomic kinds to be fitted and the basis sets associated with the kind.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_BASIS.FIT_KIND",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "sets the parameters for optimizition, output frequency and restarts",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_BASIS.OPTIMIZATION",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "specicifies the location in which the files necessary for fitting procedure are located. Each Training set needs a reptition of this section.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_BASIS.TRAINING_FILES",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_BASIS"
      ]
    }, {
      "description": "describes a basis optimization job, in which an ADMM like approach is used to find the best exponents and/or coefficients to match a given training set.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_BASIS",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "A comparison of energies between fit and reference",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_ENERGIES",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "A comparison of forces between fit and reference",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING.COMPARE_FORCES",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING"
      ]
    }, {
      "description": "Specify the force matching input.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT.FORCE_MATCHING",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "writes a history of the function value and parameters",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT.HISTORY",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "writes an input file that can be used to restart",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT.RESTART",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "Defines initial values for variables and their labels",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT.VARIABLE",
      "superNames": [
        "x_cp2k_section_input_OPTIMIZE_INPUT"
      ]
    }, {
      "description": "describes an input optimization job, in which parameters in input files get optimized.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_OPTIMIZE_INPUT",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Section controling the history of visited minima and how minima are recognized at a later point.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM.GLOBAL_OPT.HISTORY",
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Printkey to controll the writting of the minima trajectory. This trajectory contains all encountered local minima.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING.MINIMA_TRAJECTORY",
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING"
      ]
    }, {
      "description": "Section controls Minima Crawling run.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_CRAWLING",
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Section controlling the Minima Hopping method.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM.GLOBAL_OPT.MINIMA_HOPPING",
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Printkey to controll the writting of the progress trajectory. This trajectory contains the minima, which are lower in energy than the by then lowerest.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM.GLOBAL_OPT.PROGRESS_TRAJECTORY",
      "superNames": [
        "x_cp2k_section_input_SWARM.GLOBAL_OPT"
      ]
    }, {
      "description": "Section to control global geometry optimizations.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM.GLOBAL_OPT",
      "superNames": [
        "x_cp2k_section_input_SWARM"
      ]
    }, {
      "description": "Section to control swarm runs. The swarm framework provides a common ground for master/worker algorithms.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_SWARM",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "Benchmark and test the cp_dbcsr routines",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.CP_DBCSR",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Benchmark and test the cp_fm_gemm routines by multiplying C=A*B",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.CP_FM_GEMM",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Benchmark and test the eigensolver routines.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.EIGENSOLVER",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Controls the printing of information regarding the PW and RS grid structures (ONLY for TEST run).",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.GRID_INFORMATION",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "controls the printing of tests output",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.PROGRAM_RUN_INFO",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Benchmark and test the pw_transfer routines.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.PW_TRANSFER",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Set options that influence how the realspace grids are being distributed in parallel runs.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.RS_PW_TRANSFER.RS_GRID",
      "superNames": [
        "x_cp2k_section_input_TEST.RS_PW_TRANSFER"
      ]
    }, {
      "description": "Describes how to benchmark the rs_pw_transfer routines.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST.RS_PW_TRANSFER",
      "superNames": [
        "x_cp2k_section_input_TEST"
      ]
    }, {
      "description": "Tests to perform on the supported libraries.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_TEST",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "All parameters needed for the tracking of modes dominated by the motion of selected atoms",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE.INVOLVED_ATOMS",
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE"
      ]
    }, {
      "description": "All parameters needed for to run a mode selective vibrational analysis",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_VIBRATIONAL_ANALYSIS.MODE_SELECTIVE",
      "superNames": [
        "x_cp2k_section_input_VIBRATIONAL_ANALYSIS"
      ]
    }, {
      "description": "Section to setup parameters to perform a Normal Modes analysis.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input_VIBRATIONAL_ANALYSIS",
      "superNames": [
        "x_cp2k_section_input"
      ]
    }, {
      "description": "This section contains the explicitly stated keywords, default keywords, and section parameters in the CP2K input file. Only some of the sections that control printing (PRINT, EACH) are supported, because including all of them would double the size of this metadata without adding much useful information. The hidden input keywords starting with a double underscore are not included.",
      "kindStr": "type_section",
      "name": "x_cp2k_section_input",
      "superNames": [
        "section_run"
      ]
    }]
}
